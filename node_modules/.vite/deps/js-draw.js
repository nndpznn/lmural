import "./chunk-XSCQBFM2.js";

// node_modules/js-draw/dist/mjs/commands/Command.mjs
var Command = class _Command {
  // Called when the command is being deleted
  onDrop(_editor) {
  }
  /** @deprecated Use {@link uniteCommands} */
  static union(a, b) {
    return new class extends _Command {
      apply(editor) {
        a.apply(editor);
        b.apply(editor);
      }
      unapply(editor) {
        b.unapply(editor);
        a.unapply(editor);
      }
      description(editor, localizationTable) {
        const aDescription = a.description(editor, localizationTable);
        const bDescription = b.description(editor, localizationTable);
        if (aDescription === bDescription) {
          return aDescription;
        }
        return `${aDescription}, ${bDescription}`;
      }
    }();
  }
};
Command.empty = new class extends Command {
  description(_editor, _localizationTable) {
    return "";
  }
  apply(_editor) {
  }
  unapply(_editor) {
  }
}();
var Command_default = Command;

// node_modules/@js-draw/math/dist/mjs/Vec3.mjs
var defaultEqlTolerance = 1e-10;
var Vec3Impl = class {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  get xy() {
    return {
      x: this.x,
      y: this.y
    };
  }
  /** Returns this' `idx`th component. For example, `Vec3.of(1, 2, 3).at(1) → 2`. */
  at(idx) {
    if (idx === 0)
      return this.x;
    if (idx === 1)
      return this.y;
    if (idx === 2)
      return this.z;
    throw new Error(`${idx} out of bounds!`);
  }
  length() {
    return this.magnitude();
  }
  magnitude() {
    return Math.sqrt(this.magnitudeSquared());
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  squareDistanceTo(p) {
    const dx = this.x - p.x;
    const dy = this.y - p.y;
    const dz = this.z - p.z;
    return dx * dx + dy * dy + dz * dz;
  }
  distanceTo(p) {
    return Math.sqrt(this.squareDistanceTo(p));
  }
  maximumEntryMagnitude() {
    return Math.max(Math.abs(this.x), Math.max(Math.abs(this.y), Math.abs(this.z)));
  }
  angle() {
    return Math.atan2(this.y, this.x);
  }
  normalized() {
    const norm = this.magnitude();
    return Vec3.of(this.x / norm, this.y / norm, this.z / norm);
  }
  normalizedOrZero() {
    if (this.eq(Vec3.zero)) {
      return Vec3.zero;
    }
    return this.normalized();
  }
  times(c) {
    return Vec3.of(this.x * c, this.y * c, this.z * c);
  }
  plus(v) {
    return Vec3.of(this.x + v.x, this.y + v.y, this.z + v.z);
  }
  minus(v) {
    return Vec3.of(this.x - v.x, this.y - v.y, this.z - v.z);
  }
  dot(other) {
    return this.x * other.x + this.y * other.y + this.z * other.z;
  }
  cross(other) {
    return Vec3.of(this.y * other.z - other.y * this.z, other.x * this.z - this.x * other.z, this.x * other.y - other.x * this.y);
  }
  scale(other) {
    if (typeof other === "number") {
      return this.times(other);
    }
    return Vec3.of(this.x * other.x, this.y * other.y, this.z * other.z);
  }
  orthog() {
    if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {
      return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();
    }
    return this.cross(Vec3.unitZ.times(-1)).normalized();
  }
  extend(distance, direction) {
    return this.plus(direction.normalized().times(distance));
  }
  lerp(target, fractionTo) {
    return this.times(1 - fractionTo).plus(target.times(fractionTo));
  }
  zip(other, zip) {
    return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, this.z));
  }
  map(fn) {
    return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(this.z, 2));
  }
  asArray() {
    return [this.x, this.y, this.z];
  }
  eq(other, fuzz = defaultEqlTolerance) {
    return Math.abs(other.x - this.x) <= fuzz && Math.abs(other.y - this.y) <= fuzz && Math.abs(other.z - this.z) <= fuzz;
  }
  toString() {
    return `Vec(${this.x}, ${this.y}, ${this.z})`;
  }
};
var Vec2Impl = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  get z() {
    return 0;
  }
  get xy() {
    return {
      x: this.x,
      y: this.y
    };
  }
  at(idx) {
    if (idx === 0)
      return this.x;
    if (idx === 1)
      return this.y;
    if (idx === 2)
      return 0;
    throw new Error(`${idx} out of bounds!`);
  }
  length() {
    return this.magnitude();
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y;
  }
  squareDistanceTo(p) {
    const dx = this.x - p.x;
    const dy = this.y - p.y;
    return dx * dx + dy * dy + p.z * p.z;
  }
  distanceTo(p) {
    return Math.sqrt(this.squareDistanceTo(p));
  }
  maximumEntryMagnitude() {
    return Math.max(Math.abs(this.x), Math.abs(this.y));
  }
  angle() {
    return Math.atan2(this.y, this.x);
  }
  normalized() {
    const norm = this.magnitude();
    return Vec2.of(this.x / norm, this.y / norm);
  }
  normalizedOrZero() {
    if (this.eq(Vec3.zero)) {
      return Vec3.zero;
    }
    return this.normalized();
  }
  times(c) {
    return Vec2.of(this.x * c, this.y * c);
  }
  plus(v) {
    return Vec3.of(this.x + v.x, this.y + v.y, v.z);
  }
  minus(v) {
    return Vec3.of(this.x - v.x, this.y - v.y, -v.z);
  }
  dot(other) {
    return this.x * other.x + this.y * other.y;
  }
  cross(other) {
    return Vec3.of(this.y * other.z, -this.x * other.z, this.x * other.y - other.x * this.y);
  }
  scale(other) {
    if (typeof other === "number") {
      return this.times(other);
    }
    return Vec2.of(this.x * other.x, this.y * other.y);
  }
  orthog() {
    if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {
      return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();
    }
    return this.cross(Vec3.unitZ.times(-1)).normalized();
  }
  extend(distance, direction) {
    return this.plus(direction.normalized().times(distance));
  }
  lerp(target, fractionTo) {
    return this.times(1 - fractionTo).plus(target.times(fractionTo));
  }
  zip(other, zip) {
    return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, 0));
  }
  map(fn) {
    return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(0, 2));
  }
  asArray() {
    return [this.x, this.y, 0];
  }
  eq(other, fuzz = defaultEqlTolerance) {
    return Math.abs(other.x - this.x) <= fuzz && Math.abs(other.y - this.y) <= fuzz && Math.abs(other.z) <= fuzz;
  }
  toString() {
    return `Vec(${this.x}, ${this.y})`;
  }
};
var Vec2;
(function(Vec22) {
  Vec22.of = (x, y) => {
    return new Vec2Impl(x, y);
  };
  Vec22.ofXY = ({ x, y }) => {
    return Vec22.of(x, y);
  };
  Vec22.unitX = Vec22.of(1, 0);
  Vec22.unitY = Vec22.of(0, 1);
  Vec22.zero = Vec22.of(0, 0);
})(Vec2 || (Vec2 = {}));
var Vec3;
(function(Vec32) {
  Vec32.of = (x, y, z) => {
    if (z === 0) {
      return Vec2.of(x, y);
    } else {
      return new Vec3Impl(x, y, z);
    }
  };
  Vec32.unitX = Vec2.unitX;
  Vec32.unitY = Vec2.unitY;
  Vec32.zero = Vec2.zero;
  Vec32.unitZ = Vec32.of(0, 0, 1);
})(Vec3 || (Vec3 = {}));
var Vec3_default = Vec3;

// node_modules/@js-draw/math/dist/mjs/Mat33.mjs
var Mat33 = class _Mat33 {
  /**
   * Creates a matrix from inputs in the form,
   * $$
   * \begin{bmatrix}
   *   a1 & a2 & a3 \\
   *   b1 & b2 & b3 \\
   *   c1 & c2 & c3
   * \end{bmatrix}
   * $$
   *
   * Static constructor methods are also available.
   * See {@link Mat33.scaling2D}, {@link Mat33.zRotation}, {@link Mat33.translation}, and {@link Mat33.fromCSSMatrix}.
   */
  constructor(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    this.a1 = a1;
    this.a2 = a2;
    this.a3 = a3;
    this.b1 = b1;
    this.b2 = b2;
    this.b3 = b3;
    this.c1 = c1;
    this.c2 = c2;
    this.c3 = c3;
    this.cachedInverse = void 0;
    this.rows = [Vec3_default.of(a1, a2, a3), Vec3_default.of(b1, b2, b3), Vec3_default.of(c1, c2, c3)];
  }
  /**
   * Creates a matrix from the given rows:
   * $$
   * \begin{bmatrix}
   *  \texttt{r1.x} & \texttt{r1.y} & \texttt{r1.z}\\
   *  \texttt{r2.x} & \texttt{r2.y} & \texttt{r2.z}\\
   *  \texttt{r3.x} & \texttt{r3.y} & \texttt{r3.z}\\
   * \end{bmatrix}
   * $$
   */
  static ofRows(r1, r2, r3) {
    return new _Mat33(r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y, r3.z);
  }
  /**
   * Either returns the inverse of this, or, if this matrix is singular/uninvertable,
   * returns Mat33.identity.
   *
   * This may cache the computed inverse and return the cached version instead of recomputing
   * it.
   */
  inverse() {
    return this.computeInverse() ?? _Mat33.identity;
  }
  invertable() {
    return this.computeInverse() !== null;
  }
  computeInverse() {
    if (this.cachedInverse !== void 0) {
      return this.cachedInverse;
    }
    const toIdentity = [this.rows[0], this.rows[1], this.rows[2]];
    const toResult = [Vec3_default.unitX, Vec3_default.unitY, Vec3_default.unitZ];
    for (let cursor = 0; cursor < 3; cursor++) {
      let pivot = toIdentity[cursor].at(cursor);
      const minDivideBy = 1e-10;
      if (Math.abs(pivot) < minDivideBy) {
        let swapIndex = -1;
        for (let i = 1; i <= 2; i++) {
          const otherRowIdx = (cursor + i) % 3;
          if (Math.abs(toIdentity[otherRowIdx].at(cursor)) >= minDivideBy) {
            swapIndex = otherRowIdx;
            break;
          }
        }
        if (swapIndex === -1) {
          this.cachedInverse = null;
          return null;
        }
        const tmpIdentityRow = toIdentity[cursor];
        const tmpResultRow = toResult[cursor];
        toIdentity[cursor] = toIdentity[swapIndex];
        toResult[cursor] = toResult[swapIndex];
        toIdentity[swapIndex] = tmpIdentityRow;
        toResult[swapIndex] = tmpResultRow;
        pivot = toIdentity[cursor].at(cursor);
      }
      let scale = 1 / pivot;
      toIdentity[cursor] = toIdentity[cursor].times(scale);
      toResult[cursor] = toResult[cursor].times(scale);
      const cursorToIdentityRow = toIdentity[cursor];
      const cursorToResultRow = toResult[cursor];
      for (let i = 1; i <= 2; i++) {
        const otherRowIdx = (cursor + i) % 3;
        scale = -toIdentity[otherRowIdx].at(cursor);
        toIdentity[otherRowIdx] = toIdentity[otherRowIdx].plus(cursorToIdentityRow.times(scale));
        toResult[otherRowIdx] = toResult[otherRowIdx].plus(cursorToResultRow.times(scale));
      }
    }
    const inverse = _Mat33.ofRows(toResult[0], toResult[1], toResult[2]);
    this.cachedInverse = inverse;
    return inverse;
  }
  transposed() {
    return new _Mat33(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3);
  }
  /**
   * [Right-multiplies](https://en.wikipedia.org/wiki/Matrix_multiplication) this by `other`.
   *
   * See also {@link transformVec3} and {@link transformVec2}.
   *
   * Example:
   * ```ts,runnable,console
   * import {Mat33, Vec2} from '@js-draw/math';
   * console.log(Mat33.identity.rightMul(Mat33.identity));
   *
   * // Create a matrix by right multiplying.
   * const scaleThenRotate =
   *   // The resultant matrix first scales by a factor of two
   *   Mat33.scaling2D(2).rightMul(
   *     // ...then rotates by pi/4 radians = 45 degrees.
   *     Mat33.zRotation(Math.PI / 4)
   *   );
   * console.log(scaleThenRotate);
   *
   * // Use scaleThenRotate to scale then rotate a vector.
   * console.log(scaleThenRotate.transformVec2(Vec2.unitX));
   * ```
   */
  rightMul(other) {
    other = other.transposed();
    const at = (row, col) => {
      return this.rows[row].dot(other.rows[col]);
    };
    return new _Mat33(at(0, 0), at(0, 1), at(0, 2), at(1, 0), at(1, 1), at(1, 2), at(2, 0), at(2, 1), at(2, 2));
  }
  /**
   * Applies this as an **affine** transformation to the given vector.
   * Returns a transformed version of `other`.
   *
   * Unlike {@link transformVec3}, this **does** translate the given vector.
   */
  transformVec2(other) {
    let intermediate = Vec3_default.of(other.x, other.y, 1);
    intermediate = this.transformVec3(intermediate);
    return Vec2.of(intermediate.x, intermediate.y);
  }
  /**
   * Applies this as a linear transformation to the given vector (doesn't translate).
   * This is the standard way of transforming vectors in ℝ³.
   */
  transformVec3(other) {
    return Vec3_default.of(this.rows[0].dot(other), this.rows[1].dot(other), this.rows[2].dot(other));
  }
  /** @returns true iff this is the identity matrix. */
  isIdentity() {
    if (this === _Mat33.identity) {
      return true;
    }
    return this.eq(_Mat33.identity);
  }
  /** Returns true iff this = other ± fuzz */
  eq(other, fuzz = 0) {
    for (let i = 0; i < 3; i++) {
      if (!this.rows[i].eq(other.rows[i], fuzz)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Creates a human-readable representation of the matrix.
   *
   * Example:
   * ```ts,runnable,console
   * import { Mat33 } from '@js-draw/math';
   * console.log(Mat33.identity.toString());
   * ```
   */
  toString() {
    let result = "";
    const maxColumnLens = [0, 0, 0];
    for (const row of this.rows) {
      for (let i = 0; i < 3; i++) {
        maxColumnLens[i] = Math.max(maxColumnLens[0], `${row.at(i)}`.length);
      }
    }
    for (let i = 0; i < 3; i++) {
      if (i === 0) {
        result += "⎡ ";
      } else if (i === 1) {
        result += "⎢ ";
      } else {
        result += "⎣ ";
      }
      for (let j = 0; j < 3; j++) {
        const val = this.rows[i].at(j).toString();
        let padding = "";
        for (let i2 = val.length; i2 < maxColumnLens[j]; i2++) {
          padding += " ";
        }
        result += val + ", " + padding;
      }
      if (i === 0) {
        result += " ⎤";
      } else if (i === 1) {
        result += " ⎥";
      } else {
        result += " ⎦";
      }
      result += "\n";
    }
    return result.trimEnd();
  }
  /**
   * ```
   * result[0] = top left element
   * result[1] = element at row zero, column 1
   * ...
   * ```
   *
   * Example:
   * ```ts,runnable,console
   * import { Mat33 } from '@js-draw/math';
   * console.log(
   *   new Mat33(
   *     1, 2, 3,
   *     4, 5, 6,
   *     7, 8, 9,
   *   )
   * );
   * ```
   */
  toArray() {
    return [this.a1, this.a2, this.a3, this.b1, this.b2, this.b3, this.c1, this.c2, this.c3];
  }
  /**
   * Returns a new `Mat33` where each entry is the output of the function
   * `mapping`.
   *
   * @example
   * ```
   * new Mat33(
   *  1, 2, 3,
   *  4, 5, 6,
   *  7, 8, 9,
   * ).mapEntries(component => component - 1);
   * // → ⎡ 0, 1, 2 ⎤
   * //   ⎢ 3, 4, 5 ⎥
   * //   ⎣ 6, 7, 8 ⎦
   * ```
   */
  mapEntries(mapping) {
    return new _Mat33(mapping(this.a1, [0, 0]), mapping(this.a2, [0, 1]), mapping(this.a3, [0, 2]), mapping(this.b1, [1, 0]), mapping(this.b2, [1, 1]), mapping(this.b3, [1, 2]), mapping(this.c1, [2, 0]), mapping(this.c2, [2, 1]), mapping(this.c3, [2, 2]));
  }
  /** Estimate the scale factor of this matrix (based on the first row). */
  getScaleFactor() {
    return Math.hypot(this.a1, this.a2);
  }
  /** Returns the `idx`-th column (`idx` is 0-indexed). */
  getColumn(idx) {
    return Vec3_default.of(this.rows[0].at(idx), this.rows[1].at(idx), this.rows[2].at(idx));
  }
  /** Returns the magnitude of the entry with the largest entry */
  maximumEntryMagnitude() {
    let greatestSoFar = Math.abs(this.a1);
    for (const entry of this.toArray()) {
      greatestSoFar = Math.max(greatestSoFar, Math.abs(entry));
    }
    return greatestSoFar;
  }
  /**
   * Constructs a 3x3 translation matrix (for translating `Vec2`s) using
   * **transformVec2**.
   *
   * Creates a matrix in the form
   * $$
   * 	\begin{pmatrix}
   * 		1 & 0 & {\tt amount.x}\\
   * 		0 & 1 & {\tt amount.y}\\
   * 		0 & 0 & 1
   * 	\end{pmatrix}
   * $$
   */
  static translation(amount) {
    return new _Mat33(1, 0, amount.x, 0, 1, amount.y, 0, 0, 1);
  }
  /**
   * Creates a matrix for rotating `Vec2`s about `center` by some number of `radians`.
   *
   * For this function, {@link Vec2}s are considered to be points in 2D space.
   *
   * For example,
   * ```ts,runnable,console
   * import { Mat33, Vec2 } from '@js-draw/math';
   *
   * const halfCircle = Math.PI; // PI radians = 180 degrees = 1/2 circle
   * const center = Vec2.of(1, 1); // The point (1,1)
   * const rotationMatrix = Mat33.zRotation(halfCircle, center);
   *
   * console.log(
   *   'Rotating (0,0) 180deg about', center, 'results in',
   *   // Rotates (0,0)
   *   rotationMatrix.transformVec2(Vec2.zero),
   * );
   * ```
   */
  static zRotation(radians, center = Vec2.zero) {
    if (radians === 0) {
      return _Mat33.identity;
    }
    const cos3 = Math.cos(radians);
    const sin3 = Math.sin(radians);
    let result = _Mat33.translation(center);
    result = result.rightMul(new _Mat33(cos3, -sin3, 0, sin3, cos3, 0, 0, 0, 1));
    return result.rightMul(_Mat33.translation(center.times(-1)));
  }
  static scaling2D(amount, center = Vec2.zero) {
    let result = _Mat33.translation(center);
    let xAmount, yAmount;
    if (typeof amount === "number") {
      xAmount = amount;
      yAmount = amount;
    } else {
      xAmount = amount.x;
      yAmount = amount.y;
    }
    result = result.rightMul(new _Mat33(xAmount, 0, 0, 0, yAmount, 0, 0, 0, 1));
    return result.rightMul(_Mat33.translation(center.times(-1)));
  }
  /**
   * **Note**: Assumes `this.c1 = this.c2 = 0` and `this.c3 = 1`.
   *
   * @see {@link fromCSSMatrix}
   */
  toCSSMatrix() {
    return `matrix(${this.a1},${this.b1},${this.a2},${this.b2},${this.a3},${this.b3})`;
  }
  /**
   * Converts a CSS-form `matrix(a, b, c, d, e, f)` to a Mat33.
   *
   * Note that such a matrix has the form,
   * ```
   * ⎡ a c e ⎤
   * ⎢ b d f ⎥
   * ⎣ 0 0 1 ⎦
   * ```
   */
  static fromCSSMatrix(cssString) {
    if (cssString === "" || cssString === "none") {
      return _Mat33.identity;
    }
    cssString = cssString.trim().replace(/\s+/g, " ");
    const parseArguments = (argumentString) => {
      const parsed = argumentString.split(/[, \t\n]+/g).map((argString) => {
        if (argString.trim() === "") {
          return null;
        }
        let isPercentage = false;
        if (argString.endsWith("%")) {
          isPercentage = true;
          argString = argString.substring(0, argString.length - 1);
        }
        argString = argString.replace(/px$/gi, "");
        const numberExp = /^[-]?\d*(?:\.\d*)?(?:[eE][-+]?\d+)?$/i;
        if (!numberExp.exec(argString)) {
          throw new Error(`All arguments to transform functions must be numeric (state: ${JSON.stringify({
            currentArgument: argString,
            allArguments: argumentString
          })})`);
        }
        let argNumber = parseFloat(argString);
        if (isPercentage) {
          argNumber /= 100;
        }
        return argNumber;
      });
      return parsed.filter((n) => n !== null);
    };
    const keywordToAction = {
      matrix: (matrixData) => {
        if (matrixData.length !== 6) {
          throw new Error(`Invalid matrix argument: ${matrixData}. Must have length 6`);
        }
        const a = matrixData[0];
        const b = matrixData[1];
        const c = matrixData[2];
        const d = matrixData[3];
        const e = matrixData[4];
        const f = matrixData[5];
        const transform = new _Mat33(a, c, e, b, d, f, 0, 0, 1);
        return transform;
      },
      scale: (scaleArgs) => {
        let scaleX, scaleY;
        if (scaleArgs.length === 1) {
          scaleX = scaleArgs[0];
          scaleY = scaleArgs[0];
        } else if (scaleArgs.length === 2) {
          scaleX = scaleArgs[0];
          scaleY = scaleArgs[1];
        } else {
          throw new Error(`The scale() function only supports two arguments. Given: ${scaleArgs}`);
        }
        return _Mat33.scaling2D(Vec2.of(scaleX, scaleY));
      },
      translate: (translateArgs) => {
        let translateX = 0;
        let translateY = 0;
        if (translateArgs.length === 1) {
          translateX = translateArgs[0];
        } else if (translateArgs.length === 2) {
          translateX = translateArgs[0];
          translateY = translateArgs[1];
        } else {
          throw new Error(`The translate() function requires either 1 or 2 arguments. Given ${translateArgs}`);
        }
        return _Mat33.translation(Vec2.of(translateX, translateY));
      }
    };
    const partRegex = /(?:^|\W)(\w+)\s?\(([^)]*)\)/gi;
    let match;
    let matrix = null;
    while ((match = partRegex.exec(cssString)) !== null) {
      const action = match[1].toLowerCase();
      if (!(action in keywordToAction)) {
        throw new Error(`Unsupported CSS transform action: ${action}`);
      }
      const args = parseArguments(match[2]);
      const currentMatrix = keywordToAction[action](args);
      if (!matrix) {
        matrix = currentMatrix;
      } else {
        matrix = matrix.rightMul(currentMatrix);
      }
    }
    return matrix ?? _Mat33.identity;
  }
};
Mat33.identity = new Mat33(1, 0, 0, 0, 1, 0, 0, 0, 1);
var Mat33_default = Mat33;

// node_modules/@js-draw/math/dist/mjs/shapes/Abstract2DShape.mjs
var Abstract2DShape = class _Abstract2DShape {
  /**
   * @returns the distance from `point` to this shape. If `point` is within this shape,
   * this returns the distance from `point` to the edge of this shape.
   *
   * @see {@link signedDistance}
   */
  distance(point) {
    return Math.abs(this.signedDistance(point));
  }
  /**
   * Returns `true` if and only if the given `point` is contained within this shape.
   *
   * `epsilon` is a small number used to counteract floating point error. Thus, if
   * `point` is within `epsilon` of the inside of this shape, `containsPoint` may also
   * return `true`.
   *
   * The default implementation relies on `signedDistance`.
   * Subclasses may override this method to provide a more efficient implementation.
   */
  containsPoint(point, epsilon2 = _Abstract2DShape.smallValue) {
    return this.signedDistance(point) < epsilon2;
  }
  /**
   * Returns a bounding box that **loosely** fits the content of this shape.
   *
   * The result of this call can be larger than the result of {@link getTightBoundingBox},
   * **but should not be smaller**. Thus, a call to `getLooseBoundingBox` can be significantly
   * faster than a call to {@link getTightBoundingBox} for some shapes.
   */
  getLooseBoundingBox() {
    return this.getTightBoundingBox();
  }
};
Abstract2DShape.smallValue = 1e-12;
var Abstract2DShape_default = Abstract2DShape;

// node_modules/@js-draw/math/dist/mjs/shapes/Rect2.mjs
var Rect2 = class _Rect2 extends Abstract2DShape_default {
  constructor(x, y, w, h) {
    super();
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    if (w < 0) {
      this.x += w;
      this.w = Math.abs(w);
    }
    if (h < 0) {
      this.y += h;
      this.h = Math.abs(h);
    }
    this.topLeft = Vec2.of(this.x, this.y);
    this.size = Vec2.of(this.w, this.h);
    this.area = this.w * this.h;
  }
  translatedBy(vec) {
    return new _Rect2(vec.x + this.x, vec.y + this.y, this.w, this.h);
  }
  // Returns a copy of this with the given size (but same top-left).
  resizedTo(size) {
    return new _Rect2(this.x, this.y, size.x, size.y);
  }
  containsPoint(other) {
    return this.x <= other.x && this.y <= other.y && this.x + this.w >= other.x && this.y + this.h >= other.y;
  }
  /** @returns true iff `other` is completely within this `Rect2`. */
  containsRect(other) {
    return this.x <= other.x && this.y <= other.y && this.x + this.w >= other.x + other.w && this.y + this.h >= other.y + other.h;
  }
  /**
   * @returns true iff this and `other` overlap
   */
  intersects(other) {
    const thisMinX = this.x;
    const thisMaxX = thisMinX + this.w;
    const otherMinX = other.x;
    const otherMaxX = other.x + other.w;
    if (thisMaxX < otherMinX || thisMinX > otherMaxX) {
      return false;
    }
    const thisMinY = this.y;
    const thisMaxY = thisMinY + this.h;
    const otherMinY = other.y;
    const otherMaxY = other.y + other.h;
    if (thisMaxY < otherMinY || thisMinY > otherMaxY) {
      return false;
    }
    return true;
  }
  // Returns the overlap of this and [other], or null, if no such
  //          overlap exists
  intersection(other) {
    if (!this.intersects(other)) {
      return null;
    }
    const topLeft = this.topLeft.zip(other.topLeft, Math.max);
    const bottomRight = this.bottomRight.zip(other.bottomRight, Math.min);
    return _Rect2.fromCorners(topLeft, bottomRight);
  }
  // Returns a new rectangle containing both [this] and [other].
  union(other) {
    return _Rect2.union(this, other);
  }
  // Returns a the subdivision of this into [columns] columns
  // and [rows] rows. For example,
  //	 Rect2.unitSquare.divideIntoGrid(2, 2)
  //		-> [ Rect2(0, 0, 0.5, 0.5), Rect2(0.5, 0, 0.5, 0.5), Rect2(0, 0.5, 0.5, 0.5), Rect2(0.5, 0.5, 0.5, 0.5) ]
  // The rectangles are ordered in row-major order.
  divideIntoGrid(columns, rows) {
    const result = [];
    if (columns <= 0 || rows <= 0) {
      return result;
    }
    const eachRectWidth = this.w / columns;
    const eachRectHeight = this.h / rows;
    if (eachRectWidth === 0) {
      columns = 1;
    }
    if (eachRectHeight === 0) {
      rows = 1;
    }
    for (let j = 0; j < rows; j++) {
      for (let i = 0; i < columns; i++) {
        const x = eachRectWidth * i + this.x;
        const y = eachRectHeight * j + this.y;
        result.push(new _Rect2(x, y, eachRectWidth, eachRectHeight));
      }
    }
    return result;
  }
  // Returns a rectangle containing this and [point].
  // [margin] is the minimum distance between the new point and the edge
  // of the resultant rectangle.
  grownToPoint(point, margin = 0) {
    const otherRect = new _Rect2(point.x - margin, point.y - margin, margin * 2, margin * 2);
    return this.union(otherRect);
  }
  // Returns this grown by [margin] in both the x and y directions.
  grownBy(margin) {
    if (margin === 0) {
      return this;
    }
    if (margin < 0) {
      const xMargin = -Math.min(-margin, this.w / 2);
      const yMargin = -Math.min(-margin, this.h / 2);
      return new _Rect2(this.x - xMargin, this.y - yMargin, this.w + xMargin * 2, this.h + yMargin * 2);
    }
    return new _Rect2(this.x - margin, this.y - margin, this.w + margin * 2, this.h + margin * 2);
  }
  /**
   * If this rectangle is smaller than `minSize`, returns a copy of this
   * with a larger width/height.
   *
   * If smaller than `minSize`, padding is applied on both sides.
   */
  grownToSize(minSize) {
    if (this.width >= minSize.x && this.height >= minSize.y) {
      return this;
    }
    const deltaWidth = Math.max(0, minSize.x - this.width);
    const deltaHeight = Math.max(0, minSize.y - this.height);
    return new _Rect2(this.x - deltaWidth / 2, this.y - deltaHeight / 2, this.width + deltaWidth, this.height + deltaHeight);
  }
  getClosestPointOnBoundaryTo(target) {
    const closestEdgePoints = this.getEdges().map((edge) => {
      return edge.closestPointTo(target);
    });
    let closest = null;
    let closestDist = null;
    for (const point of closestEdgePoints) {
      const dist = point.distanceTo(target);
      if (closestDist === null || dist < closestDist) {
        closest = point;
        closestDist = dist;
      }
    }
    return closest;
  }
  /**
   * Returns `true` iff all points in this rectangle are within `distance` from `point`:
   *
   * If $R$ is the set of points in this rectangle, returns `true` iff
   * $$
   * 	\forall {\bf a} \in R, \|\texttt{point} - {\bf a}\| < \texttt{radius}
   * $$
   */
  isWithinRadiusOf(radius, point) {
    if (this.maxDimension > radius) {
      return false;
    }
    const squareRadius = radius * radius;
    return this.corners.every((corner) => corner.minus(point).magnitudeSquared() < squareRadius);
  }
  get corners() {
    return [this.bottomRight, this.topRight, this.topLeft, this.bottomLeft];
  }
  get maxDimension() {
    return Math.max(this.w, this.h);
  }
  get minDimension() {
    return Math.min(this.w, this.h);
  }
  get bottomRight() {
    return this.topLeft.plus(this.size);
  }
  get topRight() {
    return this.bottomRight.plus(Vec2.of(0, -this.h));
  }
  get bottomLeft() {
    return this.topLeft.plus(Vec2.of(0, this.h));
  }
  get width() {
    return this.w;
  }
  get height() {
    return this.h;
  }
  get center() {
    return Vec2.of(this.x + this.w / 2, this.y + this.h / 2);
  }
  // Returns edges in the order
  // [ rightEdge, topEdge, leftEdge, bottomEdge ]
  getEdges() {
    const corners = this.corners;
    return [
      new LineSegment2_default(corners[0], corners[1]),
      new LineSegment2_default(corners[1], corners[2]),
      new LineSegment2_default(corners[2], corners[3]),
      new LineSegment2_default(corners[3], corners[0])
    ];
  }
  intersectsLineSegment(lineSegment) {
    const result = [];
    for (const edge of this.getEdges()) {
      const intersection = edge.intersectsLineSegment(lineSegment);
      intersection.forEach((point) => result.push(point));
    }
    return result;
  }
  signedDistance(point) {
    const closestBoundaryPoint = this.getClosestPointOnBoundaryTo(point);
    const dist = point.minus(closestBoundaryPoint).magnitude();
    if (this.containsPoint(point)) {
      return -dist;
    }
    return dist;
  }
  getTightBoundingBox() {
    return this;
  }
  // [affineTransform] is a transformation matrix that both scales and **translates**.
  // the bounding box of this' four corners after transformed by the given affine transformation.
  transformedBoundingBox(affineTransform) {
    if (affineTransform === Mat33_default.identity) {
      return this;
    }
    return _Rect2.bboxOf(this.corners.map((corner) => affineTransform.transformVec2(corner)));
  }
  /** @return true iff this is equal to `other ± tolerance` */
  eq(other, tolerance = 0) {
    return this.topLeft.eq(other.topLeft, tolerance) && this.size.eq(other.size, tolerance);
  }
  toString() {
    return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))`;
  }
  static fromCorners(corner1, corner2) {
    return new _Rect2(Math.min(corner1.x, corner2.x), Math.min(corner1.y, corner2.y), Math.abs(corner1.x - corner2.x), Math.abs(corner1.y - corner2.y));
  }
  // Returns a box that contains all points in [points] with at least [margin]
  // between each point and the edge of the box.
  static bboxOf(points, margin = 0) {
    let minX = 0;
    let minY = 0;
    let maxX = 0;
    let maxY = 0;
    let isFirst = true;
    for (const point of points) {
      if (isFirst) {
        minX = point.x;
        minY = point.y;
        maxX = point.x;
        maxY = point.y;
        isFirst = false;
      }
      minX = Math.min(minX, point.x);
      minY = Math.min(minY, point.y);
      maxX = Math.max(maxX, point.x);
      maxY = Math.max(maxY, point.y);
    }
    return _Rect2.fromCorners(Vec2.of(minX - margin, minY - margin), Vec2.of(maxX + margin, maxY + margin));
  }
  // @returns a rectangle that contains all of the given rectangles, the bounding box
  //     of the given rectangles.
  static union(...rects) {
    if (rects.length === 0) {
      return _Rect2.empty;
    }
    const firstRect = rects[0];
    let minX = firstRect.x;
    let minY = firstRect.y;
    let maxX = firstRect.x + firstRect.w;
    let maxY = firstRect.y + firstRect.h;
    for (let i = 1; i < rects.length; i++) {
      const rect = rects[i];
      minX = Math.min(minX, rect.x);
      minY = Math.min(minY, rect.y);
      maxX = Math.max(maxX, rect.x + rect.w);
      maxY = Math.max(maxY, rect.y + rect.h);
    }
    return new _Rect2(minX, minY, maxX - minX, maxY - minY);
  }
  static of(template) {
    const width = template.width ?? template.w ?? 0;
    const height = template.height ?? template.h ?? 0;
    return new _Rect2(template.x, template.y, width, height);
  }
};
Rect2.empty = new Rect2(0, 0, 0, 0);
Rect2.unitSquare = new Rect2(0, 0, 1, 1);
var Rect2_default = Rect2;

// node_modules/@js-draw/math/dist/mjs/shapes/Parameterized2DShape.mjs
var Parameterized2DShape = class extends Abstract2DShape_default {
  intersectsLineSegment(line) {
    return this.argIntersectsLineSegment(line).map((t2) => this.at(t2));
  }
};
var Parameterized2DShape_default = Parameterized2DShape;

// node_modules/@js-draw/math/dist/mjs/shapes/LineSegment2.mjs
var LineSegment2 = class _LineSegment2 extends Parameterized2DShape_default {
  /** Creates a new `LineSegment2` from its endpoints. */
  constructor(point1, point2) {
    super();
    this.point1 = point1;
    this.point2 = point2;
    this.bbox = Rect2_default.bboxOf([point1, point2]);
    this.direction = point2.minus(point1);
    this.length = this.direction.magnitude();
    if (this.length > 0) {
      this.direction = this.direction.times(1 / this.length);
    }
  }
  /**
   * Returns the smallest line segment that contains all points in `points`, or `null`
   * if no such line segment exists.
   *
   * @example
   * ```ts,runnable,console
   * import {LineSegment2, Vec2} from '@js-draw/math';
   * console.log(LineSegment2.ofSmallestContainingPoints([Vec2.of(1, 0), Vec2.of(0, 1)]));
   * ```
   */
  static ofSmallestContainingPoints(points) {
    if (points.length <= 1)
      return null;
    const sorted = [...points].sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    const line = new _LineSegment2(sorted[0], sorted[sorted.length - 1]);
    for (const point of sorted) {
      if (!line.containsPoint(point)) {
        return null;
      }
    }
    return line;
  }
  // Accessors to make LineSegment2 compatible with bezier-js's
  // interface
  /** Alias for `point1`. */
  get p1() {
    return this.point1;
  }
  /** Alias for `point2`. */
  get p2() {
    return this.point2;
  }
  get center() {
    return this.point1.lerp(this.point2, 0.5);
  }
  /**
   * Gets a point a **distance** `t` along this line.
   *
   * @deprecated
   */
  get(t2) {
    return this.point1.plus(this.direction.times(t2));
  }
  /**
   * Returns a point a fraction, `t`, along this line segment.
   * Thus, `segment.at(0)` returns `segment.p1` and `segment.at(1)` returns
   * `segment.p2`.
   *
   * `t` should be in `[0, 1]`.
   */
  at(t2) {
    return this.get(t2 * this.length);
  }
  normalAt(_t) {
    return this.direction.orthog();
  }
  tangentAt(_t) {
    return this.direction;
  }
  splitAt(t2) {
    if (t2 <= 0 || t2 >= 1) {
      return [this];
    }
    return [new _LineSegment2(this.point1, this.at(t2)), new _LineSegment2(this.at(t2), this.point2)];
  }
  /**
   * Returns the intersection of this with another line segment.
   *
   * **WARNING**: The parameter value returned by this method does not range from 0 to 1 and
   *              is currently a length.
   *              This will change in a future release.
   * @deprecated
   */
  intersection(other) {
    let resultPoint, resultT;
    const small = 4e-13;
    if (Math.abs(this.direction.x) < small) {
      if (other.direction.x === 0 || this.direction.y === 0) {
        return null;
      }
      const xIntersect = this.point1.x;
      const yIntersect = (this.point1.x - other.point1.x) * other.direction.y / other.direction.x + other.point1.y;
      resultPoint = Vec2.of(xIntersect, yIntersect);
      resultT = (yIntersect - this.point1.y) / this.direction.y;
    } else {
      const numerator = (this.point1.y - other.point1.y) * this.direction.x * other.direction.x + this.direction.x * other.direction.y * other.point1.x - this.direction.y * other.direction.x * this.point1.x;
      const denominator = other.direction.y * this.direction.x - this.direction.y * other.direction.x;
      if (denominator === 0) {
        return null;
      }
      const xIntersect = numerator / denominator;
      const t1 = (xIntersect - this.point1.x) / this.direction.x;
      const yIntersect = this.point1.y + this.direction.y * t1;
      resultPoint = Vec2.of(xIntersect, yIntersect);
      resultT = (xIntersect - this.point1.x) / this.direction.x;
    }
    const resultToP1 = resultPoint.distanceTo(this.point1);
    const resultToP2 = resultPoint.distanceTo(this.point2);
    const resultToP3 = resultPoint.distanceTo(other.point1);
    const resultToP4 = resultPoint.distanceTo(other.point2);
    if (resultToP1 > this.length || resultToP2 > this.length || resultToP3 > other.length || resultToP4 > other.length) {
      return null;
    }
    return {
      point: resultPoint,
      t: resultT
    };
  }
  intersects(other) {
    return this.intersection(other) !== null;
  }
  argIntersectsLineSegment(lineSegment) {
    const intersection = this.intersection(lineSegment);
    if (intersection) {
      return [intersection.t / this.length];
    }
    return [];
  }
  /**
   * Returns the points at which this line segment intersects the
   * given line segment.
   *
   * Note that {@link intersects} returns *whether* this line segment intersects another
   * line segment. This method, by contrast, returns **the point** at which the intersection
   * occurs, if such a point exists.
   */
  intersectsLineSegment(lineSegment) {
    const intersection = this.intersection(lineSegment);
    if (intersection) {
      return [intersection.point];
    }
    return [];
  }
  // Returns the closest point on this to [target]
  closestPointTo(target) {
    return this.nearestPointTo(target).point;
  }
  nearestPointTo(target) {
    const projectedDistFromP1 = target.minus(this.p1).dot(this.direction);
    const projectedDistFromP2 = this.length - projectedDistFromP1;
    const projection = this.p1.plus(this.direction.times(projectedDistFromP1));
    if (projectedDistFromP1 > 0 && projectedDistFromP1 < this.length) {
      return { point: projection, parameterValue: projectedDistFromP1 / this.length };
    }
    if (Math.abs(projectedDistFromP2) < Math.abs(projectedDistFromP1)) {
      return { point: this.p2, parameterValue: 1 };
    } else {
      return { point: this.p1, parameterValue: 0 };
    }
  }
  /**
   * Returns the distance from this line segment to `target`.
   *
   * Because a line segment has no interior, this signed distance is equivalent to
   * the full distance between `target` and this line segment.
   */
  signedDistance(target) {
    return this.closestPointTo(target).minus(target).magnitude();
  }
  /** Returns a copy of this line segment transformed by the given `affineTransfm`. */
  transformedBy(affineTransfm) {
    return new _LineSegment2(affineTransfm.transformVec2(this.p1), affineTransfm.transformVec2(this.p2));
  }
  /** @inheritdoc */
  getTightBoundingBox() {
    return this.bbox;
  }
  toString() {
    return `LineSegment(${this.p1.toString()}, ${this.p2.toString()})`;
  }
  /**
   * Returns `true` iff this is equivalent to `other`.
   *
   * **Options**:
   * - `tolerance`: The maximum difference between endpoints. (Default: 0)
   * - `ignoreDirection`: Allow matching a version of `this` with opposite direction. (Default: `true`)
   */
  eq(other, options) {
    if (!(other instanceof _LineSegment2)) {
      return false;
    }
    const tolerance = options == null ? void 0 : options.tolerance;
    const ignoreDirection = (options == null ? void 0 : options.ignoreDirection) ?? true;
    return other.p1.eq(this.p1, tolerance) && other.p2.eq(this.p2, tolerance) || ignoreDirection && other.p1.eq(this.p2, tolerance) && other.p2.eq(this.p1, tolerance);
  }
};
var LineSegment2_default = LineSegment2;

// node_modules/bezier-js/src/utils.js
var { abs, cos, sin, acos, atan2, sqrt, pow } = Math;
function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
}
var pi = Math.PI;
var tau = 2 * pi;
var quart = pi / 2;
var epsilon = 1e-6;
var nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;
var nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;
var ZERO = { x: 0, y: 0, z: 0 };
var utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t2, derivativeFn) {
    const d = derivativeFn(t2);
    let l = d.x * d.x + d.y * d.y;
    if (typeof d.z !== "undefined") {
      l += d.z * d.z;
    }
    return sqrt(l);
  },
  compute: function(t2, points, _3d) {
    if (t2 === 0) {
      points[0].t = 0;
      return points[0];
    }
    const order = points.length - 1;
    if (t2 === 1) {
      points[order].t = 1;
      return points[order];
    }
    const mt = 1 - t2;
    let p = points;
    if (order === 0) {
      points[0].t = t2;
      return points[0];
    }
    if (order === 1) {
      const ret = {
        x: mt * p[0].x + t2 * p[1].x,
        y: mt * p[0].y + t2 * p[1].y,
        t: t2
      };
      if (_3d) {
        ret.z = mt * p[0].z + t2 * p[1].z;
      }
      return ret;
    }
    if (order < 4) {
      let mt2 = mt * mt, t22 = t2 * t2, a, b, c, d = 0;
      if (order === 2) {
        p = [p[0], p[1], p[2], ZERO];
        a = mt2;
        b = mt * t2 * 2;
        c = t22;
      } else if (order === 3) {
        a = mt2 * mt;
        b = mt2 * t2 * 3;
        c = mt * t22 * 3;
        d = t2 * t22;
      }
      const ret = {
        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,
        t: t2
      };
      if (_3d) {
        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
      }
      return ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i = 0; i < dCpts.length - 1; i++) {
        dCpts[i] = {
          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t2,
          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t2
        };
        if (typeof dCpts[i].z !== "undefined") {
          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t2;
        }
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t2;
    return dCpts[0];
  },
  computeWithRatios: function(t2, points, ratios, _3d) {
    const mt = 1 - t2, r = ratios, p = points;
    let f1 = r[0], f2 = r[1], f3 = r[2], f4 = r[3], d;
    f1 *= mt;
    f2 *= t2;
    if (p.length === 2) {
      d = f1 + f2;
      return {
        x: (f1 * p[0].x + f2 * p[1].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,
        t: t2
      };
    }
    f1 *= mt;
    f2 *= 2 * mt;
    f3 *= t2 * t2;
    if (p.length === 3) {
      d = f1 + f2 + f3;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,
        t: t2
      };
    }
    f1 *= mt;
    f2 *= 1.5 * mt;
    f3 *= 3 * mt;
    f4 *= t2 * t2 * t2;
    if (p.length === 4) {
      d = f1 + f2 + f3 + f4;
      return {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,
        t: t2
      };
    }
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
      const list = [];
      for (let j = 0, dpt; j < c; j++) {
        dpt = {
          x: c * (p[j + 1].x - p[j].x),
          y: c * (p[j + 1].y - p[j].y)
        };
        if (_3d) {
          dpt.z = c * (p[j + 1].z - p[j].z);
        }
        list.push(dpt);
      }
      dpoints.push(list);
      p = list;
    }
    return dpoints;
  },
  between: function(v, m, M) {
    return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);
  },
  approximately: function(a, b, precision) {
    return abs(a - b) <= (precision || epsilon);
  },
  length: function(derivativeFn) {
    const z = 0.5, len = utils.Tvalues.length;
    let sum = 0;
    for (let i = 0, t2; i < len; i++) {
      t2 = z * utils.Tvalues[i] + z;
      sum += utils.Cvalues[i] * utils.arcfn(t2, derivativeFn);
    }
    return z * sum;
  },
  map: function(v, ds, de, ts, te) {
    const d1 = de - ds, d2 = te - ts, v2 = v - ds, r = v2 / d1;
    return ts + d2 * r;
  },
  lerp: function(r, v1, v2) {
    const ret = {
      x: v1.x + r * (v2.x - v1.x),
      y: v1.y + r * (v2.y - v1.y)
    };
    if (v1.z !== void 0 && v2.z !== void 0) {
      ret.z = v1.z + r * (v2.z - v1.z);
    }
    return ret;
  },
  pointToString: function(p) {
    let s = p.x + "/" + p.y;
    if (typeof p.z !== "undefined") {
      s += "/" + p.z;
    }
    return s;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o, v1, v2) {
    const dx1 = v1.x - o.x, dy1 = v1.y - o.y, dx2 = v2.x - o.x, dy2 = v2.y - o.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },
  // round as string, to avoid rounding errors
  round: function(v, d) {
    const s = "" + v;
    const pos = s.indexOf(".");
    return parseFloat(s.substring(0, pos + 1 + d));
  },
  dist: function(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return sqrt(dx * dx + dy * dy);
  },
  closest: function(LUT, point) {
    let mdist = pow(2, 63), mpos, d;
    LUT.forEach(function(p, idx) {
      d = utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        mpos = idx;
      }
    });
    return { mdist, mpos };
  },
  abcratio: function(t2, n) {
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    } else if (t2 === 0 || t2 === 1) {
      return t2;
    }
    const bottom = pow(t2, n) + pow(1 - t2, n), top = bottom - 1;
    return abs(top / bottom);
  },
  projectionratio: function(t2, n) {
    if (n !== 2 && n !== 3) {
      return false;
    }
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    } else if (t2 === 0 || t2 === 1) {
      return t2;
    }
    const top = pow(1 - t2, n), bottom = pow(t2, n) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d == 0) {
      return false;
    }
    return { x: nx / d, y: ny / d };
  },
  lli4: function(p1, p2, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p2) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    sections.forEach(function(s) {
      const bbox = s.bbox();
      if (mx > bbox.x.min) mx = bbox.x.min;
      if (my > bbox.y.min) my = bbox.y.min;
      if (MX < bbox.x.max) MX = bbox.x.max;
      if (MY < bbox.y.max) MY = bbox.y.max;
    });
    return {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    a1.forEach(function(l1) {
      if (l1.virtual) return;
      a2.forEach(function(l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l2;
          iss.s1 = s1;
          iss.s2 = s2;
          intersections.push(iss);
        }
      });
    });
    return intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start, forward, back, end])
    };
    shape.intersections = function(s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    };
    return shape;
  },
  getminmax: function(curve, d, list) {
    if (!list) return { min: 0, max: 0 };
    let min2 = nMax, max2 = nMin, t2, c;
    if (list.indexOf(0) === -1) {
      list = [0].concat(list);
    }
    if (list.indexOf(1) === -1) {
      list.push(1);
    }
    for (let i = 0, len = list.length; i < len; i++) {
      t2 = list[i];
      c = curve.get(t2);
      if (c[d] < min2) {
        min2 = c[d];
      }
      if (c[d] > max2) {
        max2 = c[d];
      }
    }
    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
  },
  align: function(points, line) {
    const tx = line.p1.x, ty = line.p1.y, a = -atan2(line.p2.y - ty, line.p2.x - tx), d = function(v) {
      return {
        x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),
        y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)
      };
    };
    return points.map(d);
  },
  roots: function(points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order = points.length - 1;
    const aligned = utils.align(points, line);
    const reduce = function(t2) {
      return 0 <= t2 && t2 <= 1;
    };
    if (order === 2) {
      const a2 = aligned[0].y, b2 = aligned[1].y, c2 = aligned[2].y, d2 = a2 - 2 * b2 + c2;
      if (d2 !== 0) {
        const m1 = -sqrt(b2 * b2 - a2 * c2), m2 = -a2 + b2, v12 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
        return [v12, v2].filter(reduce);
      } else if (b2 !== c2 && d2 === 0) {
        return [(2 * b2 - c2) / (2 * b2 - 2 * c2)].filter(reduce);
      }
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d = -pa + 3 * pb - 3 * pc + pd, a = 3 * pa - 6 * pb + 3 * pc, b = -3 * pa + 3 * pb, c = pa;
    if (utils.approximately(d, 0)) {
      if (utils.approximately(a, 0)) {
        if (utils.approximately(b, 0)) {
          return [];
        }
        return [-c / b].filter(reduce);
      }
      const q3 = sqrt(b * b - 4 * a * c), a2 = 2 * a;
      return [(q3 - b) / a2, (-b - q3) / a2].filter(reduce);
    }
    a /= d;
    b /= d;
    c /= d;
    const p = (3 * b - a * a) / 3, p3 = p / 3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p / 3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t2 = -q / (2 * r), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
      x1 = t1 * cos(phi / 3) - a / 3;
      x2 = t1 * cos((phi + tau) / 3) - a / 3;
      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;
      return [x1, x2, x3].filter(reduce);
    } else if (discriminant === 0) {
      u1 = q2 < 0 ? crt(-q2) : -crt(q2);
      x1 = 2 * u1 - a / 3;
      x2 = -u1 - a / 3;
      return [x1, x2].filter(reduce);
    } else {
      const sd = sqrt(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      return [u1 - v1 - a / 3].filter(reduce);
    }
  },
  droots: function(p) {
    if (p.length === 3) {
      const a = p[0], b = p[1], c = p[2], d = a - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt(b * b - a * c), m2 = -a + b, v1 = -(m1 + m2) / d, v2 = -(-m1 + m2) / d;
        return [v1, v2];
      } else if (b !== c && d === 0) {
        return [(2 * b - c) / (2 * (b - c))];
      }
      return [];
    }
    if (p.length === 2) {
      const a = p[0], b = p[1];
      if (a !== b) {
        return [a / (a - b)];
      }
      return [];
    }
    return [];
  },
  curvature: function(t2, d1, d2, _3d, kOnly) {
    let num, dnm, adk, dk, k = 0, r = 0;
    const d = utils.compute(t2, d1);
    const dd = utils.compute(t2, d2);
    const qdsum = d.x * d.x + d.y * d.y;
    if (_3d) {
      num = sqrt(
        pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2)
      );
      dnm = pow(qdsum + d.z * d.z, 3 / 2);
    } else {
      num = d.x * dd.y - d.y * dd.x;
      dnm = pow(qdsum, 3 / 2);
    }
    if (num === 0 || dnm === 0) {
      return { k: 0, r: 0 };
    }
    k = num / dnm;
    r = dnm / num;
    if (!kOnly) {
      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, true).k;
      const nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, true).k;
      dk = (nk - k + (k - pk)) / 2;
      adk = (abs(nk - k) + abs(k - pk)) / 2;
    }
    return { k, r, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a = p[2].x * p[1].y, b = p[3].x * p[1].y, c = p[1].x * p[2].y, d = p[3].x * p[2].y, v1 = 18 * (-3 * a + 2 * b + 3 * c - d), v2 = 18 * (3 * a - b - 3 * c), v3 = 18 * (c - a);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t2 = -v3 / v2;
        if (0 <= t2 && t2 <= 1) return [t2];
      }
      return [];
    }
    const d2 = 2 * v1;
    if (utils.approximately(d2, 0)) return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function(r) {
      return 0 <= r && r <= 1;
    });
  },
  bboxoverlap: function(b1, b2) {
    const dims = ["x", "y"], len = dims.length;
    for (let i = 0, dim, l, t2, d; i < len; i++) {
      dim = dims[i];
      l = b1[dim].mid;
      t2 = b2[dim].mid;
      d = (b1[dim].size + b2[dim].size) / 2;
      if (abs(l - t2) >= d) return false;
    }
    return true;
  },
  expandbox: function(bbox, _bbox) {
    if (_bbox.x.min < bbox.x.min) {
      bbox.x.min = _bbox.x.min;
    }
    if (_bbox.y.min < bbox.y.min) {
      bbox.y.min = _bbox.y.min;
    }
    if (_bbox.z && _bbox.z.min < bbox.z.min) {
      bbox.z.min = _bbox.z.min;
    }
    if (_bbox.x.max > bbox.x.max) {
      bbox.x.max = _bbox.x.max;
    }
    if (_bbox.y.max > bbox.y.max) {
      bbox.y.max = _bbox.y.max;
    }
    if (_bbox.z && _bbox.z.max > bbox.z.max) {
      bbox.z.max = _bbox.z.max;
    }
    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
    if (bbox.z) {
      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
    }
    bbox.x.size = bbox.x.max - bbox.x.min;
    bbox.y.size = bbox.y.max - bbox.y.min;
    if (bbox.z) {
      bbox.z.size = bbox.z.max - bbox.z.min;
    }
  },
  pairiteration: function(c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c2.bbox(), r = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
      return [
        (r * (c1._t1 + c1._t2) / 2 | 0) / r + "/" + (r * (c2._t1 + c2._t2) / 2 | 0) / r
      ];
    }
    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    if (pairs.length === 0) return results;
    pairs.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    });
    results = results.filter(function(v, i) {
      return results.indexOf(v) === i;
    });
    return results;
  },
  getccenter: function(p1, p2, p3) {
    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos(quart) - dy1 * sin(quart), dy1p = dx1 * sin(quart) + dy1 * cos(quart), dx2p = dx2 * cos(quart) - dy2 * sin(quart), dy2p = dx2 * sin(quart) + dy2 * cos(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r = utils.dist(arc, p1);
    let s = atan2(p1.y - arc.y, p1.x - arc.x), m = atan2(p2.y - arc.y, p2.x - arc.x), e = atan2(p3.y - arc.y, p3.x - arc.x), _;
    if (s < e) {
      if (s > m || m > e) {
        s += tau;
      }
      if (s > e) {
        _ = e;
        e = s;
        s = _;
      }
    } else {
      if (e < m && m < s) {
        _ = e;
        e = s;
        s = _;
      } else {
        e += tau;
      }
    }
    arc.s = s;
    arc.e = e;
    arc.r = r;
    return arc;
  },
  numberSort: function(a, b) {
    return a - b;
  }
};

// node_modules/bezier-js/src/poly-bezier.js
var PolyBezier = class _PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve) {
      return utils.pointsToString(curve.points);
    }).join(", ") + "]";
  }
  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }
  length() {
    return this.curves.map(function(v) {
      return v.length();
    }).reduce(function(a, b) {
      return a + b;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c = this.curves;
    var bbox = c[0].bbox();
    for (var i = 1; i < c.length; i++) {
      utils.expandbox(bbox, c[i].bbox());
    }
    return bbox;
  }
  offset(d) {
    const offset = [];
    this.curves.forEach(function(v) {
      offset.push(...v.offset(d));
    });
    return new _PolyBezier(offset);
  }
};

// node_modules/bezier-js/src/bezier.js
var { abs: abs2, min, max, cos: cos2, sin: sin2, acos: acos2, sqrt: sqrt2 } = Math;
var pi2 = Math.PI;
var Bezier = class _Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;
    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point2) {
        ["x", "y", "z"].forEach(function(d) {
          if (typeof point2[d] !== "undefined") {
            newargs.push(point2[d]);
          }
        });
      });
      args = newargs;
    }
    let higher = false;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
        higher = true;
      }
    } else {
      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
      }
    }
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
    const points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point = {
        x: args[idx],
        y: args[idx + 1]
      };
      if (_3d) {
        point.z = args[idx + 2];
      }
      points.push(point);
    }
    const order = this.order = points.length - 1;
    const dims = this.dims = ["x", "y"];
    if (_3d) dims.push("z");
    this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order] });
    const baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t2, p) => t2 + abs2(p.y), 0) < baselength / 50;
    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }
  static quadraticFromPoints(p1, p2, p3, t2) {
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    }
    if (t2 === 0) {
      return new _Bezier(p2, p2, p3);
    }
    if (t2 === 1) {
      return new _Bezier(p1, p2, p2);
    }
    const abc = _Bezier.getABC(2, p1, p2, p3, t2);
    return new _Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S, B, E, t2, d1) {
    if (typeof t2 === "undefined") {
      t2 = 0.5;
    }
    const abc = _Bezier.getABC(3, S, B, E, t2);
    if (typeof d1 === "undefined") {
      d1 = utils.dist(B, abc.C);
    }
    const d2 = d1 * (1 - t2) / t2;
    const selen = utils.dist(S, E), lx = (E.x - S.x) / selen, ly = (E.y - S.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly;
    const e1 = { x: B.x - bx1, y: B.y - by1 }, e2 = { x: B.x + bx2, y: B.y + by2 }, A = abc.A, v1 = { x: A.x + (e1.x - A.x) / (1 - t2), y: A.y + (e1.y - A.y) / (1 - t2) }, v2 = { x: A.x + (e2.x - A.x) / t2, y: A.y + (e2.y - A.y) / t2 }, nc1 = { x: S.x + (v1.x - S.x) / t2, y: S.y + (v1.y - S.y) / t2 }, nc2 = {
      x: E.x + (v2.x - E.x) / (1 - t2),
      y: E.y + (v2.y - E.y) / (1 - t2)
    };
    return new _Bezier(S, nc1, nc2, E);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return _Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return false;
    const p = this.points, x = p[0].x, y = p[0].y, s = ["M", x, y, this.order === 2 ? "Q" : "C"];
    for (let i = 1, last = p.length; i < last; i++) {
      s.push(p[i].x);
      s.push(p[i].y);
    }
    return s.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }
    this.ratios = ratios;
    this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }
  coordDigest() {
    return this.points.map(function(c, pos) {
      return "" + pos + c.x + c.y + (c.z ? c.z : 0);
    }).join("");
  }
  update() {
    this._lut = [];
    this.dpoints = utils.derive(this.points, this._3d);
    this.computedirection();
  }
  computedirection() {
    const points = this.points;
    const angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order = 2, S, B, E, t2 = 0.5) {
    const u = utils.projectionratio(t2, order), um = 1 - u, C = {
      x: u * S.x + um * E.x,
      y: u * S.y + um * E.y
    }, s = utils.abcratio(t2, order), A = {
      x: B.x + (B.x - C.x) / s,
      y: B.y + (B.y - C.y) / s
    };
    return { A, B, C, S, E };
  }
  getABC(t2, B) {
    B = B || this.get(t2);
    let S = this.points[0];
    let E = this.points[this.order];
    return _Bezier.getABC(this.order, S, B, E, t2);
  }
  getLUT(steps) {
    this.verify();
    steps = steps || 100;
    if (this._lut.length === steps + 1) {
      return this._lut;
    }
    this._lut = [];
    steps++;
    this._lut = [];
    for (let i = 0, p, t2; i < steps; i++) {
      t2 = i / (steps - 1);
      p = this.compute(t2);
      p.t = t2;
      this._lut.push(p);
    }
    return this._lut;
  }
  on(point, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i = 0, c, t2 = 0; i < lut.length; i++) {
      c = lut[i];
      if (utils.dist(c, point) < error) {
        hits.push(c);
        t2 += i / lut.length;
      }
    }
    if (!hits.length) return false;
    return t /= hits.length;
  }
  project(point) {
    const LUT = this.getLUT(), l = LUT.length - 1, closest = utils.closest(LUT, point), mpos = closest.mpos, t1 = (mpos - 1) / l, t2 = (mpos + 1) / l, step = 0.1 / l;
    let mdist = closest.mdist, t3 = t1, ft = t3, p;
    mdist += 1;
    for (let d; t3 < t2 + step; t3 += step) {
      p = this.compute(t3);
      d = utils.dist(point, p);
      if (d < mdist) {
        mdist = d;
        ft = t3;
      }
    }
    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
    p = this.compute(ft);
    p.t = ft;
    p.d = mdist;
    return p;
  }
  get(t2) {
    return this.compute(t2);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t2) {
    if (this.ratios) {
      return utils.computeWithRatios(t2, this.points, this.ratios, this._3d);
    }
    return utils.compute(t2, this.points, this._3d, this.ratios);
  }
  raise() {
    const p = this.points, np = [p[0]], k = p.length;
    for (let i = 1, pi3, pim; i < k; i++) {
      pi3 = p[i];
      pim = p[i - 1];
      np[i] = {
        x: (k - i) / k * pi3.x + i / k * pim.x,
        y: (k - i) / k * pi3.y + i / k * pim.y
      };
    }
    np[k] = p[k - 1];
    return new _Bezier(np);
  }
  derivative(t2) {
    return utils.compute(t2, this.dpoints[0], this._3d);
  }
  dderivative(t2) {
    return utils.compute(t2, this.dpoints[1], this._3d);
  }
  align() {
    let p = this.points;
    return new _Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));
  }
  curvature(t2) {
    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t2) {
    return this._3d ? this.__normal3(t2) : this.__normal2(t2);
  }
  __normal2(t2) {
    const d = this.derivative(t2);
    const q = sqrt2(d.x * d.x + d.y * d.y);
    return { t: t2, x: -d.y / q, y: d.x / q };
  }
  __normal3(t2) {
    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt2(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt2(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r2.x /= q2;
    r2.y /= q2;
    r2.z /= q2;
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    };
    const m = sqrt2(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m;
    c.y /= m;
    c.z /= m;
    const R = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z
    ];
    const n = {
      t: t2,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
    };
    return n;
  }
  hull(t2) {
    let p = this.points, _p = [], q = [], idx = 0;
    q[idx++] = p[0];
    q[idx++] = p[1];
    q[idx++] = p[2];
    if (this.order === 3) {
      q[idx++] = p[3];
    }
    while (p.length > 1) {
      _p = [];
      for (let i = 0, pt, l = p.length - 1; i < l; i++) {
        pt = utils.lerp(t2, p[i], p[i + 1]);
        q[idx++] = pt;
        _p.push(pt);
      }
      p = _p;
    }
    return q;
  }
  split(t1, t2) {
    if (t1 === 0 && !!t2) {
      return this.split(t2).left;
    }
    if (t2 === 1) {
      return this.split(t1).right;
    }
    const q = this.hull(t1);
    const result = {
      left: this.order === 2 ? new _Bezier([q[0], q[3], q[5]]) : new _Bezier([q[0], q[4], q[7], q[9]]),
      right: this.order === 2 ? new _Bezier([q[5], q[4], q[2]]) : new _Bezier([q[9], q[8], q[6], q[3]]),
      span: q
    };
    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
    if (!t2) {
      return result;
    }
    t2 = utils.map(t2, t1, 1, 0, 1);
    return result.right.split(t2).left;
  }
  extrema() {
    const result = {};
    let roots = [];
    this.dims.forEach(
      (function(dim) {
        let mfn = function(v) {
          return v[dim];
        };
        let p = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p);
        if (this.order === 3) {
          p = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(utils.droots(p));
        }
        result[dim] = result[dim].filter(function(t2) {
          return t2 >= 0 && t2 <= 1;
        });
        roots = roots.concat(result[dim].sort(utils.numberSort));
      }).bind(this)
    );
    result.values = roots.sort(utils.numberSort).filter(function(v, idx) {
      return roots.indexOf(v) === idx;
    });
    return result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    this.dims.forEach(
      (function(d) {
        result[d] = utils.getminmax(this, d, extrema[d]);
      }).bind(this)
    );
    return result;
  }
  overlaps(curve) {
    const lbbox = this.bbox(), tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t2, d) {
    if (typeof d !== "undefined") {
      const c = this.get(t2), n = this.normal(t2);
      const ret = {
        c,
        n,
        x: c.x + n.x * d,
        y: c.y + n.y * d
      };
      if (this._3d) {
        ret.z = c.z + n.z * d;
      }
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p) {
        const ret = {
          x: p.x + t2 * nv.x,
          y: p.y + t2 * nv.y
        };
        if (p.z && nv.z) {
          ret.z = p.z + t2 * nv.z;
        }
        return ret;
      });
      return [new _Bezier(coords)];
    }
    return this.reduce().map(function(s) {
      if (s._linear) {
        return s.offset(t2)[0];
      }
      return s.scale(t2);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;
    }
    const n1 = this.normal(0);
    const n2 = this.normal(1);
    let s = n1.x * n2.x + n1.y * n2.y;
    if (this._3d) {
      s += n1.z * n2.z;
    }
    return abs2(acos2(s)) < pi2 / 3;
  }
  reduce() {
    let i, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [];
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }
    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }
    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
      t2 = extrema[i];
      segment = this.split(t1, t2);
      segment._t1 = t1;
      segment._t2 = t2;
      pass1.push(segment);
      t1 = t2;
    }
    pass1.forEach(function(p1) {
      t1 = 0;
      t2 = 0;
      while (t2 <= 1) {
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
          segment = p1.split(t1, t2);
          if (!segment.simple()) {
            t2 -= step;
            if (abs2(t1 - t2) < step) {
              return [];
            }
            segment = p1.split(t1, t2);
            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t1 = t2;
            break;
          }
        }
      }
      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }
  translate(v, d1, d2) {
    d2 = typeof d2 === "number" ? d2 : d1;
    const o = this.order;
    let d = this.points.map((_, i) => (1 - i / o) * d1 + i / o * d2);
    return new _Bezier(
      this.points.map((p, i) => ({
        x: p.x + v.x * d[i],
        y: p.y + v.y * d[i]
      }))
    );
  }
  scale(d) {
    const order = this.order;
    let distanceFn = false;
    if (typeof d === "function") {
      distanceFn = d;
    }
    if (distanceFn && order === 2) {
      return this.raise().scale(distanceFn);
    }
    const clockwise = this.clockwise;
    const points = this.points;
    if (this._linear) {
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d,
        distanceFn ? distanceFn(1) : d
      );
    }
    const r1 = distanceFn ? distanceFn(0) : d;
    const r2 = distanceFn ? distanceFn(1) : d;
    const v = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
    if (!o) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    }
    [0, 1].forEach(function(t2) {
      const p = np[t2 * order] = utils.copy(points[t2 * order]);
      p.x += (t2 ? r2 : r1) * v[t2].n.x;
      p.y += (t2 ? r2 : r1) * v[t2].n.y;
    });
    if (!distanceFn) {
      [0, 1].forEach((t2) => {
        if (order === 2 && !!t2) return;
        const p = np[t2 * order];
        const d2 = this.derivative(t2);
        const p2 = { x: p.x + d2.x, y: p.y + d2.y };
        np[t2 + 1] = utils.lli4(p, p2, o, points[t2 + 1]);
      });
      return new _Bezier(np);
    }
    [0, 1].forEach(function(t2) {
      if (order === 2 && !!t2) return;
      var p = points[t2 + 1];
      var ov = {
        x: p.x - o.x,
        y: p.y - o.y
      };
      var rc = distanceFn ? distanceFn((t2 + 1) / order) : d;
      if (distanceFn && !clockwise) rc = -rc;
      var m = sqrt2(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m;
      ov.y /= m;
      np[t2 + 1] = {
        x: p.x + rc * ov.x,
        y: p.y + rc * ov.y
      };
    });
    return new _Bezier(np);
  }
  outline(d1, d2, d3, d4) {
    d2 = d2 === void 0 ? d1 : d2;
    if (this._linear) {
      const n = this.normal(0);
      const start = this.points[0];
      const end = this.points[this.points.length - 1];
      let s, mid, e;
      if (d3 === void 0) {
        d3 = d1;
        d4 = d2;
      }
      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };
      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const fline = [s, mid, e];
      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };
      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };
      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
      const bline = [e, mid, s];
      const ls2 = utils.makeline(bline[2], fline[0]);
      const le2 = utils.makeline(fline[2], bline[0]);
      const segments2 = [ls2, new _Bezier(fline), le2, new _Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p, alen = 0, tlen = this.length();
    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
    function linearDistanceFunction(s, e, tlen2, alen2, slen) {
      return function(v) {
        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d = e - s;
        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(
          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
        );
        bcurves.push(
          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
        );
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d2));
      }
      alen += slen;
    });
    bcurves = bcurves.map(function(s) {
      p = s.points;
      if (p[3]) {
        s.points = [p[3], p[2], p[1], p[0]];
      } else {
        s.points = [p[2], p[1], p[0]];
      }
      return s;
    }).reverse();
    const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves;
    const shapes = [];
    for (let i = 1, len = outline.length; i < len / 2; i++) {
      const shape = utils.makeshape(
        outline[i],
        outline[len - i],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i > 1;
      shape.endcap.virtual = i < len / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }
    if (curve instanceof _Bezier) {
      curve = curve.reduce();
    }
    return this.curveintersects(
      this.reduce(),
      curve,
      curveIntersectionThreshold
    );
  }
  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t2) => {
      var p = this.get(t2);
      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i = 0, result, left, right; i < len; i++) {
      left = reduced.slice(i, i + 1);
      right = reduced.slice(i + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }
    return results;
  }
  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    c1.forEach(function(l) {
      c2.forEach(function(r) {
        if (l.overlaps(r)) {
          pairs.push({ left: l, right: r });
        }
      });
    });
    let intersections = [];
    pairs.forEach(function(pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      if (result.length > 0) {
        intersections = intersections.concat(result);
      }
    });
    return intersections;
  }
  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s, e) {
    const q = (e - s) / 4, c1 = this.get(s + q), c2 = this.get(e - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
    return abs2(d1 - ref) + abs2(d2 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0;
      t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc;
      let curr_good = false, prev_good = false, done;
      let t_m = t_e, prev_e = 1, step = 0;
      do {
        prev_good = curr_good;
        prev_arc = arc;
        t_m = (t_s + t_e) / 2;
        step++;
        np2 = this.get(t_m);
        np3 = this.get(t_e);
        arc = utils.getccenter(np1, np2, np3);
        arc.interval = {
          start: t_s,
          end: t_e
        };
        let error = this._error(arc, np1, t_s, t_e);
        curr_good = error <= errorThreshold;
        done = prev_good && !curr_good;
        if (!done) prev_e = t_e;
        if (curr_good) {
          if (t_e >= 1) {
            arc.interval.end = prev_e = 1;
            prev_arc = arc;
            if (t_e > 1) {
              let d = {
                x: arc.x + arc.r * cos2(arc.e),
                y: arc.y + arc.r * sin2(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else {
          t_e = t_m;
        }
      } while (!done && safety++ < 100);
      if (safety >= 100) {
        break;
      }
      prev_arc = prev_arc ? prev_arc : arc;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
};

// node_modules/@js-draw/math/dist/mjs/shapes/BezierJSWrapper.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BezierJSWrapper_bezierJs;
var BezierJSWrapper = class extends Parameterized2DShape_default {
  constructor(bezierJsBezier) {
    super();
    _BezierJSWrapper_bezierJs.set(this, null);
    if (bezierJsBezier) {
      __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, bezierJsBezier, "f");
    }
  }
  getBezier() {
    if (!__classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, "f")) {
      __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, new Bezier(this.getPoints().map((p) => p.xy)), "f");
    }
    return __classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, "f");
  }
  signedDistance(point) {
    return this.nearestPointTo(point).point.distanceTo(point);
  }
  /**
   * @returns the (more) exact distance from `point` to this.
   *
   * @see {@link approximateDistance}
   */
  distance(point) {
    return this.signedDistance(point);
  }
  /**
   * @returns the curve evaluated at `t`.
   */
  at(t2) {
    return Vec2.ofXY(this.getBezier().get(t2));
  }
  /** @returns the curve's directional derivative at `t`. */
  derivativeAt(t2) {
    return Vec2.ofXY(this.getBezier().derivative(t2));
  }
  secondDerivativeAt(t2) {
    return Vec2.ofXY(this.getBezier().dderivative(t2));
  }
  /** @returns the [normal vector](https://en.wikipedia.org/wiki/Normal_(geometry)) to this curve at `t`. */
  normal(t2) {
    return Vec2.ofXY(this.getBezier().normal(t2));
  }
  normalAt(t2) {
    return this.normal(t2);
  }
  tangentAt(t2) {
    return this.derivativeAt(t2).normalized();
  }
  getTightBoundingBox() {
    const bbox = this.getBezier().bbox();
    const width = bbox.x.max - bbox.x.min;
    const height = bbox.y.max - bbox.y.min;
    return new Rect2_default(bbox.x.min, bbox.y.min, width, height);
  }
  argIntersectsLineSegment(line) {
    const asLine = LineSegment2_default.ofSmallestContainingPoints(this.getPoints());
    if (asLine) {
      const intersection = asLine.intersectsLineSegment(line);
      return intersection.map((p) => this.nearestPointTo(p).parameterValue);
    }
    const bezier = this.getBezier();
    return bezier.intersects(line).map((t2) => {
      if (typeof t2 === "string") {
        t2 = parseFloat(t2);
      }
      const point = Vec2.ofXY(this.at(t2));
      if (point.distanceTo(line.p1) > line.length || point.distanceTo(line.p2) > line.length) {
        return null;
      }
      return t2;
    }).filter((entry) => entry !== null);
  }
  splitAt(t2) {
    if (t2 <= 0 || t2 >= 1) {
      return [this];
    }
    const bezier = this.getBezier();
    const split = bezier.split(t2);
    return [
      new BezierJSWrapperImpl(split.left.points.map((point) => Vec2.ofXY(point)), split.left),
      new BezierJSWrapperImpl(split.right.points.map((point) => Vec2.ofXY(point)), split.right)
    ];
  }
  nearestPointTo(point) {
    const sqrDistAt = (t3) => point.squareDistanceTo(this.at(t3));
    const yIntercept = sqrDistAt(0);
    let t2 = 0;
    let minSqrDist = yIntercept;
    const pointsToTest = 4;
    for (let i = 0; i < pointsToTest; i++) {
      const testT = i / (pointsToTest - 1);
      const testMinSqrDist = sqrDistAt(testT);
      if (testMinSqrDist < minSqrDist) {
        t2 = testT;
        minSqrDist = testMinSqrDist;
      }
    }
    const secondDerivativeAt = (t3) => {
      const b = this.at(t3);
      const bPrime = this.derivativeAt(t3);
      const bPrimePrime = this.secondDerivativeAt(t3);
      return 2 * bPrime.x * bPrime.x + 2 * b.x * bPrimePrime.x - 2 * point.x * bPrimePrime.x + 2 * bPrime.y * bPrime.y + 2 * b.y * bPrimePrime.y - 2 * point.y * bPrimePrime.y;
    };
    const derivativeAt = (t3) => {
      const b = this.at(t3);
      const bPrime = this.derivativeAt(t3);
      return 2 * b.x * bPrime.x - 2 * point.x * bPrime.x + 2 * b.y * bPrime.y - 2 * point.y * bPrime.y;
    };
    const iterate = () => {
      const slope = secondDerivativeAt(t2);
      if (slope === 0)
        return;
      const newT = (0 - derivativeAt(t2)) / slope + t2;
      t2 = newT;
      if (t2 > 1) {
        t2 = 1;
      } else if (t2 < 0) {
        t2 = 0;
      }
    };
    for (let i = 0; i < 12; i++) {
      iterate();
    }
    return { parameterValue: t2, point: this.at(t2) };
  }
  intersectsBezier(other) {
    const intersections = this.getBezier().intersects(other.getBezier());
    if (!intersections || intersections.length === 0) {
      return [];
    }
    const result = [];
    for (const intersection of intersections) {
      const match = /^([-0-9.eE]+)\/([-0-9.eE]+)$/.exec(intersection);
      if (!match) {
        throw new Error(`Incorrect format returned by .intersects: ${intersections} should be array of "number/number"!`);
      }
      const t2 = parseFloat(match[1]);
      result.push({
        parameterValue: t2,
        point: this.at(t2)
      });
    }
    return result;
  }
  toString() {
    return `Bézier(${this.getPoints().map((point) => point.toString()).join(", ")})`;
  }
};
_BezierJSWrapper_bezierJs = /* @__PURE__ */ new WeakMap();
var BezierJSWrapperImpl = class extends BezierJSWrapper {
  constructor(controlPoints, curve) {
    super(curve);
    this.controlPoints = controlPoints;
  }
  getPoints() {
    return this.controlPoints;
  }
};
var BezierJSWrapper_default = BezierJSWrapper;

// node_modules/@js-draw/math/dist/mjs/shapes/CubicBezier.mjs
var CubicBezier = class extends BezierJSWrapper_default {
  constructor(p0, p1, p2, p3) {
    super();
    this.p0 = p0;
    this.p1 = p1;
    this.p2 = p2;
    this.p3 = p3;
  }
  getPoints() {
    return [this.p0, this.p1, this.p2, this.p3];
  }
  /** Returns an overestimate of this shape's bounding box. */
  getLooseBoundingBox() {
    return Rect2_default.bboxOf([this.p0, this.p1, this.p2, this.p3]);
  }
};
var CubicBezier_default = CubicBezier;

// node_modules/@js-draw/math/dist/mjs/polynomial/solveQuadratic.mjs
var solveQuadratic = (a, b, c) => {
  if (a === 0) {
    let solution;
    if (b === 0) {
      solution = c === 0 ? 0 : NaN;
    } else {
      solution = -c / b;
    }
    return [solution, solution];
  }
  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) {
    return [NaN, NaN];
  }
  const rootDiscriminant = Math.sqrt(discriminant);
  const solution1 = (-b + rootDiscriminant) / (2 * a);
  const solution2 = (-b - rootDiscriminant) / (2 * a);
  if (solution1 > solution2) {
    return [solution1, solution2];
  } else {
    return [solution2, solution1];
  }
};
var solveQuadratic_default = solveQuadratic;

// node_modules/@js-draw/math/dist/mjs/shapes/QuadraticBezier.mjs
var QuadraticBezier = class _QuadraticBezier extends BezierJSWrapper_default {
  constructor(p0, p1, p2) {
    super();
    this.p0 = p0;
    this.p1 = p1;
    this.p2 = p2;
  }
  /**
   * Returns a component of a quadratic Bézier curve at t, where p0,p1,p2 are either all x or
   * all y components of the target curve.
   */
  static componentAt(t2, p0, p1, p2) {
    return p0 + t2 * (-2 * p0 + 2 * p1) + t2 * t2 * (p0 - 2 * p1 + p2);
  }
  static derivativeComponentAt(t2, p0, p1, p2) {
    return -2 * p0 + 2 * p1 + 2 * t2 * (p0 - 2 * p1 + p2);
  }
  static secondDerivativeComponentAt(t2, p0, p1, p2) {
    return 2 * (p0 - 2 * p1 + p2);
  }
  /**
   * @returns the curve evaluated at `t`.
   *
   * `t` should be a number in `[0, 1]`.
   */
  at(t2) {
    if (t2 === 0)
      return this.p0;
    if (t2 === 1)
      return this.p2;
    const p0 = this.p0;
    const p1 = this.p1;
    const p2 = this.p2;
    return Vec2.of(_QuadraticBezier.componentAt(t2, p0.x, p1.x, p2.x), _QuadraticBezier.componentAt(t2, p0.y, p1.y, p2.y));
  }
  derivativeAt(t2) {
    const p0 = this.p0;
    const p1 = this.p1;
    const p2 = this.p2;
    return Vec2.of(_QuadraticBezier.derivativeComponentAt(t2, p0.x, p1.x, p2.x), _QuadraticBezier.derivativeComponentAt(t2, p0.y, p1.y, p2.y));
  }
  secondDerivativeAt(t2) {
    const p0 = this.p0;
    const p1 = this.p1;
    const p2 = this.p2;
    return Vec2.of(_QuadraticBezier.secondDerivativeComponentAt(t2, p0.x, p1.x, p2.x), _QuadraticBezier.secondDerivativeComponentAt(t2, p0.y, p1.y, p2.y));
  }
  normal(t2) {
    const tangent = this.derivativeAt(t2);
    return tangent.orthog().normalized();
  }
  /** @returns an overestimate of this shape's bounding box. */
  getLooseBoundingBox() {
    return Rect2_default.bboxOf([this.p0, this.p1, this.p2]);
  }
  /**
   * @returns the *approximate* distance from `point` to this curve.
   */
  approximateDistance(point) {
    const A = this.p0.x - point.x;
    const B = -2 * this.p0.x + 2 * this.p1.x;
    const C = this.p0.x - 2 * this.p1.x + this.p2.x;
    const D = this.p0.y - point.y;
    const E = -2 * this.p0.y + 2 * this.p1.y;
    const F = this.p0.y - 2 * this.p1.y + this.p2.y;
    const a = 2 * A * B + 2 * D * E - point.x * B - point.y * E;
    const b = 2 * B * B + 2 * E * E + 2 * C * A + 2 * F * D - point.x * C - point.y * F;
    const c = 2 * E * F + 2 * B * C + 2 * C * B + 2 * F * E;
    const fDerivAtZero = a;
    const f2ndDerivAtZero = b;
    const f3rdDerivAtZero = 2 * c;
    let [min1, min2] = solveQuadratic_default(f3rdDerivAtZero / 2, f2ndDerivAtZero, fDerivAtZero);
    if (isNaN(min1)) {
      min1 = 0.25;
    }
    if (isNaN(min2)) {
      min2 = 0.75;
    }
    const at1 = this.at(min1);
    const at2 = this.at(min2);
    const sqrDist1 = at1.squareDistanceTo(point);
    const sqrDist2 = at2.squareDistanceTo(point);
    const sqrDist3 = this.at(0).squareDistanceTo(point);
    const sqrDist4 = this.at(1).squareDistanceTo(point);
    return Math.sqrt(Math.min(sqrDist1, sqrDist2, sqrDist3, sqrDist4));
  }
  getPoints() {
    return [this.p0, this.p1, this.p2];
  }
};
var QuadraticBezier_default = QuadraticBezier;

// node_modules/@js-draw/math/dist/mjs/shapes/PointShape2D.mjs
var PointShape2D = class extends Parameterized2DShape_default {
  constructor(p) {
    super();
    this.p = p;
  }
  signedDistance(point) {
    return this.p.distanceTo(point);
  }
  argIntersectsLineSegment(lineSegment, epsilon2) {
    if (lineSegment.containsPoint(this.p, epsilon2)) {
      return [0];
    }
    return [];
  }
  getTightBoundingBox() {
    return new Rect2_default(this.p.x, this.p.y, 0, 0);
  }
  at(_t) {
    return this.p;
  }
  /**
   * Returns an arbitrary unit-length vector.
   */
  normalAt(_t) {
    return Vec2.unitY;
  }
  tangentAt(_t) {
    return Vec2.unitX;
  }
  splitAt(_t) {
    return [this];
  }
  nearestPointTo(_point) {
    return {
      point: this.p,
      parameterValue: 0
    };
  }
};
var PointShape2D_default = PointShape2D;

// node_modules/@js-draw/math/dist/mjs/rounding/cleanUpNumber.mjs
var cleanUpNumber = (text) => {
  if (text.indexOf("e") > 0) {
    if (text.match(/[eE][-]\d{2,}$/)) {
      return "0";
    }
  }
  const lastChar = text.charAt(text.length - 1);
  if (lastChar === "0" || lastChar === ".") {
    text = text.replace(/([.]\d*[^0])0+$/, "$1");
    text = text.replace(/[.]0+$/, ".");
    text = text.replace(/[.]$/, "");
  }
  const firstChar = text.charAt(0);
  if (firstChar === "0" || firstChar === "-") {
    text = text.replace(/^(0+)[.]/, ".");
    text = text.replace(/^-(0+)[.]/, "-.");
    text = text.replace(/^(-?)0+$/, "$10");
  }
  if (text === "-0") {
    return "0";
  }
  return text;
};
var cleanUpNumber_default = cleanUpNumber;

// node_modules/@js-draw/math/dist/mjs/rounding/toRoundedString.mjs
var toRoundedString = (num) => {
  const fixRoundingUpExp = /^([-]?\d*\.\d{3,})0{4,}\d{1,4}$/;
  const hasRoundingDownExp = /^([-]?)(\d*)\.(\d{3,}9{4,})\d{1,4}$/;
  let text = num.toString(10);
  if (text.indexOf(".") === -1) {
    return text;
  }
  const roundingDownMatch = hasRoundingDownExp.exec(text);
  if (roundingDownMatch) {
    const negativeSign = roundingDownMatch[1];
    const postDecimalString = roundingDownMatch[3];
    const lastDigit = parseInt(postDecimalString.charAt(postDecimalString.length - 1), 10);
    const postDecimal = parseInt(postDecimalString, 10);
    const preDecimal = parseInt(roundingDownMatch[2], 10);
    const origPostDecimalString = roundingDownMatch[3];
    let newPostDecimal = (postDecimal + 10 - lastDigit).toString();
    let carry = 0;
    if (newPostDecimal.length > postDecimal.toString().length) {
      newPostDecimal = newPostDecimal.substring(1);
      carry = 1;
    }
    while (newPostDecimal.length < origPostDecimalString.length) {
      newPostDecimal = carry.toString(10) + newPostDecimal;
      carry = 0;
    }
    text = `${negativeSign + (preDecimal + carry).toString()}.${newPostDecimal}`;
  }
  text = text.replace(fixRoundingUpExp, "$1");
  return cleanUpNumber_default(text);
};
var toRoundedString_default = toRoundedString;

// node_modules/@js-draw/math/dist/mjs/rounding/constants.mjs
var numberRegex = /^([-]?)(\d*)[.](\d+)$/;

// node_modules/@js-draw/math/dist/mjs/rounding/getLenAfterDecimal.mjs
var getLenAfterDecimal = (numberAsString) => {
  const numberMatch = numberRegex.exec(numberAsString);
  if (!numberMatch) {
    if (numberAsString.search(/[eE]/) !== -1 || /^[a-zA-Z]+$/.exec(numberAsString)) {
      return -1;
    } else {
      return 0;
    }
  }
  const afterDecimalLen = numberMatch[3].length;
  return afterDecimalLen;
};
var getLenAfterDecimal_default = getLenAfterDecimal;

// node_modules/@js-draw/math/dist/mjs/rounding/toStringOfSamePrecision.mjs
var toStringOfSamePrecision = (num, ...references) => {
  const text = num.toString(10);
  const textMatch = numberRegex.exec(text);
  if (!textMatch) {
    return text;
  }
  let decimalPlaces = -1;
  for (const reference of references) {
    decimalPlaces = Math.max(getLenAfterDecimal_default(reference), decimalPlaces);
  }
  if (decimalPlaces === -1) {
    return toRoundedString_default(num);
  }
  let postDecimal = textMatch[3].substring(0, decimalPlaces);
  let preDecimal = textMatch[2];
  const nextDigit = textMatch[3].charAt(decimalPlaces);
  if (nextDigit !== "") {
    const asNumber = parseInt(nextDigit, 10);
    if (asNumber >= 5) {
      if (postDecimal.length > 0) {
        const leadingZeroMatch = /^(0+)(\d*)$/.exec(postDecimal);
        let leadingZeroes = "";
        let postLeading = postDecimal;
        if (leadingZeroMatch) {
          leadingZeroes = leadingZeroMatch[1];
          postLeading = leadingZeroMatch[2];
        }
        postDecimal = (parseInt(postDecimal) + 1).toString();
        if (postDecimal.length > postLeading.length && leadingZeroes.length > 0) {
          leadingZeroes = leadingZeroes.substring(1);
        }
        postDecimal = leadingZeroes + postDecimal;
      }
      if (postDecimal.length === 0 || postDecimal.length > decimalPlaces) {
        preDecimal = (parseInt(preDecimal) + 1).toString();
        postDecimal = postDecimal.substring(1);
      }
    }
  }
  const negativeSign = textMatch[1];
  return cleanUpNumber_default(`${negativeSign}${preDecimal}.${postDecimal}`);
};
var toStringOfSamePrecision_default = toStringOfSamePrecision;

// node_modules/@js-draw/math/dist/mjs/utils/convexHull2Of.mjs
var convexHull2Of = (points) => {
  if (points.length === 0) {
    return [];
  }
  const lowestPoint = points.reduce((lowest, current) => current.y < lowest.y ? current : lowest, points[0]);
  const vertices = [lowestPoint];
  let toProcess = [...points.filter((p) => !p.eq(lowestPoint))];
  let lastBaseDirection = Vec2.of(-1, 0);
  while (toProcess.length > 0) {
    const lastVertex = vertices[vertices.length - 1];
    let smallestDotProductSoFar = lastBaseDirection.dot(lowestPoint.minus(lastVertex).normalizedOrZero());
    let furthestPointSoFar = lowestPoint;
    for (const point of toProcess) {
      const currentDotProduct = lastBaseDirection.dot(point.minus(lastVertex).normalizedOrZero());
      if (currentDotProduct <= smallestDotProductSoFar) {
        furthestPointSoFar = point;
        smallestDotProductSoFar = currentDotProduct;
      }
    }
    toProcess = toProcess.filter((p) => !p.eq(furthestPointSoFar));
    const newBaseDirection = furthestPointSoFar.minus(lastVertex).normalized();
    if (Math.abs(newBaseDirection.dot(lastBaseDirection)) === 1 && vertices.length > 1) {
      vertices.pop();
    }
    if (furthestPointSoFar.eq(lowestPoint)) {
      break;
    } else {
      vertices.push(furthestPointSoFar);
      lastBaseDirection = lastVertex.minus(furthestPointSoFar).normalized();
    }
  }
  return vertices;
};
var convexHull2Of_default = convexHull2Of;

// node_modules/@js-draw/math/dist/mjs/shapes/Path.mjs
var PathCommandType;
(function(PathCommandType2) {
  PathCommandType2[PathCommandType2["LineTo"] = 0] = "LineTo";
  PathCommandType2[PathCommandType2["MoveTo"] = 1] = "MoveTo";
  PathCommandType2[PathCommandType2["CubicBezierTo"] = 2] = "CubicBezierTo";
  PathCommandType2[PathCommandType2["QuadraticBezierTo"] = 3] = "QuadraticBezierTo";
})(PathCommandType || (PathCommandType = {}));
var compareCurveIndices = (a, b) => {
  const indexCompare = a.curveIndex - b.curveIndex;
  if (indexCompare === 0) {
    return a.parameterValue - b.parameterValue;
  } else {
    return indexCompare;
  }
};
var stepCurveIndexBy = (index, stepBy) => {
  if (index.parameterValue + stepBy > 1) {
    return { curveIndex: index.curveIndex + 1, parameterValue: index.parameterValue + stepBy - 1 };
  }
  if (index.parameterValue + stepBy < 0) {
    if (index.curveIndex === 0) {
      return { curveIndex: 0, parameterValue: 0 };
    }
    return { curveIndex: index.curveIndex - 1, parameterValue: index.parameterValue + stepBy + 1 };
  }
  return { curveIndex: index.curveIndex, parameterValue: index.parameterValue + stepBy };
};
var Path = class _Path {
  /**
   * Creates a new `Path` that starts at `startPoint` and is made up of the path commands,
   * `parts`.
   *
   * See also {@link fromString}
   */
  constructor(startPoint, parts) {
    this.startPoint = startPoint;
    this.cachedGeometry = null;
    this.cachedPolylineApproximation = null;
    this.cachedStringVersion = null;
    this.parts = parts;
    this.bbox = Rect2_default.bboxOf([startPoint]);
    for (const part of this.parts) {
      this.bbox = this.bbox.union(_Path.computeBBoxForSegment(startPoint, part));
    }
  }
  /**
   * Computes and returns the full bounding box for this path.
   *
   * If a slight over-estimate of a path's bounding box is sufficient, use
   * {@link bbox} instead.
   */
  getExactBBox() {
    const bboxes = [];
    for (const part of this.geometry) {
      bboxes.push(part.getTightBoundingBox());
    }
    return Rect2_default.union(...bboxes);
  }
  // Lazy-loads and returns this path's geometry
  get geometry() {
    if (this.cachedGeometry) {
      return this.cachedGeometry;
    }
    let startPoint = this.startPoint;
    const geometry = [];
    for (const part of this.parts) {
      let exhaustivenessCheck;
      switch (part.kind) {
        case PathCommandType.CubicBezierTo:
          geometry.push(new CubicBezier_default(startPoint, part.controlPoint1, part.controlPoint2, part.endPoint));
          startPoint = part.endPoint;
          break;
        case PathCommandType.QuadraticBezierTo:
          geometry.push(new QuadraticBezier_default(startPoint, part.controlPoint, part.endPoint));
          startPoint = part.endPoint;
          break;
        case PathCommandType.LineTo:
          geometry.push(new LineSegment2_default(startPoint, part.point));
          startPoint = part.point;
          break;
        case PathCommandType.MoveTo:
          geometry.push(new PointShape2D_default(part.point));
          startPoint = part.point;
          break;
        default:
          exhaustivenessCheck = part;
          return exhaustivenessCheck;
      }
    }
    this.cachedGeometry = geometry;
    return this.cachedGeometry;
  }
  /**
   * Iterates through the start/end points of each component in this path.
   *
   * If a start point is equivalent to the end point of the previous segment,
   * the point is **not** emitted twice.
   */
  *startEndPoints() {
    yield this.startPoint;
    for (const part of this.parts) {
      let exhaustivenessCheck;
      switch (part.kind) {
        case PathCommandType.CubicBezierTo:
          yield part.endPoint;
          break;
        case PathCommandType.QuadraticBezierTo:
          yield part.endPoint;
          break;
        case PathCommandType.LineTo:
          yield part.point;
          break;
        case PathCommandType.MoveTo:
          yield part.point;
          break;
        default:
          exhaustivenessCheck = part;
          return exhaustivenessCheck;
      }
    }
  }
  // Approximates this path with a group of line segments.
  polylineApproximation() {
    if (this.cachedPolylineApproximation) {
      return this.cachedPolylineApproximation;
    }
    const points = [];
    for (const part of this.parts) {
      switch (part.kind) {
        case PathCommandType.CubicBezierTo:
          points.push(part.controlPoint1, part.controlPoint2, part.endPoint);
          break;
        case PathCommandType.QuadraticBezierTo:
          points.push(part.controlPoint, part.endPoint);
          break;
        case PathCommandType.MoveTo:
        case PathCommandType.LineTo:
          points.push(part.point);
          break;
      }
    }
    const result = [];
    let prevPoint = this.startPoint;
    for (const point of points) {
      result.push(new LineSegment2_default(prevPoint, point));
      prevPoint = point;
    }
    return result;
  }
  static computeBBoxForSegment(startPoint, part) {
    const points = [startPoint];
    let exhaustivenessCheck;
    switch (part.kind) {
      case PathCommandType.MoveTo:
      case PathCommandType.LineTo:
        points.push(part.point);
        break;
      case PathCommandType.CubicBezierTo:
        points.push(part.controlPoint1, part.controlPoint2, part.endPoint);
        break;
      case PathCommandType.QuadraticBezierTo:
        points.push(part.controlPoint, part.endPoint);
        break;
      default:
        exhaustivenessCheck = part;
        return exhaustivenessCheck;
    }
    return Rect2_default.bboxOf(points);
  }
  /**
   * Returns the signed distance between `point` and a curve `strokeRadius` units
   * away from this path.
   *
   * This returns the **signed distance**, which means that points inside this shape
   * have their distance negated. For example,
   * ```ts,runnable,console
   * import {Path, Vec2} from '@js-draw/math';
   * console.log(Path.fromString('m0,0 L100,0').signedDistance(Vec2.zero, 1));
   * ```
   * would print `-1` because (0,0) is on `m0,0 L100,0` and thus one unit away from its boundary.
   *
   * **Note**: `strokeRadius = strokeWidth / 2`
   */
  signedDistance(point, strokeRadius) {
    let minDist = Infinity;
    for (const part of this.geometry) {
      const currentDist = part.signedDistance(point) - strokeRadius;
      if (currentDist < minDist) {
        minDist = currentDist;
      }
    }
    return minDist;
  }
  /**
   * Let `S` be a closed path a distance `strokeRadius` from this path.
   *
   * @returns Approximate intersections of `line` with `S` using ray marching, starting from
   * 	        both end points of `line` and each point in `additionalRaymarchStartPoints`.
   */
  raymarchIntersectionWith(line, strokeRadius, additionalRaymarchStartPoints = []) {
    if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius))) {
      return [];
    }
    const lineLength = line.length;
    const partDistFunctionRecords = [];
    for (const part of this.geometry) {
      const bbox = part.getTightBoundingBox().grownBy(strokeRadius);
      if (!bbox.intersects(line.bbox)) {
        continue;
      }
      const partDist = (point) => part.signedDistance(point);
      const partSdf = (point) => partDist(point) - strokeRadius;
      if (partSdf(line.p1) > lineLength && partSdf(line.p2) > lineLength) {
        continue;
      }
      partDistFunctionRecords.push({
        part,
        distFn: partDist,
        bbox
      });
    }
    if (partDistFunctionRecords.length === 0) {
      return [];
    }
    const sdf = (point) => {
      let minDist = Infinity;
      let minDistPart = null;
      const uncheckedDistFunctions = [];
      for (const distFnRecord of partDistFunctionRecords) {
        const { part, distFn, bbox } = distFnRecord;
        if (!bbox.containsPoint(point)) {
          uncheckedDistFunctions.push(distFnRecord);
          continue;
        }
        const currentDist = distFn(point);
        if (currentDist <= minDist) {
          minDist = currentDist;
          minDistPart = part;
        }
      }
      for (const { part, distFn, bbox } of uncheckedDistFunctions) {
        if (isFinite(minDist) && !bbox.grownBy(minDist).containsPoint(point)) {
          continue;
        }
        const currentDist = distFn(point);
        if (currentDist <= minDist) {
          minDist = currentDist;
          minDistPart = part;
        }
      }
      return [minDistPart, minDist - strokeRadius];
    };
    const maxRaymarchSteps = 8;
    const startPoints = [line.p1, ...additionalRaymarchStartPoints, line.p2];
    const pointToParameter = (point) => {
      return point.minus(line.p1).dot(line.direction);
    };
    startPoints.sort((a, b) => {
      const t_a = pointToParameter(a);
      const t_b = pointToParameter(b);
      return t_a - t_b;
    });
    const result = [];
    const stoppingThreshold = strokeRadius / 1e3;
    const raymarchFrom = (startPoint, directionMultiplier, minimumLineParameter) => {
      let currentPoint = startPoint;
      let [lastPart, lastDist] = sdf(currentPoint);
      let lastParameter = pointToParameter(currentPoint);
      if (lastDist > lineLength) {
        return lastParameter;
      }
      const direction = line.direction.times(directionMultiplier);
      for (let i = 0; i < maxRaymarchSteps; i++) {
        const step = lastDist;
        currentPoint = currentPoint.plus(direction.times(step));
        lastParameter = pointToParameter(currentPoint);
        if (lastParameter <= minimumLineParameter) {
          return lastParameter;
        }
        const [currentPart, signedDist] = sdf(currentPoint);
        if (Math.abs(signedDist) > Math.abs(lastDist)) {
          return null;
        }
        lastDist = signedDist;
        lastPart = currentPart;
        if (Math.abs(lastDist) < stoppingThreshold) {
          break;
        }
      }
      const isOnLineSegment = lastParameter >= 0 && lastParameter <= lineLength;
      if (lastPart && isOnLineSegment && Math.abs(lastDist) < stoppingThreshold) {
        result.push({
          point: currentPoint,
          parameterValue: lastPart.nearestPointTo(currentPoint).parameterValue,
          curve: lastPart,
          curveIndex: this.geometry.indexOf(lastPart)
        });
        const parameterIncrease = strokeRadius / 20 / line.length;
        lastParameter += isFinite(parameterIncrease) ? parameterIncrease : 0;
      }
      return lastParameter;
    };
    let maxLineT = 0;
    for (let i = 0; i < startPoints.length; i++) {
      const startPoint = startPoints[i];
      maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, 1, maxLineT) ?? maxLineT);
      maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, -1, maxLineT) ?? maxLineT);
    }
    return result;
  }
  /**
   * Returns a list of intersections with this path. If `strokeRadius` is given,
   * intersections are approximated with the surface `strokeRadius` away from this.
   *
   * If `strokeRadius > 0`, the resultant `parameterValue` has no defined value.
   *
   * **Note**: `strokeRadius` is half of a stroke's width.
   */
  intersection(line, strokeRadius) {
    let result = [];
    if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius ?? 0))) {
      return [];
    }
    if (this.parts.length === 0) {
      return new _Path(this.startPoint, [
        { kind: PathCommandType.MoveTo, point: this.startPoint }
      ]).intersection(line, strokeRadius);
    }
    let index = 0;
    for (const part of this.geometry) {
      const intersections = part.argIntersectsLineSegment(line);
      for (const intersection of intersections) {
        result.push({
          curve: part,
          curveIndex: index,
          point: part.at(intersection),
          parameterValue: intersection
        });
      }
      index++;
    }
    const doRaymarching = strokeRadius && strokeRadius > 1e-8;
    if (doRaymarching) {
      const startPoints = result.map((intersection) => intersection.point);
      result = this.raymarchIntersectionWith(line, strokeRadius, startPoints);
    }
    return result;
  }
  /**
   * @returns the nearest point on this path to the given `point`.
   */
  nearestPointTo(point) {
    let closestSquareDist = Infinity;
    let closestPartIndex = 0;
    let closestParameterValue = 0;
    let closestPoint = this.startPoint;
    for (let i = 0; i < this.geometry.length; i++) {
      const current = this.geometry[i];
      const nearestPoint = current.nearestPointTo(point);
      const sqareDist = nearestPoint.point.squareDistanceTo(point);
      if (i === 0 || sqareDist < closestSquareDist) {
        closestPartIndex = i;
        closestSquareDist = sqareDist;
        closestParameterValue = nearestPoint.parameterValue;
        closestPoint = nearestPoint.point;
      }
    }
    return {
      curve: this.geometry[closestPartIndex],
      curveIndex: closestPartIndex,
      parameterValue: closestParameterValue,
      point: closestPoint
    };
  }
  at(index) {
    if (index.curveIndex === 0 && index.parameterValue === 0) {
      return this.startPoint;
    }
    return this.geometry[index.curveIndex].at(index.parameterValue);
  }
  tangentAt(index) {
    return this.geometry[index.curveIndex].tangentAt(index.parameterValue);
  }
  /** Splits this path in two near the given `point`. */
  splitNear(point, options) {
    const nearest = this.nearestPointTo(point);
    return this.splitAt(nearest, options);
  }
  /**
   * Returns a copy of this path with `deleteFrom` until `deleteUntil` replaced with `insert`.
   *
   * This method is analogous to {@link Array.toSpliced}.
   */
  spliced(deleteFrom, deleteTo, insert, options) {
    const isBeforeOrEqual = (a, b) => {
      return a.curveIndex < b.curveIndex || a.curveIndex === b.curveIndex && a.parameterValue <= b.parameterValue;
    };
    if (isBeforeOrEqual(deleteFrom, deleteTo)) {
      const firstSplit = this.splitAt(deleteFrom, options);
      const secondSplit = this.splitAt(deleteTo, options);
      const before = firstSplit[0];
      const after = secondSplit[secondSplit.length - 1];
      return insert ? before.union(insert).union(after) : before.union(after);
    } else {
      const splitAtFrom = this.splitAt([deleteFrom], options);
      const beforeFrom = splitAtFrom[0];
      const splitAtTo = beforeFrom.splitNear(this.at(deleteTo), options);
      const betweenBoth = splitAtTo[splitAtTo.length - 1];
      return insert ? betweenBoth.union(insert) : betweenBoth;
    }
  }
  // @internal
  splitAt(splitAt, options) {
    if (!Array.isArray(splitAt)) {
      splitAt = [splitAt];
    }
    splitAt = [...splitAt];
    splitAt.sort(compareCurveIndices);
    while (splitAt.length > 0 && splitAt[splitAt.length - 1].curveIndex >= this.parts.length - 1 && splitAt[splitAt.length - 1].parameterValue >= 1) {
      splitAt.pop();
    }
    splitAt.reverse();
    while (splitAt.length > 0 && splitAt[splitAt.length - 1].curveIndex <= 0 && splitAt[splitAt.length - 1].parameterValue <= 0) {
      splitAt.pop();
    }
    if (splitAt.length === 0 || this.parts.length === 0) {
      return [this];
    }
    const expectedSplitCount = splitAt.length + 1;
    const mapNewPoint = (options == null ? void 0 : options.mapNewPoint) ?? ((p) => p);
    const result = [];
    let currentStartPoint = this.startPoint;
    let currentPath = [];
    let { curveIndex, parameterValue } = splitAt.pop();
    for (let i = 0; i < this.parts.length; i++) {
      if (i !== curveIndex) {
        currentPath.push(this.parts[i]);
      } else {
        let part = this.parts[i];
        let geom = this.geometry[i];
        while (i === curveIndex) {
          let newPathStart;
          const newPath = [];
          switch (part.kind) {
            case PathCommandType.MoveTo:
              currentPath.push({
                kind: part.kind,
                point: part.point
              });
              newPathStart = part.point;
              break;
            case PathCommandType.LineTo:
              {
                const split = geom.splitAt(parameterValue);
                currentPath.push({
                  kind: part.kind,
                  point: mapNewPoint(split[0].p2)
                });
                newPathStart = split[0].p2;
                if (split.length > 1) {
                  console.assert(split.length === 2);
                  newPath.push({
                    kind: part.kind,
                    // Don't map: For lines, the end point of the split is
                    // the same as the end point of the original:
                    point: split[1].p2
                  });
                  geom = split[1];
                }
              }
              break;
            case PathCommandType.QuadraticBezierTo:
            case PathCommandType.CubicBezierTo:
              {
                const split = geom.splitAt(parameterValue);
                let isFirstPart = split.length === 2;
                for (const segment of split) {
                  geom = segment;
                  const targetArray = isFirstPart ? currentPath : newPath;
                  const controlPoints = segment.getPoints();
                  if (part.kind === PathCommandType.CubicBezierTo) {
                    targetArray.push({
                      kind: part.kind,
                      controlPoint1: mapNewPoint(controlPoints[1]),
                      controlPoint2: mapNewPoint(controlPoints[2]),
                      endPoint: mapNewPoint(controlPoints[3])
                    });
                  } else {
                    targetArray.push({
                      kind: part.kind,
                      controlPoint: mapNewPoint(controlPoints[1]),
                      endPoint: mapNewPoint(controlPoints[2])
                    });
                  }
                  if (!isFirstPart) {
                    newPathStart = controlPoints[0];
                  }
                  isFirstPart = false;
                }
              }
              break;
            default: {
              const exhaustivenessCheck = part;
              return exhaustivenessCheck;
            }
          }
          result.push(new _Path(currentStartPoint, [...currentPath]));
          currentStartPoint = mapNewPoint(newPathStart);
          console.assert(!!currentStartPoint, "should have a start point");
          currentPath = newPath;
          part = newPath[newPath.length - 1] ?? part;
          const nextSplit = splitAt.pop();
          if (!nextSplit) {
            break;
          } else {
            curveIndex = nextSplit.curveIndex;
            if (i === curveIndex) {
              const originalPoint = this.at(nextSplit);
              parameterValue = geom.nearestPointTo(originalPoint).parameterValue;
              currentPath = [];
            } else {
              parameterValue = nextSplit.parameterValue;
            }
          }
        }
      }
    }
    result.push(new _Path(currentStartPoint, currentPath));
    console.assert(result.length === expectedSplitCount, `should split into splitAt.length + 1 splits (was ${result.length}, expected ${expectedSplitCount})`);
    return result;
  }
  /**
   * Replaces all `MoveTo` commands with `LineTo` commands and connects the end point of this
   * path to the start point.
   */
  asClosed() {
    const newParts = [];
    let hasChanges = false;
    for (const part of this.parts) {
      if (part.kind === PathCommandType.MoveTo) {
        newParts.push({
          kind: PathCommandType.LineTo,
          point: part.point
        });
        hasChanges = true;
      } else {
        newParts.push(part);
      }
    }
    if (!this.getEndPoint().eq(this.startPoint)) {
      newParts.push({
        kind: PathCommandType.LineTo,
        point: this.startPoint
      });
      hasChanges = true;
    }
    if (!hasChanges) {
      return this;
    }
    const result = new _Path(this.startPoint, newParts);
    console.assert(result.getEndPoint().eq(result.startPoint));
    return result;
  }
  static mapPathCommand(part, mapping) {
    switch (part.kind) {
      case PathCommandType.MoveTo:
      case PathCommandType.LineTo:
        return {
          kind: part.kind,
          point: mapping(part.point)
        };
        break;
      case PathCommandType.CubicBezierTo:
        return {
          kind: part.kind,
          controlPoint1: mapping(part.controlPoint1),
          controlPoint2: mapping(part.controlPoint2),
          endPoint: mapping(part.endPoint)
        };
        break;
      case PathCommandType.QuadraticBezierTo:
        return {
          kind: part.kind,
          controlPoint: mapping(part.controlPoint),
          endPoint: mapping(part.endPoint)
        };
        break;
    }
    const exhaustivenessCheck = part;
    return exhaustivenessCheck;
  }
  mapPoints(mapping) {
    const startPoint = mapping(this.startPoint);
    const newParts = [];
    for (const part of this.parts) {
      newParts.push(_Path.mapPathCommand(part, mapping));
    }
    return new _Path(startPoint, newParts);
  }
  transformedBy(affineTransfm) {
    if (affineTransfm.isIdentity()) {
      return this;
    }
    return this.mapPoints((point) => affineTransfm.transformVec2(point));
  }
  /**
   * @internal -- TODO: This method may have incorrect output in some cases.
   */
  closedContainsPoint(point) {
    const bbox = this.getExactBBox();
    if (!bbox.containsPoint(point)) {
      return false;
    }
    const pointOutside = point.plus(Vec2.of(bbox.width, 0));
    const asClosed = this.asClosed();
    const lineToOutside = new LineSegment2_default(point, pointOutside);
    const intersections = asClosed.intersection(lineToOutside);
    const filteredIntersections = intersections.filter((intersection, index) => {
      if (index === 0)
        return true;
      const previousIntersection = intersections[index - 1];
      const isRepeatedIntersection = previousIntersection.parameterValue >= 1 && intersection.parameterValue <= 0;
      return !isRepeatedIntersection;
    });
    return filteredIntersections.length % 2 === 1;
  }
  /**
   * @returns `true` if this path (interpreted as a closed path) contains the given rectangle.
   */
  closedContainsRect(rect) {
    if (!this.bbox.containsRect(rect))
      return false;
    if (!rect.corners.every((corner) => this.closedContainsPoint(corner)))
      return false;
    for (const edge of rect.getEdges()) {
      if (this.intersection(edge).length) {
        return false;
      }
    }
    return true;
  }
  // Creates a new path by joining [other] to the end of this path
  union(other, options = { allowReverse: true }) {
    if (!other) {
      return this;
    }
    if (Array.isArray(other)) {
      return new _Path(this.startPoint, [...this.parts, ...other]);
    }
    const thisEnd = this.getEndPoint();
    let newParts = [];
    if (thisEnd.eq(other.startPoint)) {
      newParts = this.parts.concat(other.parts);
    } else if (options.allowReverse && this.startPoint.eq(other.getEndPoint())) {
      return other.union(this, { allowReverse: false });
    } else if (options.allowReverse && this.startPoint.eq(other.startPoint)) {
      return this.union(other.reversed(), { allowReverse: false });
    } else {
      newParts = [
        ...this.parts,
        {
          kind: PathCommandType.MoveTo,
          point: other.startPoint
        },
        ...other.parts
      ];
    }
    return new _Path(this.startPoint, newParts);
  }
  /**
   * @returns a version of this path with the direction reversed.
   *
   * Example:
   * ```ts,runnable,console
   * import {Path} from '@js-draw/math';
   * console.log(Path.fromString('m0,0l1,1').reversed()); // -> M1,1 L0,0
   * ```
   */
  reversed() {
    const newStart = this.getEndPoint();
    const newParts = [];
    let lastPoint = this.startPoint;
    for (const part of this.parts) {
      switch (part.kind) {
        case PathCommandType.LineTo:
        case PathCommandType.MoveTo:
          newParts.push({
            kind: part.kind,
            point: lastPoint
          });
          lastPoint = part.point;
          break;
        case PathCommandType.CubicBezierTo:
          newParts.push({
            kind: part.kind,
            controlPoint1: part.controlPoint2,
            controlPoint2: part.controlPoint1,
            endPoint: lastPoint
          });
          lastPoint = part.endPoint;
          break;
        case PathCommandType.QuadraticBezierTo:
          newParts.push({
            kind: part.kind,
            controlPoint: part.controlPoint,
            endPoint: lastPoint
          });
          lastPoint = part.endPoint;
          break;
        default: {
          const exhaustivenessCheck = part;
          return exhaustivenessCheck;
        }
      }
    }
    newParts.reverse();
    return new _Path(newStart, newParts);
  }
  /** Computes and returns the end point of this path */
  getEndPoint() {
    if (this.parts.length === 0) {
      return this.startPoint;
    }
    const lastPart = this.parts[this.parts.length - 1];
    if (lastPart.kind === PathCommandType.QuadraticBezierTo || lastPart.kind === PathCommandType.CubicBezierTo) {
      return lastPart.endPoint;
    } else {
      return lastPart.point;
    }
  }
  /**
   * Like {@link closedRoughlyIntersects} except takes stroke width into account.
   *
   * This is intended to be a very fast and rough approximation. Use {@link intersection}
   * and {@link signedDistance} for more accurate (but much slower) intersection calculations.
   *
   * **Note**: Unlike other methods, this accepts `strokeWidth` (and not `strokeRadius`).
   *
   * `strokeRadius` is half of `strokeWidth`.
   */
  roughlyIntersects(rect, strokeWidth = 0) {
    if (this.parts.length === 0) {
      return rect.containsPoint(this.startPoint);
    }
    const isClosed = this.startPoint.eq(this.getEndPoint());
    if (isClosed && strokeWidth === 0) {
      return this.closedRoughlyIntersects(rect);
    }
    if (rect.containsRect(this.bbox)) {
      return true;
    }
    let startPoint = this.startPoint;
    for (const part of this.parts) {
      const bbox = _Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);
      if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {
        startPoint = part.point;
      } else {
        startPoint = part.endPoint;
      }
      if (rect.intersects(bbox)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Treats this as a closed path and returns true if part of `rect` is *roughly* within
   * this path's interior.
   *
   * **Note**: Assumes that this is a closed, non-self-intersecting path.
   */
  closedRoughlyIntersects(rect) {
    if (rect.containsRect(this.bbox)) {
      return true;
    }
    const startPt = this.bbox.topLeft.minus(Vec2.of(1, 1));
    const testPts = rect.corners;
    const polygon = this.polylineApproximation();
    for (const point of testPts) {
      const testLine = new LineSegment2_default(point, startPt);
      let intersectionCount = 0;
      for (const line of polygon) {
        if (line.intersects(testLine)) {
          intersectionCount++;
        }
      }
      if (intersectionCount % 2 === 1) {
        return true;
      }
    }
    const grownRect = rect.grownBy(Math.min(rect.size.x, rect.size.y));
    const edges = [];
    for (const subrect of grownRect.divideIntoGrid(4, 4)) {
      edges.push(...subrect.getEdges());
    }
    for (const edge of edges) {
      for (const line of polygon) {
        if (edge.intersects(line)) {
          return true;
        }
      }
    }
    return false;
  }
  /** @returns true if all points on this are equivalent to the points on `other` */
  eq(other, tolerance) {
    if (other.parts.length !== this.parts.length) {
      return false;
    }
    for (let i = 0; i < this.parts.length; i++) {
      const part1 = this.parts[i];
      const part2 = other.parts[i];
      switch (part1.kind) {
        case PathCommandType.LineTo:
        case PathCommandType.MoveTo:
          if (part1.kind !== part2.kind) {
            return false;
          } else if (!part1.point.eq(part2.point, tolerance)) {
            return false;
          }
          break;
        case PathCommandType.CubicBezierTo:
          if (part1.kind !== part2.kind) {
            return false;
          } else if (!part1.controlPoint1.eq(part2.controlPoint1, tolerance) || !part1.controlPoint2.eq(part2.controlPoint2, tolerance) || !part1.endPoint.eq(part2.endPoint, tolerance)) {
            return false;
          }
          break;
        case PathCommandType.QuadraticBezierTo:
          if (part1.kind !== part2.kind) {
            return false;
          } else if (!part1.controlPoint.eq(part2.controlPoint, tolerance) || !part1.endPoint.eq(part2.endPoint, tolerance)) {
            return false;
          }
          break;
        default: {
          const exhaustivenessCheck = part1;
          return exhaustivenessCheck;
        }
      }
    }
    return true;
  }
  /**
   * Returns a path that outlines `rect`.
   *
   * If `lineWidth` is given, the resultant path traces a `lineWidth` thick
   * border around `rect`. Otherwise, the resultant path is just the border
   * of `rect`.
   */
  static fromRect(rect, lineWidth = null) {
    const commands = [];
    let corners;
    let startPoint;
    if (lineWidth !== null) {
      const cornerToEdge = Vec2.of(lineWidth, lineWidth).times(0.5);
      const innerRect = Rect2_default.fromCorners(rect.topLeft.plus(cornerToEdge), rect.bottomRight.minus(cornerToEdge));
      const outerRect = Rect2_default.fromCorners(rect.topLeft.minus(cornerToEdge), rect.bottomRight.plus(cornerToEdge));
      corners = [innerRect.corners[3], ...innerRect.corners, ...outerRect.corners.reverse()];
      startPoint = outerRect.corners[3];
    } else {
      corners = rect.corners.slice(1);
      startPoint = rect.corners[0];
    }
    for (const corner of corners) {
      commands.push({
        kind: PathCommandType.LineTo,
        point: corner
      });
    }
    commands.push({
      kind: PathCommandType.LineTo,
      point: startPoint
    });
    return new _Path(startPoint, commands);
  }
  /**
   * Convert to an [SVG path representation](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).
   *
   * If `useNonAbsCommands` is given, relative path commands (e.g. `l10,0`) are to be used instead of
   * absolute commands (e.g. `L10,0`).
   *
   * See also {@link fromString}.
   */
  toString(useNonAbsCommands, ignoreCache = false) {
    if (this.cachedStringVersion && !ignoreCache) {
      return this.cachedStringVersion;
    }
    if (useNonAbsCommands === void 0) {
      useNonAbsCommands = Math.abs(this.bbox.topLeft.x) > 10 && Math.abs(this.bbox.topLeft.y) > 10;
    }
    const result = _Path.toString(this.startPoint, this.parts, !useNonAbsCommands);
    this.cachedStringVersion = result;
    return result;
  }
  serialize() {
    return this.toString();
  }
  // @param onlyAbsCommands - True if we should avoid converting absolute coordinates to relative offsets -- such
  //   conversions can lead to smaller output strings, but also take time.
  static toString(startPoint, parts, onlyAbsCommands) {
    var _a6;
    const result = [];
    let prevPoint;
    const addCommand = (command, ...points) => {
      const absoluteCommandParts = [];
      const relativeCommandParts = [];
      const makeAbsCommand = !prevPoint || onlyAbsCommands;
      const roundedPrevX = prevPoint ? toRoundedString_default(prevPoint.x) : "";
      const roundedPrevY = prevPoint ? toRoundedString_default(prevPoint.y) : "";
      for (const point of points) {
        const xComponent = toRoundedString_default(point.x);
        const yComponent = toRoundedString_default(point.y);
        if (!makeAbsCommand) {
          const xComponentRelative = toStringOfSamePrecision_default(point.x - prevPoint.x, xComponent, roundedPrevX, roundedPrevY);
          const yComponentRelative = toStringOfSamePrecision_default(point.y - prevPoint.y, yComponent, roundedPrevX, roundedPrevY);
          if (yComponentRelative.charAt(0) === "-") {
            relativeCommandParts.push(`${xComponentRelative}${yComponentRelative}`);
          } else {
            relativeCommandParts.push(`${xComponentRelative},${yComponentRelative}`);
          }
        } else {
          absoluteCommandParts.push(`${xComponent},${yComponent}`);
        }
      }
      let commandString;
      if (makeAbsCommand) {
        commandString = `${command}${absoluteCommandParts.join(" ")}`;
      } else {
        commandString = `${command.toLowerCase()}${relativeCommandParts.join(" ")}`;
      }
      if (commandString === "l0,0" || commandString === "m0,0") {
        return;
      }
      result.push(commandString);
      if (points.length > 0) {
        prevPoint = points[points.length - 1];
      }
    };
    if (((_a6 = parts[0]) == null ? void 0 : _a6.kind) !== PathCommandType.MoveTo) {
      addCommand("M", startPoint);
    }
    let exhaustivenessCheck;
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      switch (part.kind) {
        case PathCommandType.MoveTo:
          addCommand("M", part.point);
          break;
        case PathCommandType.LineTo:
          addCommand("L", part.point);
          break;
        case PathCommandType.CubicBezierTo:
          addCommand("C", part.controlPoint1, part.controlPoint2, part.endPoint);
          break;
        case PathCommandType.QuadraticBezierTo:
          addCommand("Q", part.controlPoint, part.endPoint);
          break;
        default:
          exhaustivenessCheck = part;
          return exhaustivenessCheck;
      }
    }
    return result.join("");
  }
  /**
   * Create a `Path` from a subset of the SVG path specification.
   *
   * Currently, this does not support elliptical arcs or `s` and `t` command
   * shorthands. See https://github.com/personalizedrefrigerator/js-draw/pull/19.
   *
   * @example
   * ```ts,runnable,console
   * import { Path } from '@js-draw/math';
   *
   * const path = Path.fromString('m0,0l100,100');
   * console.log(path.toString(true)); // true: Prefer relative to absolute path commands
   * ```
   */
  static fromString(pathString) {
    pathString = pathString.split("\n").join(" ");
    let lastPos = Vec2.zero;
    let firstPos = null;
    let startPos = null;
    let isFirstCommand = true;
    const commands = [];
    const moveTo = (point) => {
      if (isFirstCommand) {
        isFirstCommand = false;
        return;
      }
      commands.push({
        kind: PathCommandType.MoveTo,
        point
      });
    };
    const lineTo = (point) => {
      if (isFirstCommand) {
        isFirstCommand = false;
        return;
      }
      commands.push({
        kind: PathCommandType.LineTo,
        point
      });
    };
    const cubicBezierTo = (cp1, cp2, end) => {
      commands.push({
        kind: PathCommandType.CubicBezierTo,
        controlPoint1: cp1,
        controlPoint2: cp2,
        endPoint: end
      });
    };
    const quadraticBeierTo = (controlPoint, endPoint) => {
      commands.push({
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint,
        endPoint
      });
    };
    const commandArgCounts = {
      m: 1,
      l: 1,
      c: 3,
      q: 2,
      z: 0,
      h: 1,
      v: 1
    };
    const commandExp = /([MZLHVCSQTA])\s*([^MZLHVCSQTA]*)/gi;
    let current;
    while ((current = commandExp.exec(pathString)) !== null) {
      const argParts = current[2].trim().split(/[^0-9Ee.-]/).filter((part) => part.length > 0).reduce((accumualtor, current2) => {
        current2 = current2.replace(/([^eE])[-]/g, "$1 -");
        const parts = current2.split(" -");
        if (parts[0] !== "") {
          accumualtor.push(parts[0]);
        }
        accumualtor.push(...parts.slice(1).map((part) => `-${part}`));
        return accumualtor;
      }, []);
      let numericArgs = argParts.map((arg) => parseFloat(arg));
      let commandChar = current[1].toLowerCase();
      let uppercaseCommand = current[1] !== commandChar;
      if (commandChar === "v" || commandChar === "h") {
        numericArgs = numericArgs.reduce((accumulator, current2) => {
          if (commandChar === "v") {
            return accumulator.concat(uppercaseCommand ? lastPos.x : 0, current2);
          } else {
            return accumulator.concat(current2, uppercaseCommand ? lastPos.y : 0);
          }
        }, []);
        commandChar = "l";
      } else if (commandChar === "z") {
        if (firstPos) {
          numericArgs = [firstPos.x, firstPos.y];
          firstPos = lastPos;
        } else {
          continue;
        }
        uppercaseCommand = true;
        commandChar = "l";
      }
      const commandArgCount = commandArgCounts[commandChar] ?? 0;
      const allArgs = numericArgs.reduce((accumulator, current2, index, parts) => {
        if (index % 2 !== 0) {
          const currentAsFloat = current2;
          const prevAsFloat = parts[index - 1];
          return accumulator.concat(Vec2.of(prevAsFloat, currentAsFloat));
        } else {
          return accumulator;
        }
      }, []).map((coordinate, index) => {
        let newPos;
        if (uppercaseCommand) {
          newPos = coordinate;
        } else {
          newPos = lastPos.plus(coordinate);
        }
        if ((index + 1) % commandArgCount === 0) {
          lastPos = newPos;
        }
        return newPos;
      });
      if (allArgs.length % commandArgCount !== 0) {
        throw new Error([
          `Incorrect number of arguments: got ${JSON.stringify(allArgs)} with a length of ${allArgs.length} ≠ ${commandArgCount}k, k ∈ ℤ.`,
          `The number of arguments to ${commandChar} must be a multiple of ${commandArgCount}!`,
          `Command: ${current[0]}`
        ].join("\n"));
      }
      for (let argPos = 0; argPos < allArgs.length; argPos += commandArgCount) {
        const args = allArgs.slice(argPos, argPos + commandArgCount);
        switch (commandChar.toLowerCase()) {
          case "m":
            if (argPos === 0) {
              moveTo(args[0]);
            } else {
              lineTo(args[0]);
            }
            break;
          case "l":
            lineTo(args[0]);
            break;
          case "c":
            cubicBezierTo(args[0], args[1], args[2]);
            break;
          case "q":
            quadraticBeierTo(args[0], args[1]);
            break;
          default:
            throw new Error(`Unknown path command ${commandChar}`);
        }
        isFirstCommand = false;
      }
      if (allArgs.length > 0) {
        firstPos ?? (firstPos = allArgs[0]);
        startPos ?? (startPos = firstPos);
        lastPos = allArgs[allArgs.length - 1];
      }
    }
    const result = new _Path(startPos ?? Vec2.zero, commands);
    result.cachedStringVersion = pathString;
    return result;
  }
  static fromConvexHullOf(points) {
    if (points.length === 0) {
      return _Path.empty;
    }
    const hull = convexHull2Of_default(points);
    const commands = hull.slice(1).map((p) => ({
      kind: PathCommandType.LineTo,
      point: p
    }));
    commands.push({
      kind: PathCommandType.LineTo,
      point: hull[0]
    });
    return new _Path(hull[0], commands);
  }
};
Path.empty = new Path(Vec2.zero, []);

// node_modules/@js-draw/math/dist/mjs/Color4.mjs
var Color4 = class _Color4 {
  constructor(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    this.hexString = null;
  }
  /**
   * Create a color from red, green, blue components. The color is fully opaque (`a = 1.0`).
   *
   * Each component should be in the range [0, 1].
   */
  static ofRGB(red, green, blue) {
    return _Color4.ofRGBA(red, green, blue, 1);
  }
  /**
   * Creates a color from red, green, blue, and transparency components. Each component should
   * be in the range $[0, 1]$.
   */
  static ofRGBA(red, green, blue, alpha) {
    red = Math.max(0, Math.min(red, 1));
    green = Math.max(0, Math.min(green, 1));
    blue = Math.max(0, Math.min(blue, 1));
    alpha = Math.max(0, Math.min(alpha, 1));
    return new _Color4(red, green, blue, alpha);
  }
  /**
   * Creates a color from an RGB (or RGBA) array.
   *
   * This is similar to {@link ofRGB} and {@link ofRGBA}, but, by default, takes values
   * that range from 0 to 255.
   *
   * If the array values instead range from 0-1, pass `maxValue` as `1`.
   */
  static fromRGBArray(array, maxValue = 255) {
    const red = array[0];
    const green = array[1] ?? red;
    const blue = array[2] ?? red;
    let alpha = 255;
    if (3 < array.length) {
      alpha = array[3];
    }
    return _Color4.ofRGBA(red / maxValue, green / maxValue, blue / maxValue, alpha / maxValue);
  }
  /**
   * Creates a `Color4` from a three or four-component hexadecimal
   * [color string](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet).
   *
   * Example:
   * ```ts,runnable,console
   * import { Color4 } from '@js-draw/math';
   * console.log(Color4.fromHex('#ff0'));
   * ```
   */
  static fromHex(hexString) {
    hexString = (hexString.match(/^[#]?(.*)$/) ?? [])[1];
    hexString = hexString.toUpperCase();
    if (!hexString.match(/^[0-9A-F]+$/)) {
      throw new Error(`${hexString} is not in a valid format.`);
    }
    if (hexString.length === 3 || hexString.length === 4) {
      const components2 = hexString.split("");
      hexString = components2.map((component) => `${component}0`).join("");
    }
    if (hexString.length === 6) {
      hexString += "FF";
    }
    const components = [];
    for (let i = 2; i <= hexString.length; i += 2) {
      const chunk = hexString.substring(i - 2, i);
      components.push(parseInt(chunk, 16) / 255);
    }
    if (components.length !== 4) {
      throw new Error(`Unable to parse ${hexString}: Wrong number of components.`);
    }
    return _Color4.ofRGBA(components[0], components[1], components[2], components[3]);
  }
  /** Like {@link fromHex}, but can handle additional colors if an `HTMLCanvasElement` is available. */
  static fromString(text) {
    if (text.startsWith("#")) {
      return _Color4.fromHex(text);
    }
    if (text === "none" || text === "transparent") {
      return _Color4.transparent;
    }
    if (text === "") {
      return _Color4.black;
    }
    const rgbRegex = /^rgba?\(([,0-9.]+)\)$/i;
    const rgbMatch = text.replace(/\s*/g, "").match(rgbRegex);
    if (rgbMatch) {
      const componentsListStr = rgbMatch[1];
      const componentsList = JSON.parse(`[ ${componentsListStr} ]`);
      if (componentsList.length === 3) {
        return _Color4.ofRGB(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255);
      } else if (componentsList.length === 4) {
        return _Color4.ofRGBA(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255, componentsList[3]);
      } else {
        throw new Error(`RGB string, ${text}, has wrong number of components: ${componentsList.length}`);
      }
    }
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return _Color4.black;
    }
    ctx.fillStyle = text;
    ctx.fillRect(0, 0, 1, 1);
    const data = ctx.getImageData(0, 0, 1, 1);
    const red = data.data[0] / 255;
    const green = data.data[1] / 255;
    const blue = data.data[2] / 255;
    const alpha = data.data[3] / 255;
    return _Color4.ofRGBA(red, green, blue, alpha);
  }
  /** @returns true if `this` and `other` are approximately equal. */
  eq(other) {
    if (other == null) {
      return false;
    }
    if (this.a === 0 && other.a === 0) {
      return true;
    }
    return this.toHexString() === other.toHexString();
  }
  /**
   * If `fractionTo` is not in the range $[0, 1]$, it will be clamped to the nearest number
   * in that range. For example, `a.mix(b, -1)` is equivalent to `a.mix(b, 0)`.
   *
   * @returns a color `fractionTo` of the way from this color to `other`.
   *
   * @example
   * ```ts
   * Color4.ofRGB(1, 0, 0).mix(Color4.ofRGB(0, 1, 0), 0.1) // -> Color4(0.9, 0.1, 0)
   * ```
   */
  mix(other, fractionTo) {
    fractionTo = Math.min(Math.max(fractionTo, 0), 1);
    const fractionOfThis = 1 - fractionTo;
    return new _Color4(this.r * fractionOfThis + other.r * fractionTo, this.g * fractionOfThis + other.g * fractionTo, this.b * fractionOfThis + other.b * fractionTo, this.a * fractionOfThis + other.a * fractionTo);
  }
  /** Returns a new color with a different opacity. */
  withAlpha(a) {
    return new _Color4(this.r, this.g, this.b, a);
  }
  /**
   * Ignoring this color's alpha component, returns a vector with components,
   * $$
   * \begin{pmatrix} \colorbox{#F44}{\tt r} \\ \colorbox{#4F4}{\tt g} \\ \colorbox{#44F}{\tt b} \end{pmatrix}
   * $$
   */
  get rgb() {
    return Vec3_default.of(this.r, this.g, this.b);
  }
  /**
   * Returns the [relative luminance](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)
   * of this color in the sRGB color space.
   *
   * Ignores the alpha component.
   */
  relativeLuminance() {
    const components = [this.r, this.g, this.b].map((component) => {
      if (component < 0.03928) {
        return component / 12.92;
      } else {
        return Math.pow((component + 0.055) / 1.055, 2.4);
      }
    });
    return 0.2126 * components[0] + 0.7152 * components[1] + 0.0722 * components[2];
  }
  /**
   * Returns the [contrast ratio](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef)
   * between `colorA` and `colorB`.
   */
  static contrastRatio(colorA, colorB) {
    const L1 = colorA.relativeLuminance();
    const L2 = colorB.relativeLuminance();
    return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
  }
  /**
   * @returns the component-wise average of `colors`, or `Color4.transparent` if `colors` is empty.
   */
  static average(colors) {
    let averageA = 0;
    let averageR = 0;
    let averageG = 0;
    let averageB = 0;
    for (const color of colors) {
      averageA += color.a;
      averageR += color.r;
      averageG += color.g;
      averageB += color.b;
    }
    if (colors.length > 0) {
      averageA /= colors.length;
      averageR /= colors.length;
      averageG /= colors.length;
      averageB /= colors.length;
    }
    return new _Color4(averageR, averageG, averageB, averageA);
  }
  /**
   * Converts to (hue, saturation, value).
   * See also https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach
   *
   * The resultant hue is represented in radians and is thus in $[0, 2\pi]$.
   */
  asHSV() {
    const minComponent = Math.min(this.r, this.g, this.b);
    const maxComponent = Math.max(this.r, this.g, this.b);
    const chroma = maxComponent - minComponent;
    let hue;
    if (chroma === 0) {
      hue = 0;
    } else if (this.r >= this.g && this.r >= this.b) {
      hue = (this.g - this.b) / chroma % 6;
    } else if (this.g >= this.r && this.g >= this.b) {
      hue = (this.b - this.r) / chroma + 2;
    } else {
      hue = (this.r - this.g) / chroma + 4;
    }
    hue *= 60;
    hue *= Math.PI / 180;
    if (hue < 0) {
      hue += Math.PI * 2;
    }
    const value = maxComponent;
    const saturation = value > 0 ? chroma / value : 0;
    return Vec3_default.of(hue, saturation, value);
  }
  /**
   * Creates a new `Color4` from a representation [in $HSV$](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
   *
   * [Algorithm](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).
   *
   * Note that hue must be given **in radians**. While non-standard, this is consistent with
   * {@link asHSV}.
   *
   * `hue` and `value` should range from 0 to 1.
   *
   * @param hue $H \in [0, 2\pi]$
   * @param saturation $S_V \in [0, 1]$
   * @param value $V \in [0, 1]$
   */
  static fromHSV(hue, saturation, value) {
    if (hue < 0) {
      hue += Math.PI * 2;
    }
    hue %= Math.PI * 2;
    value = Math.max(0, Math.min(1, value));
    saturation = Math.max(0, Math.min(1, saturation));
    const chroma = value * saturation;
    const huePrime = hue / (Math.PI / 3);
    const secondLargestComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
    let rgb;
    if (huePrime < 1) {
      rgb = [chroma, secondLargestComponent, 0];
    } else if (huePrime < 2) {
      rgb = [secondLargestComponent, chroma, 0];
    } else if (huePrime < 3) {
      rgb = [0, chroma, secondLargestComponent];
    } else if (huePrime < 4) {
      rgb = [0, secondLargestComponent, chroma];
    } else if (huePrime < 5) {
      rgb = [secondLargestComponent, 0, chroma];
    } else {
      rgb = [chroma, 0, secondLargestComponent];
    }
    const adjustment = value - chroma;
    return _Color4.ofRGB(rgb[0] + adjustment, rgb[1] + adjustment, rgb[2] + adjustment);
  }
  /**
   * Equivalent to `ofRGB(rgb.x, rgb.y, rgb.z)`.
   *
   * All components should be in the range `[0, 1]` (0 to 1 inclusive).
   */
  static fromRGBVector(rgb, alpha) {
    return _Color4.ofRGBA(rgb.x, rgb.y, rgb.z, alpha ?? 1);
  }
  /**
   * @returns a hexadecimal color string representation of `this`, in the form `#rrggbbaa`.
   *
   * @example
   * ```
   * Color4.red.toHexString(); // -> #ff0000ff
   * ```
   */
  toHexString() {
    if (this.hexString) {
      return this.hexString;
    }
    const componentToHex = (component) => {
      const res = Math.round(255 * component).toString(16);
      if (res.length === 1) {
        return `0${res}`;
      }
      return res;
    };
    const alpha = componentToHex(this.a);
    const red = componentToHex(this.r);
    const green = componentToHex(this.g);
    const blue = componentToHex(this.b);
    if (alpha === "ff") {
      return `#${red}${green}${blue}`;
    }
    this.hexString = `#${red}${green}${blue}${alpha}`;
    return this.hexString;
  }
  toString() {
    return this.toHexString();
  }
};
Color4.transparent = Color4.ofRGBA(0, 0, 0, 0);
Color4.red = Color4.ofRGB(1, 0, 0);
Color4.orange = Color4.ofRGB(1, 0.65, 0);
Color4.green = Color4.ofRGB(0, 1, 0);
Color4.blue = Color4.ofRGB(0, 0, 1);
Color4.purple = Color4.ofRGB(0.5, 0.2, 0.5);
Color4.yellow = Color4.ofRGB(1, 1, 0.1);
Color4.clay = Color4.ofRGB(0.8, 0.4, 0.2);
Color4.black = Color4.ofRGB(0, 0, 0);
Color4.gray = Color4.ofRGB(0.5, 0.5, 0.5);
Color4.white = Color4.ofRGB(1, 1, 1);

// node_modules/js-draw/dist/mjs/util/describeTransformation.mjs
var describeTransformation = (origin, transform, invertDirections, localizationTable) => {
  const linearTransformedVec = transform.transformVec3(Vec2.unitX);
  const affineTransformedVec = transform.transformVec2(origin);
  const scale = linearTransformedVec.magnitude();
  const clockwiseRotation = -(180 / Math.PI) * linearTransformedVec.angle();
  const translation = affineTransformedVec.minus(origin);
  const result = [];
  if (scale > 1.2) {
    result.push(localizationTable.zoomedIn);
  } else if (scale < 0.8) {
    result.push(localizationTable.zoomedOut);
  }
  if (Math.floor(Math.abs(clockwiseRotation)) > 0) {
    const roundedRotation = Math.round(invertDirections ? -clockwiseRotation : clockwiseRotation);
    result.push(localizationTable.rotatedBy(roundedRotation));
  }
  const minTranslation = 1e-4;
  if (translation.x > minTranslation) {
    result.push(invertDirections ? localizationTable.movedLeft : localizationTable.movedRight);
  } else if (translation.x < -minTranslation) {
    result.push(invertDirections ? localizationTable.movedRight : localizationTable.movedLeft);
  }
  if (translation.y < -minTranslation) {
    result.push(invertDirections ? localizationTable.movedDown : localizationTable.movedUp);
  } else if (translation.y > minTranslation) {
    result.push(invertDirections ? localizationTable.movedUp : localizationTable.movedDown);
  }
  return result.join("; ");
};
var describeTransformation_default = describeTransformation;

// node_modules/js-draw/dist/mjs/Viewport.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _inverseTransform;
var _a;
var ViewportTransform = class extends Command_default {
};
var Viewport = class _Viewport {
  // @internal
  constructor(onTransformChangeCallback) {
    this.onTransformChangeCallback = onTransformChangeCallback;
    this.resetTransform(Mat33.identity);
    this.screenRect = Rect2.empty;
  }
  /**
   * @returns a temporary copy of `this` that does not notify when modified. This is
   * useful when rendering with a temporarily different viewport.
   */
  getTemporaryClone() {
    const result = new _Viewport(() => {
    });
    result.transform = this.transform;
    result.inverseTransform = this.inverseTransform;
    result.screenRect = this.screenRect;
    return result;
  }
  /** Resizes the screen rect to the given size. @internal */
  updateScreenSize(screenSize) {
    this.screenRect = this.screenRect.resizedTo(screenSize);
  }
  /** Get the screen's visible region transformed into canvas space. */
  get visibleRect() {
    return this.screenRect.transformedBoundingBox(this.inverseTransform);
  }
  /** @returns the given point, but in canvas coordinates */
  screenToCanvas(screenPoint) {
    return this.inverseTransform.transformVec2(screenPoint);
  }
  /** @returns the given point transformed into screen coordinates. */
  canvasToScreen(canvasPoint) {
    return this.transform.transformVec2(canvasPoint);
  }
  /**
   * @returns a command that transforms the canvas by `transform`.
   *
   * For example, `Viewport.transformBy(moveRight).apply(editor)` would move the canvas to the right
   * (and thus the viewport to the left):
   * ```ts,runnable
   * import { Editor, Viewport, Mat33, Vec2 } from 'js-draw';
   * const editor = new Editor(document.body);
   * const moveRight = Mat33.translation(Vec2.unitX.times(500));
   * // Move the **canvas** right by 500 units:
   * Viewport.transformBy(moveRight).apply(editor);
   * ```
   */
  static transformBy(transform) {
    return new _Viewport.ViewportTransform(transform);
  }
  /**
   * Updates the transformation directly. Using `transformBy` is preferred.
   * @param newTransform - should map from canvas coordinates to screen coordinates.
   */
  resetTransform(newTransform = Mat33.identity) {
    var _a6;
    const oldTransform = this.transform;
    this.transform = newTransform;
    this.inverseTransform = newTransform.inverse();
    (_a6 = this.onTransformChangeCallback) == null ? void 0 : _a6.call(this, oldTransform, newTransform);
  }
  get screenToCanvasTransform() {
    return this.inverseTransform;
  }
  get canvasToScreenTransform() {
    return this.transform;
  }
  /** @returns the size of the visible region in pixels (screen units). */
  getScreenRectSize() {
    return this.screenRect.size;
  }
  /** Alias for `getScreenRectSize`. @deprecated */
  getResolution() {
    return this.getScreenRectSize();
  }
  /** @returns the amount a vector on the canvas is scaled to become a vector on the screen. */
  getScaleFactor() {
    return this.transform.transformVec3(Vec3.unitX).magnitude();
  }
  /**
   * @returns `getScaleFactor()` rounded to the nearest power of 10.
   * For example, if `getScaleFactor()` returns 101, `getScaleFactorToNearestPowerOfTen()`
   * should return `100` because `100` is the nearest power of 10 to 101.
   */
  getScaleFactorToNearestPowerOfTen() {
    return this.getScaleFactorToNearestPowerOf(10);
  }
  getScaleFactorToNearestPowerOf(powerOf) {
    const scaleFactor = this.getScaleFactor();
    return Math.pow(powerOf, Math.round(Math.log(scaleFactor) / Math.log(powerOf)));
  }
  /** Returns the size of a grid cell (in canvas units) as used by {@link snapToGrid}. */
  static getGridSize(scaleFactor) {
    return 50 / scaleFactor;
  }
  /**
   * Snaps `canvasPos` to the nearest grid cell corner.
   *
   * @see {@link getGridSize}.
   */
  snapToGrid(canvasPos) {
    const scaleFactor = this.getScaleFactorToNearestPowerOf(2);
    const snapCoordinate = (coordinate) => {
      const roundFactor = 1 / _Viewport.getGridSize(scaleFactor);
      const snapped = Math.round(coordinate * roundFactor) / roundFactor;
      return snapped;
    };
    const snappedCanvasPos = Vec2.of(snapCoordinate(canvasPos.x), snapCoordinate(canvasPos.y));
    return snappedCanvasPos;
  }
  /** Returns the size of one screen pixel in canvas units. */
  getSizeOfPixelOnCanvas() {
    return 1 / this.getScaleFactor();
  }
  /**
   * @returns the angle of the canvas in radians.
   * This is the angle by which the canvas is rotated relative to the screen.
   *
   * Returns an angle in the range $[-\pi, \pi]$ (the same range as {@link Vec3.angle}).
   */
  getRotationAngle() {
    return this.transform.transformVec3(Vec3.unitX).angle();
  }
  // The separate function type definition seems necessary here.
  // See https://stackoverflow.com/a/58163623/17055750.
  static roundPoint(point, tolerance) {
    const scaleFactor = 10 ** Math.floor(Math.log10(tolerance));
    const roundComponent = (component) => {
      return Math.round(component / scaleFactor) * scaleFactor;
    };
    if (typeof point === "number") {
      return roundComponent(point);
    }
    return point.map(roundComponent);
  }
  /** Round a point with a tolerance of ±1 screen unit. */
  roundPoint(point) {
    return _Viewport.roundPoint(point, 1 / this.getScaleFactor());
  }
  // `roundAmount`: An integer >= 0, larger numbers cause less rounding. Smaller numbers cause more
  // (as such `roundAmount = 0` does the most rounding).
  static roundScaleRatio(scaleRatio, roundAmount = 1) {
    if (Math.abs(scaleRatio) <= 1e-12) {
      return 0;
    }
    const decimalComponent = 10 ** Math.floor(Math.log10(Math.abs(scaleRatio)));
    const roundAmountFactor = 2 ** roundAmount;
    scaleRatio = Math.round(scaleRatio / decimalComponent * roundAmountFactor) / roundAmountFactor * decimalComponent;
    return scaleRatio;
  }
  // Computes and returns an affine transformation that makes `toMakeVisible` visible and roughly centered on the screen.
  computeZoomToTransform(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {
    let transform = Mat33.identity;
    if (toMakeVisible.w === 0 || toMakeVisible.h === 0) {
      let newSize = Math.max(toMakeVisible.w, toMakeVisible.h);
      if (newSize === 0) {
        newSize = 50;
        allowZoomIn = false;
        allowZoomOut = false;
      }
      toMakeVisible = new Rect2(toMakeVisible.x, toMakeVisible.y, newSize, newSize);
    }
    if (isNaN(toMakeVisible.size.magnitude())) {
      throw new Error(`${toMakeVisible.toString()} rectangle has NaN size! Cannot zoom to!`);
    }
    const recomputeTargetRect = () => {
      const visibleRect = this.visibleRect.transformedBoundingBox(transform.inverse());
      return visibleRect.transformedBoundingBox(Mat33.scaling2D(4 / 5, visibleRect.center));
    };
    let targetRect = recomputeTargetRect();
    const largerThanTarget = targetRect.w < toMakeVisible.w || targetRect.h < toMakeVisible.h;
    const muchSmallerThanTarget = toMakeVisible.maxDimension / targetRect.maxDimension < 1 / 3;
    if (largerThanTarget && allowZoomOut || muchSmallerThanTarget && allowZoomIn) {
      const multiplier = Math.max(toMakeVisible.w / targetRect.w, toMakeVisible.h / targetRect.h);
      const visibleRectTransform = Mat33.scaling2D(multiplier, targetRect.topLeft);
      const viewportContentTransform = visibleRectTransform.inverse();
      transform = transform.rightMul(viewportContentTransform);
    }
    targetRect = recomputeTargetRect();
    if (!targetRect.containsRect(toMakeVisible)) {
      const translation = toMakeVisible.center.minus(targetRect.center);
      const visibleRectTransform = Mat33.translation(translation);
      const viewportContentTransform = visibleRectTransform.inverse();
      transform = transform.rightMul(viewportContentTransform);
    }
    if (!transform.invertable()) {
      console.warn("Unable to zoom to ", toMakeVisible, "! Computed transform", transform, "is singular.");
      transform = Mat33.identity;
    }
    return transform;
  }
  // Returns a Command that transforms the view such that `toMakeVisible` is visible, and perhaps
  // centered in the viewport.
  //
  // If the content is already roughly centered in the screen and at a reasonable zoom level,
  // the resultant command does nothing.
  //
  // @see {@link computeZoomToTransform}
  zoomTo(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {
    const transform = this.computeZoomToTransform(toMakeVisible, allowZoomIn, allowZoomOut);
    return new _Viewport.ViewportTransform(transform);
  }
};
Viewport.ViewportTransform = (_a = class extends ViewportTransform {
  constructor(transform) {
    super();
    this.transform = transform;
    _inverseTransform.set(this, void 0);
    __classPrivateFieldSet2(this, _inverseTransform, transform.inverse(), "f");
  }
  apply(editor) {
    const viewport = editor.viewport;
    viewport.resetTransform(viewport.transform.rightMul(this.transform));
    editor.queueRerender();
  }
  unapply(editor) {
    const viewport = editor.viewport;
    viewport.resetTransform(viewport.transform.rightMul(__classPrivateFieldGet2(this, _inverseTransform, "f")));
    editor.queueRerender();
  }
  description(editor, localizationTable) {
    return describeTransformation_default(editor.viewport.visibleRect.center, this.transform, true, localizationTable);
  }
}, _inverseTransform = /* @__PURE__ */ new WeakMap(), _a);
var Viewport_default = Viewport;

// node_modules/js-draw/dist/mjs/commands/SerializableCommand.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SerializableCommand_commandTypeId;
var SerializableCommand = class _SerializableCommand extends Command_default {
  /** @param commandTypeId - A unique identifier for this command. */
  constructor(commandTypeId) {
    super();
    _SerializableCommand_commandTypeId.set(this, void 0);
    if (!(commandTypeId in _SerializableCommand.deserializationCallbacks)) {
      throw new Error(`Command ${commandTypeId} must have a registered deserialization callback. To do this, call SerializableCommand.register.`);
    }
    __classPrivateFieldSet3(this, _SerializableCommand_commandTypeId, commandTypeId, "f");
  }
  // Convert this command to an object that can be passed to `JSON.stringify`.
  //
  // Do not rely on the stability of the optupt of this function — it can change
  // form without a major version increase.
  serialize() {
    return {
      data: this.serializeToJSON(),
      commandType: __classPrivateFieldGet3(this, _SerializableCommand_commandTypeId, "f")
    };
  }
  // Convert a `string` containing JSON data (or the output of `JSON.parse`) into a
  // `Command`.
  //
  // Implementations should assume that `data` is untrusted.
  static deserialize(data, editor) {
    const json = typeof data === "string" ? JSON.parse(data) : data;
    const commandType = json.commandType;
    if (!(commandType in _SerializableCommand.deserializationCallbacks)) {
      throw new Error(`Unrecognised command type ${commandType}!`);
    }
    return _SerializableCommand.deserializationCallbacks[commandType](json.data, editor);
  }
  // Register a deserialization callback. This must be called at least once for every subclass of
  // `SerializableCommand`.
  static register(commandTypeId, deserialize) {
    _SerializableCommand.deserializationCallbacks[commandTypeId] = deserialize;
  }
};
_SerializableCommand_commandTypeId = /* @__PURE__ */ new WeakMap();
SerializableCommand.deserializationCallbacks = {};
var SerializableCommand_default = SerializableCommand;

// node_modules/js-draw/dist/mjs/commands/UnresolvedCommand.mjs
var UnresolvedSerializableCommand = class extends SerializableCommand_default {
  constructor(commandId, componentID, component) {
    super(commandId);
    this.component = component ?? null;
    this.componentID = componentID;
  }
  resolveComponent(image) {
    if (this.component) {
      return;
    }
    const component = image.lookupElement(this.componentID);
    if (!component) {
      throw new Error(`Unable to resolve component with ID ${this.componentID}`);
    }
    this.component = component;
  }
};

// node_modules/js-draw/dist/mjs/util/assertions.mjs
function assertUnreachable(key) {
  throw new Error(`Should be unreachable. Key: ${key}.`);
}
function assertIsNumber(value, allowNaN = false) {
  if (typeof value !== "number" || !allowNaN && isNaN(value)) {
    throw new Error("Given value is not a number");
  }
}
function assertIsString(value) {
  if (typeof value !== "string") {
    throw new Error("Given value is not a string");
  }
}
function assertIsArray(values) {
  if (!Array.isArray(values)) {
    throw new Error("Asserting isArray: Given entity is not an array");
  }
}
function assertIsNumberArray(values, allowNaN = false) {
  assertIsArray(values);
  assertIsNumber(values.length);
  for (const value of values) {
    assertIsNumber(value, allowNaN);
  }
}
function assertIsStringArray(values) {
  assertIsArray(values);
  assertIsNumber(values.length);
  for (const value of values) {
    assertIsString(value);
  }
}
function assertIsBoolean(value) {
  if (typeof value !== "boolean") {
    throw new Error("Given value is not a boolean");
  }
}
function assertTruthy(value) {
  if (!value) {
    throw new Error(`${JSON.stringify(value)} is not truthy`);
  }
}
function assertIsObject(value) {
  if (typeof value !== "object") {
    throw new Error(`AssertIsObject: Given entity is not an object (type = ${typeof value})`);
  }
}

// node_modules/js-draw/dist/mjs/components/AbstractComponent.mjs
var __setFunctionName = function(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var _a2;
var ComponentSizingMode;
(function(ComponentSizingMode2) {
  ComponentSizingMode2[ComponentSizingMode2["BoundingBox"] = 0] = "BoundingBox";
  ComponentSizingMode2[ComponentSizingMode2["FillScreen"] = 1] = "FillScreen";
  ComponentSizingMode2[ComponentSizingMode2["Anywhere"] = 2] = "Anywhere";
})(ComponentSizingMode || (ComponentSizingMode = {}));
var AbstractComponent = class _AbstractComponent {
  constructor(componentKind2, initialZIndex) {
    this.componentKind = componentKind2;
    this.loadSaveData = {};
    this.lastChangedTime = (/* @__PURE__ */ new Date()).getTime();
    if (initialZIndex !== void 0) {
      this.zIndex = initialZIndex;
    } else {
      this.zIndex = _AbstractComponent.zIndexCounter++;
    }
    this.id = `${(/* @__PURE__ */ new Date()).getTime()}-${Math.random()}`;
    if (_AbstractComponent.deserializationCallbacks[componentKind2] === void 0) {
      throw new Error(`Component ${componentKind2} has not been registered using AbstractComponent.registerComponent`);
    }
  }
  // Returns a unique ID for this element.
  // @see { @link EditorImage.lookupElement }
  getId() {
    return this.id;
  }
  // Store the deserialization callback (or lack of it) for [componentKind].
  // If components are registered multiple times (as may be done in automated tests),
  // the most recent deserialization callback is used.
  static registerComponent(componentKind2, deserialize) {
    this.deserializationCallbacks[componentKind2] = deserialize ?? null;
  }
  /**
   * Attach data that can be used while exporting the component (e.g. to SVG).
   *
   * This is intended for use by an {@link ImageLoader}.
   */
  attachLoadSaveData(key, data) {
    if (!this.loadSaveData[key]) {
      this.loadSaveData[key] = [];
    }
    this.loadSaveData[key].push(data);
  }
  /** See {@link attachLoadSaveData} */
  getLoadSaveData() {
    return this.loadSaveData;
  }
  getZIndex() {
    return this.zIndex;
  }
  /**
   * @returns the bounding box of this. This can be a slight overestimate if doing so
   * 			significantly improves performance.
   */
  getBBox() {
    return this.contentBBox;
  }
  /**
   * @returns the bounding box of this. Unlike `getBBox`, this should **not** be a rough estimate.
   */
  getExactBBox() {
    return this.getBBox();
  }
  /**
   * Returns information about how this component should be displayed
   * (e.g. fill the screen or get its size from {@link getBBox}).
   *
   * {@link EditorImage.queueRerenderOf} must be called to apply changes to
   * the output of this method if this component has already been added to an
   * {@link EditorImage}.
   */
  getSizingMode() {
    return ComponentSizingMode.BoundingBox;
  }
  /**
   * **Optimization**
   *
   * Should return `true` if this component covers the entire `visibleRect`
   * and would prevent anything below this component from being visible.
   *
   * Should return `false` otherwise.
   */
  occludesEverythingBelowWhenRenderedInRect(_visibleRect) {
    return false;
  }
  /** Called when this component is added to the given image. */
  onAddToImage(_image) {
  }
  onRemoveFromImage() {
  }
  /**
   * @returns true if this component intersects `rect` -- it is entirely contained
   *  within the rectangle or one of the rectangle's edges intersects this component.
   *
   * The default implementation assumes that `this.getExactBBox()` returns a tight bounding box
   * -- that any horiziontal/vertical line that intersects this' boounding box also
   * intersects a point in this component. If this is not the case, components must override
   * this function.
   */
  intersectsRect(rect) {
    if (rect.containsRect(this.getExactBBox())) {
      return true;
    }
    const testLines = rect.getEdges();
    return testLines.some((edge) => this.intersects(edge));
  }
  /**
   * Returns a selection of points within this object. Each contiguous section
   * of this object should have a point in the returned array.
   *
   * Subclasses should override this method if the center of the bounding box is
   * not contained within the object.
   */
  keyPoints() {
    return [this.getBBox().center];
  }
  // @returns true iff this component can be selected (e.g. by the selection tool.)
  isSelectable() {
    return true;
  }
  // @returns true iff this component should be added to the background, rather than the
  // foreground of the image.
  isBackground() {
    return false;
  }
  // @returns an approximation of the proportional time it takes to render this component.
  // This is intended to be a rough estimate, but, for example, a stroke with two points sould have
  // a renderingWeight approximately twice that of a stroke with one point.
  getProportionalRenderingTime() {
    return 1;
  }
  /**
   * Returns a command that, when applied, transforms this by [affineTransfm] and
   * updates the editor.
   *
   * The transformed component is also moved to the top (use
   * {@link AbstractComponent#setZIndexAndTransformBy} to avoid this behavior).
   */
  transformBy(affineTransfm) {
    return new _AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this);
  }
  // Returns a command that updates this component's z-index.
  setZIndex(newZIndex) {
    return new _AbstractComponent.TransformElementCommand(Mat33.identity, this.getId(), this, newZIndex);
  }
  /**
   * Combines {@link transformBy} and {@link setZIndex} into a single command.
   *
   * @param newZIndex - The z-index this component should have after applying this command.
   * @param originalZIndex - @internal The z-index the component should revert to after unapplying
   *                         this command.
   */
  setZIndexAndTransformBy(affineTransfm, newZIndex, originalZIndex) {
    return new _AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this, newZIndex, originalZIndex);
  }
  // Returns a copy of this component.
  clone() {
    const clone = this.createClone();
    for (const attachmentKey in this.loadSaveData) {
      for (const val of this.loadSaveData[attachmentKey]) {
        clone.attachLoadSaveData(attachmentKey, val);
      }
    }
    return clone;
  }
  /**
   * Creates a copy of this component with a particular `id`.
   * This is used internally by {@link Duplicate} when deserializing.
   *
   * @internal -- users of the library shouldn't need this.
   */
  cloneWithId(cloneId) {
    const clone = this.clone();
    clone.id = cloneId;
    return clone;
  }
  // Convert the component to an object that can be passed to
  // `JSON.stringify`.
  //
  // Do not rely on the output of this function to take a particular form —
  // this function's output can change form without a major version increase.
  serialize() {
    const data = this.serializeToJSON();
    if (data === null) {
      throw new Error(`${this} cannot be serialized.`);
    }
    return {
      name: this.componentKind,
      zIndex: this.zIndex,
      id: this.id,
      loadSaveData: this.loadSaveData,
      data
    };
  }
  // Returns true if `data` is not deserializable. May return false even if [data]
  // is not deserializable.
  static isNotDeserializable(json) {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    if (typeof json !== "object") {
      return true;
    }
    if (!this.deserializationCallbacks[json == null ? void 0 : json.name]) {
      return true;
    }
    if (!json.data) {
      return true;
    }
    return false;
  }
  // Convert a string or an object produced by `JSON.parse` into an `AbstractComponent`.
  static deserialize(json) {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    if (_AbstractComponent.isNotDeserializable(json)) {
      throw new Error(`Element with data ${json} cannot be deserialized.`);
    }
    assertIsString(json.id);
    const instance = this.deserializationCallbacks[json.name](json.data);
    instance.id = json.id;
    if (isFinite(json.zIndex)) {
      instance.zIndex = json.zIndex;
      _AbstractComponent.zIndexCounter = Math.max(_AbstractComponent.zIndexCounter, instance.zIndex + 1);
    }
    return instance;
  }
};
AbstractComponent.zIndexCounter = 0;
AbstractComponent.deserializationCallbacks = {};
AbstractComponent.transformElementCommandId = "transform-element";
AbstractComponent.TransformElementCommand = (_a2 = class extends UnresolvedSerializableCommand {
  // Construct a new TransformElementCommand. `component`, while optional, should
  // be provided if available. If not provided, it will be fetched from the editor's
  // document when the command is applied.
  constructor(affineTransfm, componentID, component, targetZIndex, origZIndex) {
    super(AbstractComponent.transformElementCommandId, componentID, component);
    this.affineTransfm = affineTransfm;
    this.origZIndex = origZIndex;
    this.targetZIndex = targetZIndex ?? AbstractComponent.zIndexCounter++;
    if (this.targetZIndex >= AbstractComponent.zIndexCounter) {
      AbstractComponent.zIndexCounter = this.targetZIndex + 1;
    }
    if (component && origZIndex === void 0) {
      this.origZIndex = component.getZIndex();
    }
  }
  resolveComponent(image) {
    if (this.component) {
      return;
    }
    super.resolveComponent(image);
    this.origZIndex ?? (this.origZIndex = this.component.getZIndex());
  }
  updateTransform(editor, newTransfm, targetZIndex) {
    if (!this.component) {
      throw new Error("this.component is undefined or null!");
    }
    const parent = editor.image.findParent(this.component);
    let hadParent = false;
    if (parent) {
      parent.remove();
      hadParent = true;
    }
    this.component.applyTransformation(newTransfm);
    this.component.zIndex = targetZIndex;
    this.component.lastChangedTime = (/* @__PURE__ */ new Date()).getTime();
    if (targetZIndex >= AbstractComponent.zIndexCounter) {
      AbstractComponent.zIndexCounter = targetZIndex + 1;
    }
    if (hadParent) {
      EditorImage_default.addComponent(this.component).apply(editor);
    }
  }
  apply(editor) {
    this.resolveComponent(editor.image);
    this.updateTransform(editor, this.affineTransfm, this.targetZIndex);
    editor.queueRerender();
  }
  unapply(editor) {
    this.resolveComponent(editor.image);
    this.updateTransform(editor, this.affineTransfm.inverse(), this.origZIndex);
    editor.queueRerender();
  }
  description(_editor, localizationTable) {
    return localizationTable.transformedElements(1, describeTransformation_default(Vec2.zero, this.affineTransfm, false, localizationTable));
  }
  serializeToJSON() {
    return {
      id: this.componentID,
      transfm: this.affineTransfm.toArray(),
      targetZIndex: this.targetZIndex,
      origZIndex: this.origZIndex
    };
  }
}, __setFunctionName(_a2, "TransformElementCommand"), (() => {
  SerializableCommand_default.register(AbstractComponent.transformElementCommandId, (json, editor) => {
    const elem = editor.image.lookupElement(json.id) ?? void 0;
    const transform = new Mat33(...json.transfm);
    const targetZIndex = json.targetZIndex;
    const origZIndex = json.origZIndex ?? void 0;
    return new AbstractComponent.TransformElementCommand(transform, json.id, elem, targetZIndex, origZIndex);
  });
})(), _a2);
var AbstractComponent_default = AbstractComponent;

// node_modules/js-draw/dist/mjs/EventDispatcher.mjs
var EventDispatcher = class {
  constructor() {
    this.listeners = {};
  }
  dispatch(eventName, event) {
    const listenerList = this.listeners[eventName];
    if (listenerList) {
      for (let i = 0; i < listenerList.length; i++) {
        listenerList[i](event);
      }
    }
  }
  on(eventName, callback) {
    if (!this.listeners[eventName])
      this.listeners[eventName] = [];
    this.listeners[eventName].push(callback);
    return {
      // Retuns false if the listener has already been removed, true otherwise.
      remove: () => {
        const originalListeners = this.listeners[eventName];
        this.off(eventName, callback);
        return originalListeners.length !== this.listeners[eventName].length;
      }
    };
  }
  /** Removes an event listener. This is equivalent to calling `.remove()` on the object returned by `.on`. */
  off(eventName, callback) {
    const listeners = this.listeners[eventName];
    if (!listeners)
      return;
    this.listeners[eventName] = listeners.filter((otherCallback) => otherCallback !== callback);
  }
};

// node_modules/js-draw/dist/mjs/image/EditorImage.mjs
var __setFunctionName2 = function(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var _a3;
var _b;
var _c;
var sortLeavesByZIndex = (leaves) => {
  leaves.sort((a, b) => a.getContent().getZIndex() - b.getContent().getZIndex());
};
var EditorImageEventType;
(function(EditorImageEventType2) {
  EditorImageEventType2[EditorImageEventType2["ExportViewportChanged"] = 0] = "ExportViewportChanged";
  EditorImageEventType2[EditorImageEventType2["AutoresizeModeChanged"] = 1] = "AutoresizeModeChanged";
  EditorImageEventType2[EditorImageEventType2["ComponentAdded"] = 2] = "ComponentAdded";
  EditorImageEventType2[EditorImageEventType2["ComponentRemoved"] = 3] = "ComponentRemoved";
})(EditorImageEventType || (EditorImageEventType = {}));
var debugMode = false;
var EditorImage = class {
  // @internal
  constructor() {
    this.componentCount = 0;
    this.settingExportRect = false;
    this.root = new RootImageNode();
    this.background = new RootImageNode();
    this.componentsById = /* @__PURE__ */ new Map();
    this.notifier = new EventDispatcher();
    this.importExportViewport = new Viewport_default(() => {
      this.onExportViewportChanged();
    });
    this.importExportViewport.updateScreenSize(Vec2.of(500, 500));
    this.shouldAutoresizeExportViewport = false;
  }
  // Returns all components that make up the background of this image. These
  // components are rendered below all other components.
  getBackgroundComponents() {
    const result = [];
    const leaves = this.background.getLeaves();
    sortLeavesByZIndex(leaves);
    for (const leaf of leaves) {
      const content = leaf.getContent();
      if (content) {
        result.push(content);
      }
    }
    return result;
  }
  // Returns the parent of the given element, if it exists.
  findParent(elem) {
    return this.background.getChildWithContent(elem) ?? this.root.getChildWithContent(elem);
  }
  // Forces a re-render of `elem` when the image is next re-rendered as a whole.
  // Does nothing if `elem` is not in this.
  queueRerenderOf(elem) {
    const parent = this.findParent(elem);
    if (parent) {
      parent.remove();
      this.addComponentDirectly(elem);
    }
  }
  /** @internal */
  renderWithCache(screenRenderer, cache, viewport) {
    this.background.render(screenRenderer, viewport.visibleRect);
    if (!debugMode) {
      cache.render(screenRenderer, this.root, viewport);
    } else {
      this.root.render(screenRenderer, viewport.visibleRect);
    }
  }
  /**
   * Renders this image to the given `renderer`.
   *
   * If `viewport` is non-null, only components that can be seen from that viewport
   * will be rendered. If `viewport` is `null`, **all** components are rendered.
   *
   * **Example**:
   * [[include:doc-pages/inline-examples/canvas-renderer.md]]
   */
  render(renderer, viewport) {
    this.background.render(renderer, viewport == null ? void 0 : viewport.visibleRect);
    this.root.render(renderer, viewport == null ? void 0 : viewport.visibleRect);
  }
  /**
   * Like {@link renderAll}, but can be stopped early and paused.
   *
   * **Note**: If the image is being edited during an async rendering, there is no
   * guarantee that all nodes will be rendered correctly (some may be missing).
   *
   * @internal
   */
  async renderAllAsync(renderer, preRenderComponent) {
    const stoppedEarly = !await this.background.renderAllAsync(renderer, preRenderComponent);
    if (!stoppedEarly) {
      return await this.root.renderAllAsync(renderer, preRenderComponent);
    }
    return false;
  }
  /**
   * Renders all nodes, even ones not within the viewport.
   *
   * This can be slow for large images
   * @internal
   */
  renderAll(renderer) {
    this.render(renderer, null);
  }
  /**
   * @returns all elements in the image, sorted by z-index (low to high).
   *
   * This can be slow for large images. If you only need all elemenst in part of the image,
   * consider using {@link getComponentsIntersecting} instead.
   *
   * **Note**: The result does not include background elements. See {@link getBackgroundComponents}.
   */
  getAllComponents() {
    const leaves = this.root.getLeaves();
    sortLeavesByZIndex(leaves);
    return leaves.map((leaf) => leaf.getContent());
  }
  /** @deprecated in favor of {@link getAllComponents} */
  getAllElements() {
    return this.getAllComponents();
  }
  /** Returns the number of elements added to this image. @internal */
  estimateNumElements() {
    return this.componentCount;
  }
  /** @deprecated @see getComponentsIntersecting */
  getElementsIntersectingRegion(region, includeBackground = false) {
    return this.getComponentsIntersecting(region, includeBackground);
  }
  /**
   * @returns a list of `AbstractComponent`s intersecting `region`, sorted by increasing z-index.
   *
   * Components in the background layer are only included if `includeBackground` is `true`.
   */
  getComponentsIntersecting(region, includeBackground = false) {
    let leaves = this.root.getLeavesIntersectingRegion(region);
    if (includeBackground) {
      leaves = leaves.concat(this.background.getLeavesIntersectingRegion(region));
    }
    sortLeavesByZIndex(leaves);
    return leaves.map((leaf) => leaf.getContent());
  }
  /** Called whenever (just after) an element is completely removed. @internal */
  onDestroyElement(elem) {
    this.componentCount--;
    const componentId2 = elem.getId();
    this.componentsById.delete(componentId2);
    this.notifier.dispatch(EditorImageEventType.ComponentRemoved, {
      kind: EditorImageEventType.ComponentRemoved,
      image: this,
      componentId: componentId2
    });
    this.autoresizeExportViewport();
  }
  /** Called just after an element is added. @internal */
  onElementAdded(elem) {
    this.componentCount++;
    const elementId = elem.getId();
    this.componentsById.set(elem.getId(), elem);
    this.notifier.dispatch(EditorImageEventType.ComponentAdded, {
      kind: EditorImageEventType.ComponentAdded,
      image: this,
      componentId: elementId
    });
    this.autoresizeExportViewport();
  }
  /**
   * @returns the AbstractComponent with `id`, if it exists.
   *
   * @see {@link AbstractComponent.getId}
   */
  lookupElement(id) {
    return this.componentsById.get(id) ?? null;
  }
  addComponentDirectly(elem) {
    elem.onAddToImage(this);
    const parentTree = elem.isBackground() ? this.background : this.root;
    const result = parentTree.addLeaf(elem);
    this.onElementAdded(elem);
    return result;
  }
  removeElementDirectly(element) {
    const container = this.findParent(element);
    container == null ? void 0 : container.remove();
    if (container) {
      this.onDestroyElement(element);
      return true;
    }
    return false;
  }
  /**
   * Returns a command that adds the given element to the `EditorImage`.
   * If `applyByFlattening` is true, the content of the wet ink renderer is
   * rendered onto the main rendering canvas instead of doing a full re-render.
   *
   * @see {@link Display.flatten}
   *
   * **Example**:
   *
   * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
   */
  static addComponent(elem, applyByFlattening = false) {
    return new _a3.AddComponentCommand(elem, applyByFlattening);
  }
  /** @see EditorImage.addComponent */
  addComponent(component, applyByFlattening) {
    return _a3.addComponent(component, applyByFlattening);
  }
  /** Alias for {@link addComponent}. @deprecated Prefer `.addComponent` */
  addElement(elem, applyByFlattening) {
    return this.addComponent(elem, applyByFlattening);
  }
  /** Alias for {@link addComponent}. @deprecated Prefer `.addComponent`. */
  static addElement(elem, applyByFlattening = false) {
    return this.addComponent(elem, applyByFlattening);
  }
  /**
   * @returns a `Viewport` for rendering the image when importing/exporting.
   */
  getImportExportViewport() {
    return this.importExportViewport;
  }
  /**
   * @see {@link setImportExportRect}
   */
  getImportExportRect() {
    return this.getImportExportViewport().visibleRect;
  }
  /**
   * Sets the import/export rectangle to the given `imageRect`. Disables
   * autoresize if it was previously enabled.
   *
   * **Note**: The import/export rectangle is the same as the size of any
   * {@link BackgroundComponent}s (and other components that auto-resize).
   */
  setImportExportRect(imageRect) {
    return _a3.SetImportExportRectCommand.of(this, imageRect, false);
  }
  /** @see {@link setAutoresizeEnabled} */
  getAutoresizeEnabled() {
    return this.shouldAutoresizeExportViewport;
  }
  /**
   * Returns a `Command` that sets whether the image should autoresize when
   * {@link AbstractComponent}s are added/removed.
   *
   * @example
   *
   * ```ts,runnable
   * import { Editor } from 'js-draw';
   *
   * const editor = new Editor(document.body);
   * const toolbar = editor.addToolbar();
   *
   * // Add a save button to demonstrate what the output looks like
   * // (it should change size to fit whatever was drawn)
   * toolbar.addSaveButton(() => {
   *   document.body.replaceChildren(editor.toSVG({ sanitize: true }));
   * });
   *
   * // Actually using setAutoresizeEnabled:
   * //
   * // To set autoresize without announcing for accessibility/making undoable
   * const addToHistory = false;
   * editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(true), addToHistory);
   *
   * // Add to undo history **and** announce for accessibility
   * //editor.dispatch(editor.image.setAutoresizeEnabled(true), true);
   * ```
   */
  setAutoresizeEnabled(autoresize) {
    if (autoresize === this.shouldAutoresizeExportViewport) {
      return Command_default.empty;
    }
    const newBBox = this.root.getBBox();
    return _a3.SetImportExportRectCommand.of(this, newBBox, autoresize);
  }
  setAutoresizeEnabledDirectly(shouldAutoresize) {
    if (shouldAutoresize !== this.shouldAutoresizeExportViewport) {
      this.shouldAutoresizeExportViewport = shouldAutoresize;
      this.notifier.dispatch(EditorImageEventType.AutoresizeModeChanged, {
        kind: EditorImageEventType.AutoresizeModeChanged,
        image: this
      });
    }
  }
  /** Updates the size/position of the viewport */
  autoresizeExportViewport() {
    if (this.shouldAutoresizeExportViewport) {
      this.setExportRectDirectly(this.root.getBBox());
    }
  }
  /**
   * Sets the import/export viewport directly, without returning a `Command`.
   * As such, this is not undoable.
   *
   * See setImportExportRect
   *
   * Returns true if changes to the viewport were made (and thus
   * ExportViewportChanged was fired.)
   */
  setExportRectDirectly(newRect) {
    const viewport = this.getImportExportViewport();
    const lastSize = viewport.getScreenRectSize();
    const lastTransform = viewport.canvasToScreenTransform;
    const newTransform = Mat33.translation(newRect.topLeft.times(-1));
    if (!lastSize.eq(newRect.size) || !lastTransform.eq(newTransform)) {
      this.settingExportRect = true;
      viewport.updateScreenSize(newRect.size);
      viewport.resetTransform(newTransform);
      this.settingExportRect = false;
      this.onExportViewportChanged();
      return true;
    }
    return false;
  }
  onExportViewportChanged() {
    if (!this.settingExportRect) {
      this.notifier.dispatch(EditorImageEventType.ExportViewportChanged, {
        kind: EditorImageEventType.ExportViewportChanged,
        image: this
      });
    }
  }
  /**
   * @internal
   *
   * Enables debug mode for **all** `EditorImage`s.
   *
   * **Only use for debugging**.
   *
   * @internal
   */
  static setDebugMode(newDebugMode) {
    debugMode = newDebugMode;
  }
};
_a3 = EditorImage;
EditorImage.AddComponentCommand = (_b = class extends SerializableCommand_default {
  // If [applyByFlattening], then the rendered content of this element
  // is present on the display's wet ink canvas. As such, no re-render is necessary
  // the first time this command is applied (the surfaces are joined instead).
  constructor(element, applyByFlattening = false) {
    super("add-element");
    this.element = element;
    this.applyByFlattening = applyByFlattening;
    this.serializedElem = null;
    this.serializedElem = null;
    if (isNaN(element.getBBox().area)) {
      throw new Error("Elements in the image cannot have NaN bounding boxes");
    }
  }
  apply(editor) {
    editor.image.addComponentDirectly(this.element);
    if (!this.applyByFlattening) {
      editor.queueRerender();
    } else {
      this.applyByFlattening = false;
      editor.display.flatten();
    }
  }
  unapply(editor) {
    editor.image.removeElementDirectly(this.element);
    editor.queueRerender();
  }
  description(_editor, localization4) {
    return localization4.addComponentAction(this.element.description(localization4));
  }
  serializeToJSON() {
    return {
      elemData: this.serializedElem ?? this.element.serialize()
    };
  }
}, __setFunctionName2(_b, "AddComponentCommand"), (() => {
  SerializableCommand_default.register("add-element", (json, editor) => {
    const id = json.elemData.id;
    const foundElem = editor.image.lookupElement(id);
    const elem = foundElem ?? AbstractComponent_default.deserialize(json.elemData);
    const result = new _a3.AddComponentCommand(elem);
    result.serializedElem = json.elemData;
    return result;
  });
})(), _b);
EditorImage.SetImportExportRectCommand = (_c = class extends SerializableCommand_default {
  constructor(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize) {
    super(_a3.SetImportExportRectCommand.commandId);
    this.originalSize = originalSize;
    this.originalTransform = originalTransform;
    this.originalAutoresize = originalAutoresize;
    this.newExportRect = newExportRect;
    this.newAutoresize = newAutoresize;
  }
  // Uses `image` to store the original size/transform
  static of(image, newExportRect, newAutoresize) {
    const importExportViewport = image.getImportExportViewport();
    const originalSize = importExportViewport.visibleRect.size;
    const originalTransform = importExportViewport.canvasToScreenTransform;
    const originalAutoresize = image.getAutoresizeEnabled();
    return new _a3.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize);
  }
  apply(editor) {
    editor.image.setAutoresizeEnabledDirectly(this.newAutoresize);
    editor.image.setExportRectDirectly(this.newExportRect);
    editor.queueRerender();
  }
  unapply(editor) {
    const viewport = editor.image.getImportExportViewport();
    editor.image.setAutoresizeEnabledDirectly(this.originalAutoresize);
    viewport.updateScreenSize(this.originalSize);
    viewport.resetTransform(this.originalTransform);
    editor.queueRerender();
  }
  description(_editor, localization4) {
    if (this.newAutoresize !== this.originalAutoresize) {
      if (this.newAutoresize) {
        return localization4.enabledAutoresizeOutputCommand;
      } else {
        return localization4.disabledAutoresizeOutputCommand;
      }
    }
    return localization4.resizeOutputCommand(this.newExportRect);
  }
  serializeToJSON() {
    return {
      originalSize: this.originalSize.xy,
      originalTransform: this.originalTransform.toArray(),
      newRegion: {
        x: this.newExportRect.x,
        y: this.newExportRect.y,
        w: this.newExportRect.w,
        h: this.newExportRect.h
      },
      autoresize: this.newAutoresize,
      originalAutoresize: this.originalAutoresize
    };
  }
}, __setFunctionName2(_c, "SetImportExportRectCommand"), _c.commandId = "set-import-export-rect", (() => {
  const commandId = _c.commandId;
  SerializableCommand_default.register(commandId, (json, _editor) => {
    assertIsNumber(json.originalSize.x);
    assertIsNumber(json.originalSize.y);
    assertIsNumberArray(json.originalTransform);
    assertIsNumberArray([
      json.newRegion.x,
      json.newRegion.y,
      json.newRegion.w,
      json.newRegion.h
    ]);
    assertIsBoolean(json.autoresize ?? false);
    assertIsBoolean(json.originalAutoresize ?? false);
    const originalSize = Vec2.ofXY(json.originalSize);
    const originalTransform = new Mat33(...json.originalTransform);
    const finalRect = new Rect2(json.newRegion.x, json.newRegion.y, json.newRegion.w, json.newRegion.h);
    const autoresize = json.autoresize ?? false;
    const originalAutoresize = json.originalAutoresize ?? false;
    return new _a3.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, finalRect, autoresize);
  });
})(), _c);
var EditorImage_default = EditorImage;
var computeFirstIndexToRender = (sortedLeaves, visibleRect) => {
  var _a6;
  let startIndex = 0;
  if (visibleRect) {
    for (let i = sortedLeaves.length - 1; i >= 1; i--) {
      if (
        // Check for occlusion
        sortedLeaves[i].getBBox().containsRect(visibleRect) && ((_a6 = sortedLeaves[i].getContent()) == null ? void 0 : _a6.occludesEverythingBelowWhenRenderedInRect(visibleRect))
      ) {
        startIndex = i;
        break;
      }
    }
  }
  return startIndex;
};
var ImageNode = class _ImageNode {
  constructor(parent = null) {
    this.parent = parent;
    this.targetChildCount = 30;
    this.children = [];
    this.bbox = Rect2.empty;
    this.content = null;
    this.id = _ImageNode.idCounter++;
  }
  getId() {
    return this.id;
  }
  onContentChange() {
    this.id = _ImageNode.idCounter++;
  }
  getContent() {
    return this.content;
  }
  getParent() {
    return this.parent;
  }
  // Override this to change how children are considered within a given region.
  getChildrenIntersectingRegion(region, isTooSmallFilter) {
    return this.children.filter((child) => {
      const bbox = child.getBBox();
      return !(isTooSmallFilter == null ? void 0 : isTooSmallFilter(bbox)) && bbox.intersects(region);
    });
  }
  getChildrenOrSelfIntersectingRegion(region, isTooSmall) {
    if (this.content && this.bbox.intersects(region) && !(isTooSmall == null ? void 0 : isTooSmall(this.bbox))) {
      return [this];
    }
    return this.getChildrenIntersectingRegion(region, isTooSmall);
  }
  /**
   * Returns a list of `ImageNode`s with content (and thus no children).
   * Override getChildrenIntersectingRegion to customize how this method
   * determines whether/which children are in `region`.
   *
   * @paran region - All resultant `ImageNode`s must intersect `region`.
   * @param isTooSmall - If `isTooSmall` returns true for an image node, that node
   *                     is excluded from the output.
   *
   */
  getLeavesIntersectingRegion(region, isTooSmall) {
    const result = [];
    const workList = [];
    workList.push(this);
    while (workList.length > 0) {
      const current = workList.pop();
      const processed = current.getChildrenOrSelfIntersectingRegion(region, isTooSmall);
      for (const item of processed) {
        if (item.content) {
          result.push(item);
        } else {
          workList.push(item);
        }
      }
    }
    return result;
  }
  // Returns the child of this with the target content or `null` if no
  // such child exists.
  //
  // Note: Relies on all children to have valid bounding boxes.
  getChildWithContent(target) {
    const candidates = this.getLeavesIntersectingRegion(target.getBBox());
    for (const candidate of candidates) {
      if (candidate.getContent() === target) {
        return candidate;
      }
    }
    return null;
  }
  // Returns a list of leaves with this as an ancestor.
  // Like getLeavesInRegion, but does not check whether ancestors are in a given rectangle
  getLeaves() {
    if (this.content) {
      return [this];
    }
    const result = [];
    for (const child of this.children) {
      result.push(...child.getLeaves());
    }
    return result;
  }
  addLeaf(leaf) {
    this.onContentChange();
    if (this.content === null && this.children.length === 0) {
      this.content = leaf;
      this.recomputeBBox(true);
      return this;
    }
    if (this.content !== null) {
      console.assert(this.children.length === 0);
      const contentNode = new _ImageNode(this);
      contentNode.content = this.content;
      this.content = null;
      this.children.push(contentNode);
      contentNode.recomputeBBox(false);
    }
    const leafBBox = leaf.getBBox();
    if (leafBBox.containsRect(this.getBBox())) {
      const nodeForNewLeaf = new _ImageNode(this);
      if (this.children.length < this.targetChildCount) {
        this.children.push(nodeForNewLeaf);
      } else {
        const nodeForChildren = new _ImageNode(this);
        nodeForChildren.children = this.children;
        this.children = [nodeForNewLeaf, nodeForChildren];
        nodeForChildren.updateParents();
        nodeForChildren.recomputeBBox(true);
      }
      return nodeForNewLeaf.addLeaf(leaf);
    }
    const containingNodes = this.children.filter((child) => child.getBBox().containsRect(leafBBox));
    if (containingNodes.length > 0 && this.children.length >= this.targetChildCount) {
      containingNodes.sort((a, b) => a.getBBox().area - b.getBBox().area);
      const result = containingNodes[0].addLeaf(leaf);
      result.rebalance();
      return result;
    }
    const newNode = _ImageNode.createLeafNode(this, leaf);
    this.children.push(newNode);
    newNode.recomputeBBox(true);
    if (this.children.length >= this.targetChildCount) {
      this.rebalance();
    }
    return newNode;
  }
  // Creates a new leaf node with the given content.
  // This only establishes the parent-child linking in one direction. Callers
  // must add the resultant node to the list of children manually.
  static createLeafNode(parent, content) {
    const newNode = new _ImageNode(parent);
    newNode.content = content;
    return newNode;
  }
  getBBox() {
    return this.bbox;
  }
  // Recomputes this' bounding box. If [bubbleUp], also recompute
  // this' ancestors bounding boxes. This also re-computes this' bounding box
  // in the z-direction (z-indicies).
  recomputeBBox(bubbleUp) {
    var _a6, _b2;
    const oldBBox = this.bbox;
    if (this.content !== null) {
      this.bbox = this.content.getBBox();
    } else {
      this.bbox = Rect2.union(...this.children.map((child) => child.getBBox()));
    }
    if (bubbleUp && !oldBBox.eq(this.bbox)) {
      if (this.bbox.containsRect(oldBBox)) {
        (_a6 = this.parent) == null ? void 0 : _a6.unionBBoxWith(this.bbox);
      } else {
        (_b2 = this.parent) == null ? void 0 : _b2.recomputeBBox(true);
      }
    }
    this.checkRep();
  }
  // Grows this' bounding box to also include `other`.
  // Always bubbles up.
  unionBBoxWith(other) {
    var _a6;
    this.bbox = this.bbox.union(other);
    (_a6 = this.parent) == null ? void 0 : _a6.unionBBoxWith(other);
  }
  updateParents(recursive = false) {
    for (const child of this.children) {
      child.parent = this;
      if (recursive) {
        child.updateParents(recursive);
      }
    }
  }
  rebalance() {
    if (this.parent && this.parent.children.length === 1) {
      console.assert(this.parent.content === null);
      console.assert(this.parent.children[0] === this);
      const oldParent = this.parent;
      if (oldParent.parent !== null) {
        const newParent = oldParent.parent;
        newParent.children = newParent.children.filter((c) => c !== oldParent);
        oldParent.parent = null;
        oldParent.children = [];
        this.parent = newParent;
        newParent.children.push(this);
        this.parent.recomputeBBox(false);
      } else if (this.content === null) {
        this.parent.children = this.children;
        this.parent.updateParents();
        this.parent = null;
      }
    }
    if (this.children.length > this.targetChildCount * 10) {
      const grid = this.getBBox().divideIntoGrid(4, 4);
      const indexToCount = [];
      while (indexToCount.length < grid.length) {
        indexToCount.push(0);
      }
      for (const child of this.children) {
        for (let i = 0; i < grid.length; i++) {
          if (grid[i].containsRect(child.getBBox())) {
            indexToCount[i]++;
          }
        }
      }
      let indexWithGreatest = 0;
      let greatestCount = indexToCount[0];
      for (let i = 1; i < indexToCount.length; i++) {
        if (indexToCount[i] > greatestCount) {
          indexWithGreatest = i;
          greatestCount = indexToCount[i];
        }
      }
      const targetGridSquare = grid[indexWithGreatest];
      if (greatestCount > 4) {
        const newChildren = [];
        const childNodeChildren = [];
        for (const child of this.children) {
          if (targetGridSquare.containsRect(child.getBBox())) {
            childNodeChildren.push(child);
          } else {
            newChildren.push(child);
          }
        }
        if (childNodeChildren.length < this.children.length) {
          this.children = newChildren;
          const child = new _ImageNode(this);
          this.children.push(child);
          child.children = childNodeChildren;
          child.updateParents(false);
          child.recomputeBBox(false);
          child.rebalance();
        }
      }
    }
    if (this.parent && this.children.length === 0 && this.content === null) {
      this.remove();
    }
  }
  // Removes the parent-to-child link.
  // Called internally by `.remove`
  removeChild(child) {
    this.checkRep();
    const oldChildCount = this.children.length;
    this.children = this.children.filter((node) => {
      return node !== child;
    });
    console.assert(this.children.length === oldChildCount - 1, `${oldChildCount - 1} ≠ ${this.children.length} after removing all nodes equal to ${child}. Nodes should only be removed once.`);
    this.children.forEach((child2) => {
      child2.rebalance();
    });
    this.recomputeBBox(true);
    this.rebalance();
    this.checkRep();
  }
  // Remove this node and all of its children
  remove() {
    var _a6;
    (_a6 = this.content) == null ? void 0 : _a6.onRemoveFromImage();
    if (!this.parent) {
      this.content = null;
      this.children = [];
      return;
    }
    this.parent.removeChild(this);
    this.parent = null;
    this.content = null;
    this.children = [];
    this.checkRep();
  }
  // Creates a (potentially incomplete) async rendering of this image.
  // Returns false if stopped early
  async renderAllAsync(renderer, preRenderComponent) {
    const leaves = this.getLeaves();
    sortLeavesByZIndex(leaves);
    const totalLeaves = leaves.length;
    for (let leafIndex = 0; leafIndex < totalLeaves; leafIndex++) {
      const leaf = leaves[leafIndex];
      const component = leaf.getContent();
      if (!component) {
        continue;
      }
      const shouldContinue = await preRenderComponent(component, leafIndex, totalLeaves);
      if (!shouldContinue) {
        return false;
      }
      component.render(renderer, void 0);
    }
    return true;
  }
  render(renderer, visibleRect) {
    let leaves;
    if (visibleRect) {
      leaves = this.getLeavesIntersectingRegion(visibleRect, (rect) => renderer.isTooSmallToRender(rect));
    } else {
      leaves = this.getLeaves();
    }
    sortLeavesByZIndex(leaves);
    const startIndex = computeFirstIndexToRender(leaves);
    for (let i = startIndex; i < leaves.length; i++) {
      const leaf = leaves[i];
      leaf.getContent().render(renderer, visibleRect);
    }
    if (debugMode && visibleRect) {
      if (startIndex !== 0) {
        console.log("EditorImage: skipped ", startIndex, "nodes due to occlusion");
      }
      this.renderDebugBoundingBoxes(renderer, visibleRect);
    }
  }
  // Debug only: Shows bounding boxes of this and all children.
  renderDebugBoundingBoxes(renderer, visibleRect, depth = 0) {
    const bbox = this.getBBox();
    const pixelSize = 1 / (renderer.getSizeOfCanvasPixelOnScreen() || 1);
    if (bbox.maxDimension < 3 * pixelSize || !bbox.intersects(visibleRect)) {
      return;
    }
    renderer.startObject(bbox);
    const isLeaf = !!this.content;
    const fill = isLeaf ? Color4.ofRGBA(1, 0, 1, 0.4) : Color4.ofRGBA(0, 1, Math.sin(depth), 0.6);
    const lineWidth = isLeaf ? 1 * pixelSize : 2 * pixelSize;
    renderer.drawRect(bbox.intersection(visibleRect), lineWidth, { fill });
    renderer.endObject();
    if (bbox.maxDimension > visibleRect.maxDimension / 3) {
      const textStyle = {
        fontFamily: "monospace",
        size: bbox.minDimension / 20,
        renderingStyle: { fill: Color4.red }
      };
      renderer.drawText(`Depth: ${depth}`, Mat33.translation(bbox.bottomLeft), textStyle);
    }
    for (const child of this.children) {
      child.renderDebugBoundingBoxes(renderer, visibleRect, depth + 1);
    }
  }
  checkRep(depth = 0) {
    if (debugMode) {
      if (this.parent && !this.parent.children.includes(this)) {
        throw new Error(`Parent does not have this node as a child. (depth: ${depth})`);
      }
      let expectedBBox = null;
      const seenChildren = /* @__PURE__ */ new Set();
      for (const child of this.children) {
        expectedBBox ?? (expectedBBox = child.getBBox());
        expectedBBox = expectedBBox.union(child.getBBox());
        if (child.parent !== this) {
          throw new Error(`Child with bbox ${child.getBBox()} and ${child.children.length} has wrong parent (was ${child.parent}).`);
        }
        if (seenChildren.has(child)) {
          throw new Error(`Child ${child} is present twice or more in its parent's child list`);
        }
        seenChildren.add(child);
      }
      const tolerance = this.bbox.minDimension / 100;
      if (expectedBBox && !this.bbox.eq(expectedBBox, tolerance)) {
        throw new Error(`Wrong bounding box ${expectedBBox} \\neq ${this.bbox} (depth: ${depth})`);
      }
    }
  }
};
ImageNode.idCounter = 0;
var RootImageNode = class extends ImageNode {
  constructor() {
    super(...arguments);
    this.fullscreenChildren = [];
    this.dataComponents = [];
  }
  getChildrenIntersectingRegion(region, _isTooSmall) {
    const result = super.getChildrenIntersectingRegion(region);
    for (const node of this.fullscreenChildren) {
      result.push(node);
    }
    return result;
  }
  getChildrenOrSelfIntersectingRegion(region, _isTooSmall) {
    const content = this.getContent();
    if (content && content.getSizingMode() === ComponentSizingMode.FillScreen) {
      return [this];
    }
    return super.getChildrenOrSelfIntersectingRegion(region, _isTooSmall);
  }
  getLeaves() {
    const leaves = super.getLeaves();
    return this.dataComponents.concat(this.fullscreenChildren, leaves);
  }
  removeChild(child) {
    let removed = false;
    const checkTargetChild = (component) => {
      const isTarget = component === child;
      removed || (removed = isTarget);
      return !isTarget;
    };
    this.dataComponents = this.dataComponents.filter(checkTargetChild);
    this.fullscreenChildren = this.fullscreenChildren.filter(checkTargetChild);
    if (!removed) {
      super.removeChild(child);
    }
  }
  getChildWithContent(target) {
    const searchExtendedChildren = () => {
      const candidates = this.fullscreenChildren.concat(this.dataComponents);
      for (const candidate of candidates) {
        if (candidate.getContent() === target) {
          return candidate;
        }
      }
      return null;
    };
    if (target.getSizingMode() === ComponentSizingMode.BoundingBox) {
      return super.getChildWithContent(target) ?? searchExtendedChildren();
    }
    return super.getChildWithContent(target) ?? searchExtendedChildren();
  }
  addLeaf(leafContent) {
    const sizingMode = leafContent.getSizingMode();
    if (sizingMode === ComponentSizingMode.BoundingBox) {
      return super.addLeaf(leafContent);
    } else if (sizingMode === ComponentSizingMode.FillScreen) {
      this.onContentChange();
      const newNode = ImageNode.createLeafNode(this, leafContent);
      this.fullscreenChildren.push(newNode);
      return newNode;
    } else if (sizingMode === ComponentSizingMode.Anywhere) {
      this.onContentChange();
      const newNode = ImageNode.createLeafNode(this, leafContent);
      this.dataComponents.push(newNode);
      return newNode;
    } else {
      const exhaustivenessCheck = sizingMode;
      throw new Error(`Invalid sizing mode, ${sizingMode}`);
      return exhaustivenessCheck;
    }
  }
};

// node_modules/js-draw/dist/mjs/types.mjs
var EditorEventType;
(function(EditorEventType2) {
  EditorEventType2[EditorEventType2["ToolEnabled"] = 0] = "ToolEnabled";
  EditorEventType2[EditorEventType2["ToolDisabled"] = 1] = "ToolDisabled";
  EditorEventType2[EditorEventType2["ToolUpdated"] = 2] = "ToolUpdated";
  EditorEventType2[EditorEventType2["UndoRedoStackUpdated"] = 3] = "UndoRedoStackUpdated";
  EditorEventType2[EditorEventType2["CommandDone"] = 4] = "CommandDone";
  EditorEventType2[EditorEventType2["CommandUndone"] = 5] = "CommandUndone";
  EditorEventType2[EditorEventType2["ObjectAdded"] = 6] = "ObjectAdded";
  EditorEventType2[EditorEventType2["ViewportChanged"] = 7] = "ViewportChanged";
  EditorEventType2[EditorEventType2["DisplayResized"] = 8] = "DisplayResized";
  EditorEventType2[EditorEventType2["SelectionUpdated"] = 9] = "SelectionUpdated";
  EditorEventType2[EditorEventType2["ReadOnlyModeToggled"] = 10] = "ReadOnlyModeToggled";
  EditorEventType2[EditorEventType2["ColorPickerToggled"] = 11] = "ColorPickerToggled";
  EditorEventType2[EditorEventType2["ColorPickerColorSelected"] = 12] = "ColorPickerColorSelected";
  EditorEventType2[EditorEventType2["ToolbarDropdownShown"] = 13] = "ToolbarDropdownShown";
})(EditorEventType || (EditorEventType = {}));
var UndoEventType;
(function(UndoEventType2) {
  UndoEventType2[UndoEventType2["CommandDone"] = 0] = "CommandDone";
  UndoEventType2[UndoEventType2["CommandUndone"] = 1] = "CommandUndone";
  UndoEventType2[UndoEventType2["CommandRedone"] = 2] = "CommandRedone";
})(UndoEventType || (UndoEventType = {}));

// node_modules/js-draw/dist/mjs/Pointer.mjs
var PointerDevice;
(function(PointerDevice2) {
  PointerDevice2[PointerDevice2["Pen"] = 0] = "Pen";
  PointerDevice2[PointerDevice2["Eraser"] = 1] = "Eraser";
  PointerDevice2[PointerDevice2["Touch"] = 2] = "Touch";
  PointerDevice2[PointerDevice2["PrimaryButtonMouse"] = 3] = "PrimaryButtonMouse";
  PointerDevice2[PointerDevice2["RightButtonMouse"] = 4] = "RightButtonMouse";
  PointerDevice2[PointerDevice2["Other"] = 5] = "Other";
})(PointerDevice || (PointerDevice = {}));
var Pointer = class _Pointer {
  constructor(screenPos, canvasPos, pressure, isPrimary, down, device, id, timeStamp) {
    this.screenPos = screenPos;
    this.canvasPos = canvasPos;
    this.pressure = pressure;
    this.isPrimary = isPrimary;
    this.down = down;
    this.device = device;
    this.id = id;
    this.timeStamp = timeStamp;
  }
  /**
   * Snaps this pointer to the nearest grid point (rounds the coordinates of this
   * pointer based on the current zoom). Returns a new Pointer and does not modify
   * this.
   */
  snappedToGrid(viewport) {
    const snappedCanvasPos = viewport.snapToGrid(this.canvasPos);
    return this.withCanvasPosition(snappedCanvasPos, viewport);
  }
  // Snap this pointer to the X or Y axis (whichever is closer), where (0,0)
  // is considered to be at `originPointScreen`.
  // @internal
  lockedToXYAxesScreen(originPointScreen, viewport) {
    const current = this.screenPos;
    const currentFromStart = current.minus(originPointScreen);
    const projOntoXAxis = Vec2.unitX.times(currentFromStart.x);
    const projOntoYAxis = Vec2.unitY.times(currentFromStart.y);
    let pos;
    if (currentFromStart.dot(projOntoXAxis) > currentFromStart.dot(projOntoYAxis)) {
      pos = projOntoXAxis;
    } else {
      pos = projOntoYAxis;
    }
    pos = pos.plus(originPointScreen);
    return this.withScreenPosition(pos, viewport);
  }
  /** @see {@link withCanvasPosition} */
  withScreenPosition(screenPos, viewport) {
    const canvasPos = viewport.screenToCanvas(screenPos);
    return this.withCanvasPosition(canvasPos, viewport);
  }
  /** Returns a copy of this pointer with a changed timestamp. */
  withTimestamp(timeStamp) {
    return new _Pointer(this.screenPos, this.canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, timeStamp);
  }
  /**
   * Returns a copy of this pointer with a new position. The screen position is determined
   * by the given `canvasPos`.
   */
  withCanvasPosition(canvasPos, viewport) {
    const screenPos = viewport.canvasToScreen(canvasPos);
    return new _Pointer(screenPos, canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, this.timeStamp);
  }
  // Creates a Pointer from a DOM event. If `relativeTo` is given, (0, 0) in screen coordinates is
  // considered the top left of `relativeTo`.
  static ofEvent(evt, isDown, viewport, relativeTo) {
    let screenPos = Vec2.of(evt.clientX, evt.clientY);
    if (relativeTo) {
      const bbox = relativeTo.getBoundingClientRect();
      screenPos = screenPos.minus(Vec2.of(bbox.left, bbox.top));
    }
    const pointerTypeToDevice = {
      mouse: PointerDevice.PrimaryButtonMouse,
      pen: PointerDevice.Pen,
      touch: PointerDevice.Touch
    };
    let device = pointerTypeToDevice[evt.pointerType] ?? PointerDevice.Other;
    const eraserButtonMask = 32;
    if (device === PointerDevice.Pen && (evt.buttons & eraserButtonMask) !== 0) {
      device = PointerDevice.Eraser;
    }
    const timeStamp = evt.timeStamp;
    const canvasPos = viewport.roundPoint(viewport.screenToCanvas(screenPos));
    if (device === PointerDevice.PrimaryButtonMouse) {
      if (evt.buttons & 2) {
        device = PointerDevice.RightButtonMouse;
      }
    }
    return new _Pointer(screenPos, canvasPos, evt.pressure ?? null, evt.isPrimary, isDown, device, evt.pointerId, timeStamp);
  }
  // Create a new Pointer from a point on the canvas.
  // Intended for unit tests.
  static ofCanvasPoint(canvasPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {
    const screenPos = viewport.canvasToScreen(canvasPos);
    timeStamp ?? (timeStamp = performance.now());
    return new _Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);
  }
  // Create a new Pointer from a point on the screen.
  // Intended for unit tests.
  static ofScreenPoint(screenPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {
    const canvasPos = viewport.screenToCanvas(screenPos);
    timeStamp ?? (timeStamp = performance.now());
    return new _Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);
  }
};

// node_modules/js-draw/dist/mjs/util/untilNextAnimationFrame.mjs
var untilNextAnimationFrame = () => {
  return new Promise((resolve) => {
    requestAnimationFrame(() => resolve());
  });
};
var untilNextAnimationFrame_default = untilNextAnimationFrame;

// node_modules/js-draw/dist/mjs/inputEvents.mjs
var InputEvtType;
(function(InputEvtType2) {
  InputEvtType2[InputEvtType2["PointerDownEvt"] = 0] = "PointerDownEvt";
  InputEvtType2[InputEvtType2["PointerMoveEvt"] = 1] = "PointerMoveEvt";
  InputEvtType2[InputEvtType2["PointerUpEvt"] = 2] = "PointerUpEvt";
  InputEvtType2[InputEvtType2["GestureCancelEvt"] = 3] = "GestureCancelEvt";
  InputEvtType2[InputEvtType2["WheelEvt"] = 4] = "WheelEvt";
  InputEvtType2[InputEvtType2["KeyPressEvent"] = 5] = "KeyPressEvent";
  InputEvtType2[InputEvtType2["KeyUpEvent"] = 6] = "KeyUpEvent";
  InputEvtType2[InputEvtType2["CopyEvent"] = 7] = "CopyEvent";
  InputEvtType2[InputEvtType2["PasteEvent"] = 8] = "PasteEvent";
  InputEvtType2[InputEvtType2["ContextMenu"] = 9] = "ContextMenu";
})(InputEvtType || (InputEvtType = {}));
var keyEventFromHTMLEvent = (kind, event) => {
  return {
    kind,
    key: event.key,
    code: event.code,
    ctrlKey: event.ctrlKey || event.metaKey,
    altKey: event.altKey,
    shiftKey: event.shiftKey
  };
};
var keyUpEventFromHTMLEvent = (event) => {
  return keyEventFromHTMLEvent(InputEvtType.KeyUpEvent, event);
};
var keyPressEventFromHTMLEvent = (event) => {
  return keyEventFromHTMLEvent(InputEvtType.KeyPressEvent, event);
};
var isPointerEvt = (event) => {
  return event.kind === InputEvtType.PointerDownEvt || event.kind === InputEvtType.PointerMoveEvt || event.kind === InputEvtType.PointerUpEvt;
};

// node_modules/js-draw/dist/mjs/util/ReactiveValue.mjs
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ReactiveValueImpl_value;
var _ReactiveValueImpl_onUpdateListeners;
var noOpUpdateListenerResult = {
  remove() {
  }
};
var noOpSetUpdateListener = () => {
  return noOpUpdateListenerResult;
};
var ReactiveValue = class _ReactiveValue {
  /** Returns a promise that resolves when this value is next changed. */
  waitForNextUpdate() {
    return new Promise((resolve) => {
      const listener = this.onUpdate((value) => {
        listener.remove();
        resolve(value);
      });
    });
  }
  /** Creates a `ReactiveValue` with an initial value, `initialValue`. */
  static fromInitialValue(initialValue) {
    return new ReactiveValueImpl(initialValue);
  }
  /** Returns a `ReactiveValue` that is **known** will never change. */
  static fromImmutable(value) {
    return {
      get: () => value,
      onUpdate: noOpSetUpdateListener,
      onUpdateAndNow: (callback) => {
        callback(value);
        return noOpUpdateListenerResult;
      },
      // Never resolves -- immutable.
      waitForNextUpdate: () => new Promise(() => {
      })
    };
  }
  /**
   * Creates a `ReactiveValue` whose values come from `callback`.
   *
   * `callback` is called whenever any of `sourceValues` are updated and initially to
   * set the initial value of the result.
   */
  static fromCallback(callback, sourceValues) {
    const result = new ReactiveValueImpl(callback());
    const resultRef = typeof WeakRef !== "undefined" ? new WeakRef(result) : { deref: () => result };
    for (const value of sourceValues) {
      const listener = value.onUpdate(() => {
        const value2 = resultRef.deref();
        if (value2) {
          value2.set(callback());
        } else {
          listener.remove();
        }
      });
    }
    return result;
  }
  static map(source, map, inverseMap) {
    const result = _ReactiveValue.fromInitialValue(map(source.get()));
    let expectedResultValue = result.get();
    source.onUpdate((newValue) => {
      expectedResultValue = map(newValue);
      result.set(expectedResultValue);
    });
    if (inverseMap) {
      result.onUpdate((newValue) => {
        if (newValue !== expectedResultValue) {
          source.set(inverseMap(newValue));
        }
      });
    }
    return result;
  }
  static union(values) {
    return _ReactiveValue.fromCallback(() => {
      return values.map((value) => value.get());
    }, values);
  }
};
var MutableReactiveValue = class extends ReactiveValue {
  static fromProperty(sourceValue, propertyName) {
    const child = ReactiveValue.fromInitialValue(sourceValue.get()[propertyName]);
    const childRef = typeof WeakRef !== "undefined" ? new WeakRef(child) : { deref: () => child };
    const sourceListener = sourceValue.onUpdate((newValue) => {
      const childValue = childRef.deref();
      if (childValue) {
        childValue.set(newValue[propertyName]);
      } else {
        sourceListener.remove();
      }
    });
    child.onUpdate((newValue) => {
      sourceValue.set({
        ...sourceValue.get(),
        [propertyName]: newValue
      });
    });
    return child;
  }
};
var ReactiveValueImpl = class extends MutableReactiveValue {
  constructor(initialValue) {
    super();
    _ReactiveValueImpl_value.set(this, void 0);
    _ReactiveValueImpl_onUpdateListeners.set(this, void 0);
    __classPrivateFieldSet4(this, _ReactiveValueImpl_value, initialValue, "f");
    __classPrivateFieldSet4(this, _ReactiveValueImpl_onUpdateListeners, [], "f");
  }
  set(newValue) {
    if (__classPrivateFieldGet4(this, _ReactiveValueImpl_value, "f") === newValue) {
      return;
    }
    __classPrivateFieldSet4(this, _ReactiveValueImpl_value, newValue, "f");
    for (const listener of __classPrivateFieldGet4(this, _ReactiveValueImpl_onUpdateListeners, "f")) {
      listener(newValue);
    }
  }
  get() {
    return __classPrivateFieldGet4(this, _ReactiveValueImpl_value, "f");
  }
  onUpdate(listener) {
    __classPrivateFieldGet4(this, _ReactiveValueImpl_onUpdateListeners, "f").push(listener);
    return {
      remove: () => {
        __classPrivateFieldSet4(this, _ReactiveValueImpl_onUpdateListeners, __classPrivateFieldGet4(this, _ReactiveValueImpl_onUpdateListeners, "f").filter((otherListener) => {
          return otherListener !== listener;
        }), "f");
      }
    };
  }
  onUpdateAndNow(callback) {
    callback(this.get());
    return this.onUpdate(callback);
  }
};
_ReactiveValueImpl_value = /* @__PURE__ */ new WeakMap(), _ReactiveValueImpl_onUpdateListeners = /* @__PURE__ */ new WeakMap();
var ReactiveValue_default = ReactiveValue;

// node_modules/js-draw/dist/mjs/tools/BaseTool.mjs
var __classPrivateFieldSet5 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet5 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseTool_enabled;
var _BaseTool_group;
var _BaseTool_inputMapper;
var _BaseTool_readOnlyEditorChangeListener;
var BaseTool = class {
  constructor(notifier, description) {
    this.notifier = notifier;
    this.description = description;
    _BaseTool_enabled.set(this, void 0);
    _BaseTool_group.set(this, null);
    _BaseTool_inputMapper.set(this, null);
    _BaseTool_readOnlyEditorChangeListener.set(this, null);
    __classPrivateFieldSet5(this, _BaseTool_enabled, ReactiveValue.fromInitialValue(true), "f");
    __classPrivateFieldGet5(this, _BaseTool_enabled, "f").onUpdate((enabled) => {
      var _a6;
      if (enabled) {
        (_a6 = __classPrivateFieldGet5(this, _BaseTool_group, "f")) == null ? void 0 : _a6.notifyEnabled(this);
        this.notifier.dispatch(EditorEventType.ToolEnabled, {
          kind: EditorEventType.ToolEnabled,
          tool: this
        });
      } else {
        this.notifier.dispatch(EditorEventType.ToolDisabled, {
          kind: EditorEventType.ToolDisabled,
          tool: this
        });
      }
    });
  }
  /** Override this to allow this tool to be enabled in a read-only editor */
  canReceiveInputInReadOnlyEditor() {
    return false;
  }
  setInputMapper(mapper) {
    __classPrivateFieldSet5(this, _BaseTool_inputMapper, mapper, "f");
    if (mapper) {
      mapper.setEmitListener((event) => this.dispatchEventToCallback(event));
    }
  }
  getInputMapper() {
    return __classPrivateFieldGet5(this, _BaseTool_inputMapper, "f");
  }
  dispatchEventToCallback(event) {
    let exhaustivenessCheck;
    switch (event.kind) {
      case InputEvtType.PointerDownEvt:
        return this.onPointerDown(event);
      case InputEvtType.PointerMoveEvt:
        this.onPointerMove(event);
        break;
      case InputEvtType.PointerUpEvt:
        return this.onPointerUp(event) ?? false;
      case InputEvtType.GestureCancelEvt:
        this.onGestureCancel(event);
        break;
      case InputEvtType.WheelEvt:
        return this.onWheel(event);
      case InputEvtType.KeyPressEvent:
        return this.onKeyPress(event);
      case InputEvtType.KeyUpEvent:
        return this.onKeyUp(event);
      case InputEvtType.CopyEvent:
        return this.onCopy(event);
      case InputEvtType.PasteEvent:
        return this.onPaste(event);
      case InputEvtType.ContextMenu:
        return this.onContextMenu(event);
      default:
        exhaustivenessCheck = event;
        return exhaustivenessCheck;
    }
    return true;
  }
  // @internal
  onEvent(event) {
    if (__classPrivateFieldGet5(this, _BaseTool_inputMapper, "f")) {
      return __classPrivateFieldGet5(this, _BaseTool_inputMapper, "f").onEvent(event);
    }
    return this.dispatchEventToCallback(event);
  }
  /**
   * Returns true iff the tool handled the event and thus should receive additional
   * events.
   */
  onPointerDown(_event) {
    return false;
  }
  onPointerMove(_event) {
  }
  /**
   * Returns true iff there are additional pointers down and the tool should
   * remain active to handle the additional events.
   *
   * For most purposes, this should return `false` or nothing.
   */
  onPointerUp(_event) {
  }
  onGestureCancel(_event) {
  }
  onWheel(_event) {
    return false;
  }
  onCopy(_event) {
    return false;
  }
  onPaste(_event) {
    return false;
  }
  onKeyPress(_event) {
    return false;
  }
  onKeyUp(_event) {
    return false;
  }
  onContextMenu(_event) {
    return false;
  }
  /**
   * Return true if, while this tool is active, `_event` can be delivered to
   * another tool that is higher priority than this.
   * @internal May be renamed
   */
  eventCanBeDeliveredToNonActiveTool(_event) {
    return true;
  }
  setEnabled(enabled) {
    __classPrivateFieldGet5(this, _BaseTool_enabled, "f").set(enabled);
  }
  isEnabled() {
    return __classPrivateFieldGet5(this, _BaseTool_enabled, "f").get();
  }
  /**
   * Returns a {@link ReactiveValue} that updates based on whether this tool is
   * enabled.
   *
   * @example
   * ```ts
   * const tool = new SomeTool();
   *
   * // Watch for changes in enabled status
   * tool.enabledValue().onUpdate(enabled => doSomething(enabled));
   * ```
   */
  enabledValue() {
    return __classPrivateFieldGet5(this, _BaseTool_enabled, "f");
  }
  // Connect this tool to a set of other tools, ensuring that at most one
  // of the tools in the group is enabled.
  setToolGroup(group) {
    if (this.isEnabled()) {
      group.notifyEnabled(this);
    }
    __classPrivateFieldSet5(this, _BaseTool_group, group, "f");
  }
  getToolGroup() {
    if (__classPrivateFieldGet5(this, _BaseTool_group, "f")) {
      return __classPrivateFieldGet5(this, _BaseTool_group, "f");
    }
    return null;
  }
  // Called when the tool is removed/when the editor is destroyed.
  // Subclasses that override this method **must call super.onDestroy()**.
  onDestroy() {
    var _a6;
    (_a6 = __classPrivateFieldGet5(this, _BaseTool_readOnlyEditorChangeListener, "f")) == null ? void 0 : _a6.remove();
    __classPrivateFieldSet5(this, _BaseTool_readOnlyEditorChangeListener, null, "f");
    __classPrivateFieldSet5(this, _BaseTool_group, null, "f");
  }
};
_BaseTool_enabled = /* @__PURE__ */ new WeakMap(), _BaseTool_group = /* @__PURE__ */ new WeakMap(), _BaseTool_inputMapper = /* @__PURE__ */ new WeakMap(), _BaseTool_readOnlyEditorChangeListener = /* @__PURE__ */ new WeakMap();
var BaseTool_default = BaseTool;

// node_modules/js-draw/dist/mjs/commands/localization.mjs
var defaultCommandLocalization = {
  updatedViewport: "Transformed Viewport",
  transformedElements: (elemCount, action) => `Transformed ${elemCount} element${elemCount === 1 ? "" : "s"} (${action})`,
  resizeOutputCommand: (newSize) => `Resized image to ${newSize.w}x${newSize.h}`,
  enabledAutoresizeOutputCommand: "Enabled output autoresize",
  disabledAutoresizeOutputCommand: "Disabled output autoresize",
  addComponentAction: (componentDescription) => `Added ${componentDescription}`,
  eraseAction: (componentDescription, numElems) => `Erased ${numElems} ${componentDescription}`,
  duplicateAction: (componentDescription, numElems) => `Duplicated ${numElems} ${componentDescription}`,
  unionOf: (actionDescription, actionCount) => `Union: ${actionCount} ${actionDescription}`,
  inverseOf: (actionDescription) => `Inverse of ${actionDescription}`,
  elements: "Elements",
  erasedNoElements: "Erased nothing",
  duplicatedNoElements: "Duplicated nothing",
  rotatedBy: (degrees) => `Rotated by ${Math.abs(degrees)} degrees ${degrees < 0 ? "clockwise" : "counter-clockwise"}`,
  movedLeft: "Moved left",
  movedUp: "Moved up",
  movedDown: "Moved down",
  movedRight: "Moved right",
  zoomedOut: "Zoomed out",
  zoomedIn: "Zoomed in",
  andNMoreCommands: (count) => `And ${count} more commands.`,
  selectedElements: (count) => `Selected ${count} element${count === 1 ? "" : "s"}`
};

// node_modules/js-draw/dist/mjs/components/localization.mjs
var defaultComponentLocalization = {
  unlabeledImageNode: "Unlabeled image node",
  stroke: "Stroke",
  svgObject: "SVG Object",
  emptyBackground: "Empty background",
  gridBackground: "Grid background",
  filledBackgroundWithColor: (color) => `Filled background (${color})`,
  text: (text) => `Text object: ${text}`,
  imageNode: (description) => `Image: ${description}`,
  restyledElement: (elementDescription) => `Restyled ${elementDescription}`
};

// node_modules/js-draw/dist/mjs/rendering/localization.mjs
var defaultTextRendererLocalization = {
  pathNodeCount: (count) => `There are ${count} visible path objects.`,
  textNodeCount: (count) => `There are ${count} visible text nodes.`,
  imageNodeCount: (nodeCount) => `There are ${nodeCount} visible image nodes.`,
  textNode: (content) => `Text: ${content}`,
  imageNode: (label) => `Image: ${label}`,
  unlabeledImageNode: "Unlabeled image",
  rerenderAsText: "Re-render as text"
};

// node_modules/js-draw/dist/mjs/toolbar/utils/localization.mjs
var defaultToolbarUtilsLocalization = {
  help: "Help",
  helpHidden: "Help hidden",
  next: "Next",
  previous: "Previous",
  close: "Close",
  helpScreenNavigationHelp: "Click on a control for more information.",
  helpControlsAccessibilityLabel: "Controls: Activate a control to show help."
};

// node_modules/js-draw/dist/mjs/toolbar/localization.mjs
var defaultToolbarLocalization = {
  ...defaultToolbarUtilsLocalization,
  pen: "Pen",
  eraser: "Eraser",
  select: "Select",
  handTool: "Pan",
  zoom: "Zoom",
  image: "Image",
  reformatSelection: "Format selection",
  inputAltText: "Alt text",
  decreaseImageSize: "Decrease size",
  resetImage: "Reset",
  chooseFile: "Choose file",
  dragAndDropHereOrBrowse: "Drag and drop here\nor\n{{browse}}",
  submit: "Submit",
  addAll: "Add all",
  cancel: "Cancel",
  resetView: "Reset view",
  thicknessLabel: "Thickness",
  colorLabel: "Color",
  fontLabel: "Font",
  textSize: "Size",
  resizeImageToSelection: "Resize image to selection",
  deleteSelection: "Delete selection",
  duplicateSelection: "Duplicate selection",
  exit: "Exit",
  save: "Save",
  undo: "Undo",
  redo: "Redo",
  fullStrokeEraser: "Full stroke eraser",
  selectPenType: "Pen type",
  selectShape: "Shape",
  pickColorFromScreen: "Pick color from screen",
  clickToPickColorAnnouncement: "Click on the screen to pick a color",
  colorSelectionCanceledAnnouncement: "Color selection canceled",
  selectionTool__lassoSelect: "Freeform selection",
  selectionTool__lassoSelect__help: "When enabled, dragging creates a freeform (lasso) selection.",
  selectionToolKeyboardShortcuts: "Selection tool: Use arrow keys to move selected items, lowercase/uppercase ‘i’ and ‘o’ to resize.",
  documentProperties: "Page",
  backgroundColor: "Background color",
  imageWidthOption: "Width",
  imageHeightOption: "Height",
  useGridOption: "Grid",
  enableAutoresizeOption: "Auto-resize",
  toggleOverflow: "More",
  about: "About",
  inputStabilization: "Stabilization",
  strokeAutocorrect: "Autocorrect",
  pressureSensitivity: "Pressure",
  touchPanning: "Scroll with touch",
  roundedTipPen: "Round",
  roundedTipPen2: "Polyline",
  flatTipPen: "Flat",
  arrowPen: "Arrow",
  linePen: "Line",
  outlinedRectanglePen: "Outlined rectangle",
  filledRectanglePen: "Filled rectangle",
  outlinedCirclePen: "Outlined circle",
  lockRotation: "Lock rotation",
  paste: "Paste",
  errorImageHasZeroSize: "Error: Image has zero size",
  describeTheImage: "Image description",
  fileInput__loading: "Loading...",
  fileInput__andNMoreFiles: (n) => `(...${n} more)`,
  // Help text
  penDropdown__baseHelpText: "This tool draws shapes or freehand lines.",
  penDropdown__colorHelpText: "Changes the pen's color",
  penDropdown__thicknessHelpText: "Changes the thickness of strokes drawn by the pen.",
  penDropdown__penTypeHelpText: "Changes the pen style.\n\nEither a “pen” style or “shape” can be chosen. Choosing a “pen” style draws freehand lines. Choosing a “shape” draws shapes.",
  penDropdown__autocorrectHelpText: "Converts approximate freehand lines and rectangles to perfect ones.\n\nThe pen must be held stationary at the end of a stroke to trigger a correction.",
  penDropdown__stabilizationHelpText: "Draws smoother strokes.\n\nThis also adds a short delay between the mouse/stylus and the stroke.",
  penDropdown__pressureSensitivityHelpText: "Changes the thickness of strokes according to how hard you press, when using a compatible device like a stylus.",
  handDropdown__baseHelpText: "This tool is responsible for scrolling, rotating, and zooming the editor.",
  handDropdown__zoomInHelpText: "Zooms in.",
  handDropdown__zoomOutHelpText: "Zooms out.",
  handDropdown__resetViewHelpText: "Resets the zoom level to 100% and resets scroll.",
  handDropdown__zoomDisplayHelpText: "Shows the current zoom level. 100% shows the image at its actual size.",
  handDropdown__touchPanningHelpText: "When enabled, touchscreen gestures move the image rather than select or draw.",
  handDropdown__lockRotationHelpText: "When enabled, prevents touch gestures from rotating the screen.",
  eraserDropdown__baseHelpText: "This tool removes strokes, images, and text under the cursor.",
  eraserDropdown__thicknessHelpText: "Changes the size of the eraser.",
  eraserDropdown__fullStrokeEraserHelpText: "When in full-stroke mode, entire shapes are erased.\n\nWhen not in full-stroke mode, shapes can be partially erased.",
  selectionDropdown__baseHelpText: "Selects content and manipulates the selection",
  selectionDropdown__resizeToHelpText: "Crops the drawing to the size of what's currently selected.\n\nIf auto-resize is enabled, it will be disabled.",
  selectionDropdown__deleteHelpText: "Erases selected items.",
  selectionDropdown__duplicateHelpText: "Makes a copy of selected items.",
  selectionDropdown__changeColorHelpText: "Changes the color of selected items.",
  pageDropdown__baseHelpText: "Controls the drawing canvas' background color, pattern, and size.",
  pageDropdown__backgroundColorHelpText: "Changes the background color of the drawing canvas.",
  pageDropdown__gridCheckboxHelpText: "Enables/disables a background grid pattern.",
  pageDropdown__autoresizeCheckboxHelpText: "When checked, the page grows to fit the drawing.\n\nWhen unchecked, the page is visible and its size can be set manually.",
  pageDropdown__aboutButtonHelpText: "Shows version, debug, and other information.",
  colorPickerPipetteHelpText: "Picks a color from the screen.",
  colorPickerToggleHelpText: "Opens/closes the color picker.",
  closeSidebar: (toolName) => `Close sidebar for ${toolName}`,
  dropdownShown: (toolName) => `Menu for ${toolName} shown`,
  dropdownHidden: (toolName) => `Menu for ${toolName} hidden`,
  zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,
  colorChangedAnnouncement: (color) => `Color changed to ${color}`,
  imageSize: (size, units) => `Image size: ${size} ${units}`,
  imageLoadError: (message) => `Error loading image: ${message}`
};

// node_modules/js-draw/dist/mjs/tools/localization.mjs
var defaultToolLocalization = {
  penTool: (penId) => `Pen ${penId}`,
  selectionTool: "Selection",
  selectAllTool: "Select all shortcut",
  eraserTool: "Eraser",
  touchPanTool: "Touch panning",
  twoFingerPanZoomTool: "Panning and zooming",
  undoRedoTool: "Undo/Redo",
  rightClickDragPanTool: "Right-click drag",
  pipetteTool: "Pick color from screen",
  keyboardPanZoom: "Keyboard pan/zoom shortcuts",
  selectionMenu__show: "Show selection menu",
  selectionMenu__copyToClipboard: "Copy to clipboard",
  selectionMenu__duplicate: "Duplicate",
  selectionMenu__delete: "Delete",
  selectionMenu__paste: "Paste",
  copyPasteError__heading: "Copy/paste",
  copyPasteError__description: "Something went wrong — this tool may not have clipboard access.",
  copyPasteError__errorDetails: "Show error",
  copyPasteError__pasteRetry: "To retry, please paste into the input box below:",
  copyPasteError__copyRetry: "To retry, please copy the text in the input box below:",
  copyPasteError__copyMe: "Copy me!",
  autocorrectedTo: (strokeDescription) => `Autocorrected to ${strokeDescription}`,
  autocorrectionCanceled: "Autocorrect cancelled",
  textTool: "Text",
  enterTextToInsert: "Text to insert",
  changeTool: "Change tool",
  pasteHandler: "Copy paste handler",
  soundExplorer: "Sound-based image exploration",
  disableAccessibilityExploreTool: "Disable sound-based exploration",
  enableAccessibilityExploreTool: "Enable sound-based exploration",
  soundExplorerUsageAnnouncement: "Sound-based image exploration enabled: Click/drag the screen to play a sound representation of different parts of the image.",
  findLabel: "Find",
  toNextMatch: "Next",
  closeDialog: "Close",
  findDialogShown: "Find dialog shown",
  findDialogHidden: "Find dialog hidden",
  focusedFoundText: (matchIdx, totalMatches) => `Viewing match ${matchIdx} of ${totalMatches}`,
  anyDevicePanning: "Any device panning",
  copied: (count) => `Copied ${count} item(s)`,
  pasted: (count) => `Pasted ${count} item(s)`,
  toolEnabledAnnouncement: (toolName) => `${toolName} enabled`,
  toolDisabledAnnouncement: (toolName) => `${toolName} disabled`
};

// node_modules/js-draw/dist/mjs/localization.mjs
var defaultEditorLocalization = {
  ...defaultToolbarLocalization,
  ...defaultToolLocalization,
  ...defaultCommandLocalization,
  ...defaultComponentLocalization,
  ...defaultTextRendererLocalization,
  accessibilityInputInstructions: [
    'Press "t" to read the contents of the viewport as text.',
    "Use the arrow keys to move the viewport, click and drag to draw strokes.",
    'Press "w" to zoom in and "s" to zoom out.'
  ].join(" "),
  loading: (percentage) => `Loading ${percentage}%...`,
  imageEditor: "Image Editor",
  doneLoading: "Done loading",
  undoAnnouncement: (commandDescription) => `Undid ${commandDescription}`,
  redoAnnouncement: (commandDescription) => `Redid ${commandDescription}`,
  softwareLibraries: "Libraries",
  developerInformation: "Developer information"
};

// node_modules/js-draw/dist/mjs/localizations/de.mjs
var localization = {
  ...defaultEditorLocalization,
  pen: "Stift",
  eraser: "Radierer",
  select: "Auswahl",
  handTool: "Verschieben",
  zoom: "Vergrößerung",
  image: "Bild",
  inputAltText: "Alt-Text: ",
  chooseFile: "Wähle Datei: ",
  submit: "Absenden",
  cancel: "Abbrechen",
  resetView: "Ansicht zurücksetzen",
  thicknessLabel: "Dicke: ",
  colorLabel: "Farbe: ",
  fontLabel: "Schriftart: ",
  textSize: "Größe: ",
  resizeImageToSelection: "Bildgröße an Auswahl anpassen",
  deleteSelection: "Auswahl löschen",
  duplicateSelection: "Auswahl duplizieren",
  undo: "Rückgängig",
  redo: "Wiederholen",
  pickColorFromScreen: "Farbe von Bildschirm auswählen",
  clickToPickColorAnnouncement: "Klicke auf den Bildschirm, um eine Farbe auszuwählen",
  selectionToolKeyboardShortcuts: "Auswahl-Werkzeug: Verwende die Pfeiltasten, um ausgewählte Elemente zu verschieben und ‚i‘ und ‚o‘, um ihre Größe zu ändern.",
  touchPanning: "Ansicht mit Touchscreen verschieben",
  anyDevicePanning: "Ansicht mit jedem Eingabegerät verschieben",
  selectPenType: "Objekt-Typ: ",
  roundedTipPen: "Freihand",
  flatTipPen: "Stift (druckempfindlich)",
  arrowPen: "Pfeil",
  linePen: "Linie",
  outlinedRectanglePen: "Umrissenes Rechteck",
  filledRectanglePen: "Ausgefülltes Rechteck",
  lockRotation: "Sperre Rotation",
  paste: "Einfügen",
  dropdownShown: (toolName) => `Dropdown-Menü für ${toolName} angezeigt`,
  dropdownHidden: (toolName) => `Dropdown-Menü für ${toolName} versteckt`,
  zoomLevel: (zoomPercent) => `Vergößerung: ${zoomPercent}%`,
  colorChangedAnnouncement: (color) => `Farbe zu ${color} geändert`,
  imageSize: (size, units) => `Bild-Größe: ${size} ${units}`,
  imageLoadError: (message) => `Fehler beim Laden des Bildes: ${message}`,
  errorImageHasZeroSize: "Fehler: Bild hat Größe Null",
  penTool: (penNumber) => `Stift ${penNumber}`,
  selectionTool: "Auswahl",
  eraserTool: "Radiergummi",
  touchPanTool: "Ansicht mit Touchscreen verschieben",
  twoFingerPanZoomTool: "Ansicht verschieben und vergrößern",
  undoRedoTool: "Rückgängig/Wiederholen",
  rightClickDragPanTool: "Rechtsklick-Ziehen",
  pipetteTool: "Farbe von Bildschirm auswählen",
  keyboardPanZoom: "Tastaturkürzel zum Verschieben/Vergrößern der Ansicht",
  textTool: "Text",
  enterTextToInsert: "Einzufügender Text",
  changeTool: "Wechsle Werkzeug",
  pasteHandler: "Copy-Paste-Handler",
  findLabel: "Finde",
  toNextMatch: "Nächstes",
  closeDialog: "Schließen",
  findDialogShown: "Finde-Dialog angezeigt",
  findDialogHidden: "Finde-Dialog versteckt",
  focusedFoundText: (matchIdx, totalMatches) => `Sieh Treffer ${matchIdx} von ${totalMatches} an`,
  toolEnabledAnnouncement: (toolName) => `${toolName} aktiviert`,
  toolDisabledAnnouncement: (toolName) => `${toolName} deaktiviert`,
  updatedViewport: "Transformierte Ansicht",
  transformedElements: (elemCount, action) => `${elemCount} Element${1 === elemCount ? "" : "e"} transformiert (${action})`,
  resizeOutputCommand: (newSize) => `Bildgröße auf ${newSize.w}x${newSize.h} geändert`,
  addComponentAction: (componentDescription) => `${componentDescription} hinzugefügt`,
  eraseAction: (elemDescription, countErased) => `${countErased} ${elemDescription} gelöscht`,
  duplicateAction: (elemDescription, countErased) => `${countErased} ${elemDescription} dupliziert`,
  inverseOf: (actionDescription) => `${actionDescription} umgekehrt`,
  elements: "Elemente",
  erasedNoElements: "Nichts entfernt",
  duplicatedNoElements: "Nichts dupliziert",
  rotatedBy: (degrees) => `${Math.abs(degrees)} Grad ${degrees < 0 ? "im Uhrzeigersinn" : "gegen den Uhrzeigersinn"} gedreht`,
  movedLeft: "Nacht links bewegt",
  movedUp: "Nacht oben bewegt",
  movedDown: "Nacht unten bewegt",
  movedRight: "Nacht rechts bewegt",
  zoomedOut: "Ansicht verkleinert",
  zoomedIn: "Ansicht vergrößert",
  selectedElements: (count) => `${count} Element${1 === count ? "" : "e"} ausgewählt`,
  stroke: "Strich",
  svgObject: "SVG-Objekt",
  text: (text) => `Text-Objekt: ${text}`,
  pathNodeCount: (count) => `Es gibt ${count} sichtbare Pfad-Objekte.`,
  textNodeCount: (count) => `Es gibt ${count} sichtbare Text-Knotenpunkte.`,
  textNode: (content) => `Text: ${content}`,
  imageNodeCount: (nodeCount) => `Es gibt ${nodeCount} sichtbare Bild-Knoten.`,
  imageNode: (label) => `Bild: ${label}`,
  unlabeledImageNode: "Bild ohne Label",
  rerenderAsText: "Als Text darstellen",
  accessibilityInputInstructions: "Drücke ‚t‘, um den Inhalt des Ansichtsfensters als Text zu lesen. Verwende die Pfeiltasten, um die Ansicht zu verschieben, und klicke und ziehe, um Striche zu zeichnen. Drücke ‚w‘ zum Vergrößern und ‚s‘ zum Verkleinern der Ansicht.",
  loading: (percentage) => `Laden ${percentage}%...`,
  doneLoading: "Laden fertig",
  imageEditor: "Bild-Editor",
  undoAnnouncement: (commandDescription) => `${commandDescription} rückgängig gemacht`,
  redoAnnouncement: (commandDescription) => `${commandDescription} wiederholt`,
  reformatSelection: "Formatiere Auswahl",
  documentProperties: "Seite",
  backgroundColor: "Hintergrundfarbe: ",
  imageWidthOption: "Breite: ",
  imageHeightOption: "Höhe: ",
  useGridOption: "Gitter: ",
  toggleOverflow: "Mehr",
  selectAllTool: "Alle auswählen",
  soundExplorer: "Klangbasierte Bilderkundung",
  disableAccessibilityExploreTool: "Deaktiviere klangbasierte Erkundung",
  enableAccessibilityExploreTool: "Aktiviere klangbasierte Erkundung",
  unionOf: (actionDescription, actionCount) => `Vereinigung: ${actionCount} ${actionDescription}`,
  emptyBackground: "Leerer Hintergrund",
  filledBackgroundWithColor: (color) => `Gefüllter Hintergrund (${color})`,
  restyledElement: (elementDescription) => `${elementDescription} umgestaltet`
};
var de_default = localization;

// node_modules/js-draw/dist/mjs/localizations/en.mjs
var localization2 = {
  ...defaultEditorLocalization
};
var en_default = localization2;

// node_modules/js-draw/dist/mjs/localizations/es.mjs
var localization3 = {
  ...defaultEditorLocalization,
  pen: "Lapiz",
  eraser: "Borrador",
  select: "Selecciona",
  handTool: "Mover",
  image: "Imagen",
  inputAltText: "Texto alternativo",
  resetImage: "Reiniciar",
  chooseFile: "Seleccionar archivo",
  cancel: "Cancelar",
  resetView: "Reiniciar vista",
  thicknessLabel: "Tamaño",
  fontLabel: "Fuente:",
  textSize: "Tamaño",
  resizeImageToSelection: "Redimensionar la imagen a lo que está seleccionado",
  deleteSelection: "Borra la selección",
  duplicateSelection: "Duplica la selección",
  exit: "Salir",
  save: "Guardar",
  undo: "Deshace",
  redo: "Rehace",
  selectPenType: "Punta",
  selectShape: "Forma",
  pickColorFromScreen: "Selecciona un color de la pantalla",
  clickToPickColorAnnouncement: "Haga un clic en la pantalla para seleccionar un color",
  documentProperties: "Fondo",
  backgroundColor: "Color de fondo",
  imageWidthOption: "Ancho",
  imageHeightOption: "Alto",
  enableAutoresizeOption: "Redimensionar automático",
  toggleOverflow: "Más",
  about: "Acerca de",
  touchPanning: "Mover la pantalla con un dedo",
  roundedTipPen: "Lapiz Redondeado",
  arrowPen: "Flecha",
  linePen: "Línea",
  outlinedRectanglePen: "Rectángulo delineado",
  filledRectanglePen: "Rectángulo sin borde",
  lockRotation: "Bloquea rotación",
  paste: "Pegar",
  selectionMenu__paste: "Pegar",
  selectionMenu__delete: "Eliminar",
  selectionMenu__duplicate: "Duplicar",
  closeSidebar: (toolName) => `Close sidebar for ${toolName}`,
  dropdownShown: (toolName) => `Menú por ${toolName} es visible`,
  dropdownHidden: (toolName) => {
    return `Menú por ${toolName} fue ocultado`;
  },
  zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,
  colorChangedAnnouncement: (color) => {
    return `Color fue cambiado a ${color}`;
  },
  imageSize: (size, units) => `Tamaño del imagen: ${size} ${units}`,
  imageLoadError: (message) => `Error cargando imagen: ${message}`,
  penTool: (penId) => `Lapiz ${penId}`,
  selectionTool: "Selecciona",
  eraserTool: "Borrador",
  touchPanTool: "Instrumento de mover la pantalla con un dedo",
  undoRedoTool: "Deshace/rehace",
  pipetteTool: "Seleccione un color de la pantalla",
  keyboardPanZoom: "Mover la pantalla con el teclado",
  textTool: "Texto",
  enterTextToInsert: "Entra texto",
  findLabel: "Buscar",
  toNextMatch: "Próxima",
  closeDialog: "Cerrar",
  anyDevicePanning: "Mover la pantalla con todo dispotivo",
  copied: (count) => `${count} cosas fueron copiados`,
  pasted: (count) => count === 1 ? "Pegado" : `${count} cosas fueron pegados`,
  toolEnabledAnnouncement: (toolName) => `${toolName} fue activado`,
  toolDisabledAnnouncement: (toolName) => `${toolName} fue desactivado`,
  resizeOutputCommand: (newSize) => `Tamaño de imagen fue cambiado a ${newSize.w}x${newSize.h}`,
  eraseAction: (componentDescription, numElems) => `Borrado: ${numElems} ${componentDescription}`,
  rerenderAsText: "Redibuja la pantalla al texto",
  loading: (percentage) => `Cargando: ${percentage}%...`,
  imageEditor: "Editor de dibujos",
  doneLoading: "El cargado terminó",
  undoAnnouncement: (commandDescription) => `${commandDescription} fue deshecho`,
  redoAnnouncement: (commandDescription) => `${commandDescription} fue rehecho`
};
var es_default = localization3;

// node_modules/js-draw/dist/mjs/localizations/getLocalizationTable.mjs
var allLocales = {
  de: de_default,
  en: en_default,
  es: es_default
};
var languageFromLocale = (locale) => {
  const matches = /^(\w+)[_-](\w+)$/.exec(locale);
  if (!matches) {
    return locale;
  }
  return matches[1];
};
var matchingLocalizationTable = (userLocales, localizationTables, defaultLocalizationTable) => {
  let prevLanguage;
  for (const locale of userLocales) {
    const language = languageFromLocale(locale);
    if (prevLanguage && language !== prevLanguage) {
      if (prevLanguage in localizationTables) {
        return localizationTables[prevLanguage];
      }
    }
    if (locale in localizationTables) {
      return localizationTables[locale];
    }
    prevLanguage = language;
  }
  if (prevLanguage && prevLanguage in localizationTables) {
    return localizationTables[prevLanguage];
  } else {
    return defaultLocalizationTable;
  }
};
var getLocalizationTable = (userLocales) => {
  userLocales ?? (userLocales = navigator.languages);
  return matchingLocalizationTable(userLocales, allLocales, defaultEditorLocalization);
};
var getLocalizationTable_default = getLocalizationTable;

// node_modules/js-draw/dist/mjs/shortcuts/KeyBinding.mjs
var isUppercaseLetter = (text) => {
  return text.toUpperCase() === text && text.toLowerCase() !== text && text.length === 1;
};
var isLowercaseLetter = (text) => {
  return text.toLowerCase() === text && text.toUpperCase() !== text && text.length === 1;
};
var KeyBinding = class _KeyBinding {
  constructor(trigger) {
    this.key = trigger.key;
    this.shiftKey = trigger.shiftKey;
    this.ctrlKey = trigger.ctrlKey;
    this.altKey = trigger.altKey;
    this.metaKey = trigger.metaKey;
    this.controlOrMeta = trigger.controlOrMeta;
  }
  /** Returns true if and only if `keyEvent` should trigger this shortcut. */
  matchesEvent(keyEvent) {
    var _a6;
    const lowercaseKey = (_a6 = keyEvent.key) == null ? void 0 : _a6.toLowerCase();
    const isUpperCaseKey = isUppercaseLetter(keyEvent.key ?? "");
    const isLowercaseKey = isLowercaseLetter(keyEvent.key ?? "");
    const ctrlKey = (keyEvent.ctrlKey ?? false) || lowercaseKey === "control";
    const altKey = (keyEvent.altKey ?? false) || lowercaseKey === "alt";
    const metaKey = (keyEvent.metaKey ?? false) || lowercaseKey === "meta";
    const shiftKey = (keyEvent.shiftKey ?? isUpperCaseKey) || lowercaseKey === "shift";
    const keyEventHasCtrlOrMeta = keyEvent.controlOrMeta || keyEvent.ctrlKey || keyEvent.metaKey || false;
    if (this.key !== keyEvent.code) {
      if (this.key.toLowerCase() !== lowercaseKey) {
        return false;
      }
      if ((isUpperCaseKey || isLowercaseKey) && this.key !== keyEvent.key) {
        const uppercaseKeyMatches = this.shiftKey === true && this.key.toUpperCase() === keyEvent.key;
        if (!uppercaseKeyMatches) {
          return false;
        }
      }
    }
    const shortcutControlOrMeta = this.controlOrMeta;
    const ctrlAndMetaMatches = ctrlKey === this.ctrlKey && metaKey === this.metaKey && !shortcutControlOrMeta;
    const matches = (ctrlAndMetaMatches || shortcutControlOrMeta && keyEventHasCtrlOrMeta) && altKey === this.altKey && (shiftKey === this.shiftKey || this.shiftKey === void 0);
    return matches;
  }
  /**
   * Returns a string representation of this shortcut in the same format accepted by
   * {@link fromString}.
   */
  toString() {
    const result = [];
    if (this.ctrlKey && this.key !== "control") {
      result.push("Ctrl");
    }
    if (this.controlOrMeta) {
      result.push("CtrlOrMeta");
    }
    if (this.altKey && this.key !== "alt") {
      result.push("Alt");
    }
    if (this.metaKey && this.key !== "meta") {
      result.push("Meta");
    }
    if (this.shiftKey && this.key !== "shift") {
      result.push("Shift");
    }
    result.push(this.key);
    return result.join("+");
  }
  /**
   * Accepts a string in the form `modifier1+modifier2+...+key` (e.g. `Ctrl+Shift+a`)
   * and returns the corresponding `KeyboardShortcut`.
   */
  static fromString(shortcutStr) {
    const getDefaultModifiers = (key2) => {
      let shiftKey2 = void 0;
      if (isUppercaseLetter(key2)) {
        shiftKey2 = true;
      } else if (isLowercaseLetter(key2)) {
        shiftKey2 = false;
      } else if (key2.length > 1) {
        shiftKey2 = false;
      }
      const lowercaseKey = key2.toLowerCase();
      if (lowercaseKey === "shift") {
        shiftKey2 = true;
      }
      return {
        shiftKey: shiftKey2,
        ctrlKey: lowercaseKey === "control" || lowercaseKey === "ctrl",
        altKey: lowercaseKey === "alt",
        metaKey: lowercaseKey === "meta",
        controlOrMeta: lowercaseKey === "control or meta" || lowercaseKey === "ctrlormeta"
      };
    };
    const hasNoModifiers = shortcutStr.search(/[-+]/) === -1 || shortcutStr.length === 1;
    if (hasNoModifiers) {
      const modifiers = getDefaultModifiers(shortcutStr);
      return new _KeyBinding({
        key: shortcutStr,
        ...modifiers
      });
    }
    const keyModifiersExp = /^(.*[-+])?(.+)$/g;
    const match = keyModifiersExp.exec(shortcutStr);
    if (!match) {
      throw new Error(`Invalid shortcut expression, ${shortcutStr}!`);
    }
    const key = match[2];
    const defaultModifiers = getDefaultModifiers(key);
    const modifierStrings = (match[1] ?? "").split(/[-+]/);
    let shiftKey = defaultModifiers.shiftKey;
    let ctrlKey = defaultModifiers.ctrlKey;
    let altKey = defaultModifiers.altKey;
    let metaKey = defaultModifiers.metaKey;
    let controlOrMeta = defaultModifiers.controlOrMeta;
    for (const modifier of modifierStrings) {
      if (modifier === "") {
        continue;
      }
      switch (modifier.toLowerCase()) {
        case "shift":
          shiftKey = true;
          break;
        case "anyshift":
          shiftKey = void 0;
          break;
        case "ctrl":
        case "control":
          ctrlKey = true;
          break;
        case "meta":
          metaKey = true;
          break;
        case "ctrlormeta":
        case "ctrl or meta":
        case "controlormeta":
          controlOrMeta = true;
          break;
        case "alt":
          altKey = true;
          break;
        default:
          throw new Error(`Unknown modifier: "${modifier}" in shortcut ${shortcutStr}.`);
      }
    }
    const shortcut = new _KeyBinding({
      key,
      shiftKey,
      ctrlKey,
      altKey,
      metaKey,
      controlOrMeta
    });
    return shortcut;
  }
};

// node_modules/js-draw/dist/mjs/shortcuts/KeyboardShortcutManager.mjs
var KeyboardShortcutManager = class _KeyboardShortcutManager {
  /**
   * Creates a new `ShortcutManager` with an initial set of shortcut overrides.
   *
   * @internal
   */
  constructor(initialOverrides) {
    this.shortcutOverrides = /* @__PURE__ */ Object.create(null);
    for (const id in initialOverrides) {
      this.overrideShortcut(id, initialOverrides[id]);
    }
  }
  /**
   * Override an existing shortcut with a custom set of triggers.
   * @internal
   */
  overrideShortcut(shortcutId, overrideWith) {
    this.shortcutOverrides[shortcutId] = [...overrideWith];
  }
  /** Returns true if `keyEvent` matches the shortcut with `shortcutId`. @internal */
  matchesShortcut(shortcutId, keyEvent) {
    let shortcutList = this.shortcutOverrides[shortcutId];
    if (!shortcutList) {
      if (shortcutId in _KeyboardShortcutManager.shortcuts) {
        shortcutList = _KeyboardShortcutManager.shortcuts[shortcutId];
      } else {
        throw new Error(`No shortcut with ID ${shortcutId} exists!`);
      }
    }
    for (const shortcut of shortcutList) {
      if (shortcut.matchesEvent(keyEvent)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Registers a default keyboard shortcut that can be overridden by individual instances
   * of `ShortcutManager`. Note that `id` should be a globally unique identifier.
   *
   * Only the first call to this method for a given `id` has an effect.
   *
   * @example
   * ```ts
   * const shortcutId = 'io.github.personalizedrefrigerator.js-draw.select-all';
   *
   * // Associate two shortcuts with the same ID
   * const shortcut1 = KeyBinding.fromString('ctrlOrMeta+a');
   * const shortcut2 = KeyBinding.fromString('ctrlOrMeta+shift+a');
   * KeyboardShortcutManager.registerDefaultKeyboardShortcut(
   * 	shortcutId,
   * 	[ shortcut1, shortcut2 ],
   * 	"Select All",
   * );
   *
   * // Provide a localized description
   * KeyboardShortcutManager.provideShortcutDescription(
   * 	shotcutId,
   * 	'es',
   * 	'Seleccionar todo',
   * );
   * ```
   *
   * @internal
   */
  static registerDefaultKeyboardShortcut(id, shortcuts, defaultDescription) {
    if (id in _KeyboardShortcutManager.shortcuts) {
      return false;
    }
    const shortcutsAsShortcuts = shortcuts.map((shortcut) => {
      if (typeof shortcut === "string") {
        return KeyBinding.fromString(shortcut);
      }
      return shortcut;
    });
    _KeyboardShortcutManager.shortcuts[id] = [...shortcutsAsShortcuts];
    _KeyboardShortcutManager.shortcutDefaultDescriptions[id] = defaultDescription;
    return true;
  }
  /** Provides a localized description of a keyboard shortcut. @internal */
  static provideShortcutDescription(id, locale, description) {
    if (!(locale in _KeyboardShortcutManager.shortcutLocalizedDescriptions)) {
      _KeyboardShortcutManager.shortcutLocalizedDescriptions[locale] = /* @__PURE__ */ Object.create(null);
    }
    _KeyboardShortcutManager.shortcutLocalizedDescriptions[locale][id] = description;
  }
  /**
   * Gets all registered keyboard shortcut IDs.
   *
   * @see {@link getShortcutDescription}
   */
  static getAllShortcutIds() {
    const ids = [];
    for (const id in this.shortcuts) {
      ids.push(id);
    }
    return ids;
  }
  /**
   * Get the default keybindings associated with a keyboard shortcut.
   *
   * Any keybinding in the resultant list, by default, can trigger the function associated
   * with the shortcut.
   */
  static getShortcutDefaultKeybindings(shortcutId) {
    if (!(shortcutId in _KeyboardShortcutManager.shortcuts)) {
      throw new Error(`No shortcut with ID ${shortcutId} exists!`);
    }
    return _KeyboardShortcutManager.shortcuts[shortcutId];
  }
  /**
   * Get a description of a keyboard shortcut.
   *
   * `localeList`, if given, attempts to
   */
  static getShortcutDescription(id, localeList) {
    const localizationTable = matchingLocalizationTable(localeList ?? [], this.shortcutLocalizedDescriptions, this.shortcutDefaultDescriptions);
    return localizationTable[id] ?? this.shortcutDefaultDescriptions[id] ?? null;
  }
};
KeyboardShortcutManager.shortcuts = /* @__PURE__ */ Object.create(null);
KeyboardShortcutManager.shortcutDefaultDescriptions = /* @__PURE__ */ Object.create(null);
KeyboardShortcutManager.shortcutLocalizedDescriptions = /* @__PURE__ */ Object.create(null);
var KeyboardShortcutManager_default = KeyboardShortcutManager;

// node_modules/js-draw/dist/mjs/tools/SelectionTool/keybindings.mjs
var selectAllKeyboardShortcut = "jsdraw.tools.SelectionTool.selectAll";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(selectAllKeyboardShortcut, ["CtrlOrMeta+KeyA"], "Select all");
var duplicateSelectionShortcut = "jsdraw.tools.SelectionTool.duplicateSelection";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(duplicateSelectionShortcut, ["CtrlOrMeta+KeyD"], "Duplicate selection");
var sendToBackSelectionShortcut = "jsdraw.tools.SelectionTool.sendToBack";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(sendToBackSelectionShortcut, ["End"], "Send to back");
var translateLeftSelectionShortcutId = "jsdraw.tools.SelectionTool.translateLeft";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateLeftSelectionShortcutId, ["KeyA", "KeyH", "ArrowLeft"], "Move selection left");
var translateRightSelectionShortcutId = "jsdraw.tools.SelectionTool.translateRight";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateRightSelectionShortcutId, ["KeyD", "KeyL", "ArrowRight"], "Move selection right");
var translateUpSelectionShortcutId = "jsdraw.tools.SelectionTool.translateUp";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateUpSelectionShortcutId, ["KeyQ", "KeyK", "ArrowUp"], "Move selection up");
var translateDownSelectionShortcutId = "jsdraw.tools.SelectionTool.translateDown";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(translateDownSelectionShortcutId, ["KeyE", "KeyJ", "ArrowDown"], "Move selection down");
var rotateCounterClockwiseSelectionShortcutId = "jsdraw.tools.SelectionTool.rotateCCW";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateCounterClockwiseSelectionShortcutId, ["Shift+KeyR"], "Rotate selection counter clockwise");
var rotateClockwiseSelectionShortcutId = "jsdraw.tools.SelectionTool.rotateCW";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateClockwiseSelectionShortcutId, ["KeyR"], "Rotate selection clockwise");
var shrinkXSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.x";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(shrinkXSelectionShortcutId, ["KeyI"], "Decrease width");
var stretchXSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.x";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(stretchXSelectionShortcutId, ["Shift+KeyI"], "Increase width");
var shrinkYSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.y";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(shrinkYSelectionShortcutId, ["KeyO"], "Decrease height");
var stretchYSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.y";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(stretchYSelectionShortcutId, ["Shift+KeyO"], "Increase height");
var shrinkXYSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.xy";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(shrinkXYSelectionShortcutId, ["Comma"], "Decrease selection size");
var stretchXYSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.xy";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(stretchXYSelectionShortcutId, ["Period"], "Increase selection size");

// node_modules/js-draw/dist/mjs/tools/keybindings.mjs
var undoKeyboardShortcutId = "jsdraw.tools.undo";
var redoKeyboardShortcutId = "jsdaw.tools.redo";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(undoKeyboardShortcutId, ["CtrlOrMeta+KeyZ"], "Undo");
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(redoKeyboardShortcutId, ["CtrlOrMeta+Shift+KeyZ", "CtrlOrMeta+KeyY"], "Redo");
var increaseSizeKeyboardShortcutId = "jsdraw.tools.increaseSize";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(increaseSizeKeyboardShortcutId, ["Equal", "Shift+Equal"], "Increase pen/eraser size");
var decreaseSizeKeyboardShortcutId = "jsdraw.tools.decreaseSize";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(decreaseSizeKeyboardShortcutId, ["Minus", "Shift+Minus"], "Decrease pen/eraser size");
var snapToGridKeyboardShortcutId = "jsdraw.tools.snapToGrid";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(snapToGridKeyboardShortcutId, ["Control", "Meta"], "Snap to grid (press and hold)");
var lineLockKeyboardShortcutId = "jsdraw.tools.lockToLine";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(lineLockKeyboardShortcutId, ["Shift"], "Snap to XY axes (press and hold)");
var toggleFindVisibleShortcutId = "js-draw.tools.FindTool.toggleVisible";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(toggleFindVisibleShortcutId, ["CtrlOrMeta+KeyF"], "Shows/hides the find tool");
var moveLeftKeyboardShortcutId = "jsdraw.tools.PanZoom.moveLeft";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveLeftKeyboardShortcutId, ["ArrowLeft", "KeyH", "KeyA"], "Pan left");
var moveRightKeyboardShortcutId = "jsdraw.tools.PanZoom.moveRight";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveRightKeyboardShortcutId, ["ArrowRight", "KeyL", "KeyD"], "Pan right");
var moveUpKeyboardShortcutId = "jsdraw.tools.PanZoom.moveUp";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveUpKeyboardShortcutId, ["ArrowUp", "KeyK", "KeyQ"], "Pan up");
var moveDownKeyboardShortcutId = "jsdraw.tools.PanZoom.moveDown";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(moveDownKeyboardShortcutId, ["ArrowDown", "KeyJ", "KeyE"], "Pan down");
var rotateClockwiseKeyboardShortcutId = "jsdraw.tools.PanZoom.rotateViewClockwise";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateClockwiseKeyboardShortcutId, ["Shift+KeyR"], "Rotate viewport clockwise");
var rotateCounterClockwiseKeyboardShortcutId = "jsdraw.tools.PanZoom.rotateViewCounterClockwise";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(rotateCounterClockwiseKeyboardShortcutId, ["KeyR"], "Rotate viewport counter-clockwise");
var zoomInKeyboardShortcutId = "jsdraw.tools.PanZoom.zoomIn";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(zoomInKeyboardShortcutId, ["KeyW"], "Zoom in");
var zoomOutKeyboardShortcutId = "jsdraw.tools.PanZoom.zoomOut";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(zoomOutKeyboardShortcutId, ["KeyS"], "Zoom out");

// node_modules/js-draw/dist/mjs/tools/PanZoom.mjs
var PanZoomMode;
(function(PanZoomMode2) {
  PanZoomMode2[PanZoomMode2["OneFingerTouchGestures"] = 1] = "OneFingerTouchGestures";
  PanZoomMode2[PanZoomMode2["TwoFingerTouchGestures"] = 2] = "TwoFingerTouchGestures";
  PanZoomMode2[PanZoomMode2["RightClickDrags"] = 4] = "RightClickDrags";
  PanZoomMode2[PanZoomMode2["SinglePointerGestures"] = 8] = "SinglePointerGestures";
  PanZoomMode2[PanZoomMode2["Keyboard"] = 16] = "Keyboard";
  PanZoomMode2[PanZoomMode2["RotationLocked"] = 32] = "RotationLocked";
})(PanZoomMode || (PanZoomMode = {}));
var InertialScroller = class {
  constructor(initialVelocity, scrollBy, onComplete) {
    this.initialVelocity = initialVelocity;
    this.scrollBy = scrollBy;
    this.onComplete = onComplete;
    this.running = false;
    this.start();
  }
  async start() {
    if (this.running) {
      return;
    }
    this.currentVelocity = this.initialVelocity;
    let lastTime = performance.now();
    this.running = true;
    const maxSpeed = 5e3;
    const minSpeed = 200;
    if (this.currentVelocity.magnitude() > maxSpeed) {
      this.currentVelocity = this.currentVelocity.normalized().times(maxSpeed);
    }
    while (this.running && this.currentVelocity.magnitude() > minSpeed) {
      const nowTime = performance.now();
      const dt = (nowTime - lastTime) / 1e3;
      this.currentVelocity = this.currentVelocity.times(Math.pow(1 / 8, dt));
      this.scrollBy(this.currentVelocity.times(dt));
      await untilNextAnimationFrame_default();
      lastTime = nowTime;
    }
    if (this.running) {
      this.stop();
    }
  }
  getCurrentVelocity() {
    if (!this.running) {
      return null;
    }
    return this.currentVelocity;
  }
  stop() {
    if (this.running) {
      this.running = false;
      this.onComplete();
    }
  }
};
var PanZoom = class extends BaseTool_default {
  constructor(editor, mode, description) {
    super(editor.notifier, description);
    this.editor = editor;
    this.mode = mode;
    this.transform = null;
    this.initialRotationSnapAngle = 0.22;
    this.afterRotationStartSnapAngle = 0.07;
    this.pinchZoomStartThreshold = 1.08;
    this.lastPointerDownTimestamp = 0;
    this.initialTouchAngle = 0;
    this.initialViewportRotation = 0;
    this.initialViewportScale = 0;
    this.isScaling = false;
    this.isRotating = false;
    this.inertialScroller = null;
    this.velocity = null;
  }
  // The pan/zoom tool can be used in a read-only editor.
  canReceiveInputInReadOnlyEditor() {
    return true;
  }
  // Returns information about the pointers in a gesture
  computePinchData(p1, p2) {
    if (p1.id < p2.id) {
      const tmp = p1;
      p1 = p2;
      p2 = tmp;
    }
    const screenBetween = p2.screenPos.minus(p1.screenPos);
    const angle = screenBetween.angle();
    const dist = screenBetween.magnitude();
    const canvasCenter = p2.canvasPos.plus(p1.canvasPos).times(0.5);
    const screenCenter = p2.screenPos.plus(p1.screenPos).times(0.5);
    return { canvasCenter, screenCenter, angle, dist };
  }
  allPointersAreOfType(pointers, kind) {
    return pointers.every((pointer) => pointer.device === kind);
  }
  onPointerDown({ allPointers: pointers, current: currentPointer }) {
    var _a6, _b2;
    let handlingGesture = false;
    const inertialScrollerVelocity = ((_a6 = this.inertialScroller) == null ? void 0 : _a6.getCurrentVelocity()) ?? Vec2.zero;
    (_b2 = this.inertialScroller) == null ? void 0 : _b2.stop();
    this.velocity = inertialScrollerVelocity;
    this.lastPointerDownTimestamp = currentPointer.timeStamp;
    const allAreTouch = this.allPointersAreOfType(pointers, PointerDevice.Touch);
    const isRightClick = this.allPointersAreOfType(pointers, PointerDevice.RightButtonMouse);
    if (allAreTouch && pointers.length === 2 && this.mode & PanZoomMode.TwoFingerTouchGestures) {
      const { screenCenter, angle, dist } = this.computePinchData(pointers[0], pointers[1]);
      this.lastTouchDist = dist;
      this.startTouchDist = dist;
      this.lastScreenCenter = screenCenter;
      this.initialTouchAngle = angle;
      this.initialViewportRotation = this.editor.viewport.getRotationAngle();
      this.initialViewportScale = this.editor.viewport.getScaleFactor();
      this.isScaling = false;
      this.isRotating = Math.abs(Math.sin(this.initialViewportRotation * 2)) > 1e-3;
      handlingGesture = true;
    } else if (pointers.length === 1 && (this.mode & PanZoomMode.OneFingerTouchGestures && allAreTouch || isRightClick && this.mode & PanZoomMode.RightClickDrags || this.mode & PanZoomMode.SinglePointerGestures)) {
      this.lastScreenCenter = pointers[0].screenPos;
      this.isScaling = false;
      handlingGesture = true;
    }
    if (handlingGesture) {
      this.lastTimestamp = performance.now();
      this.transform ?? (this.transform = Viewport.transformBy(Mat33.identity));
      this.editor.display.setDraftMode(true);
    }
    return handlingGesture;
  }
  updateVelocity(currentCenter) {
    const deltaPos = currentCenter.minus(this.lastScreenCenter);
    let deltaTime = (performance.now() - this.lastTimestamp) / 1e3;
    if (deltaPos.magnitude() === 0 && deltaTime < 0.1) {
      return;
    }
    if (deltaTime === 0) {
      return;
    }
    deltaTime = Math.max(deltaTime, 0.01);
    const currentVelocity = deltaPos.times(1 / deltaTime);
    let smoothedVelocity = currentVelocity;
    if (this.velocity) {
      smoothedVelocity = this.velocity.lerp(currentVelocity, 0.5);
    }
    this.velocity = smoothedVelocity;
  }
  // Returns the change in position of the center of the given group of pointers.
  // Assumes this.lastScreenCenter has been set appropriately.
  getCenterDelta(screenCenter) {
    const delta = this.editor.viewport.screenToCanvasTransform.transformVec3(screenCenter.minus(this.lastScreenCenter));
    return delta;
  }
  //  Snaps `angle` to common desired rotations. For example, if `touchAngle` corresponds
  // to a viewport rotation of 90.1 degrees, this function returns a rotation delta that,
  // when applied to the viewport, rotates the viewport to 90.0 degrees.
  //
  // Returns a snapped rotation delta that, when applied to the viewport, rotates the viewport,
  // from its position on the last touchDown event, by `touchAngle - initialTouchAngle`.
  toSnappedRotationDelta(touchAngle) {
    const deltaAngle = touchAngle - this.initialTouchAngle;
    let fullRotation = deltaAngle + this.initialViewportRotation;
    const snapToMultipleOf = Math.PI / 2;
    const roundedFullRotation = Math.round(fullRotation / snapToMultipleOf) * snapToMultipleOf;
    const maxSnapAngle = this.isRotating ? this.afterRotationStartSnapAngle : this.initialRotationSnapAngle;
    if (Math.abs(fullRotation - roundedFullRotation) < maxSnapAngle) {
      fullRotation = roundedFullRotation;
      if (fullRotation !== 0) {
        fullRotation += 1e-4;
      }
    }
    return fullRotation - this.editor.viewport.getRotationAngle();
  }
  /**
   * Given a scale update, `scaleFactor`, returns a new scale factor snapped
   * to a power of two (if within some tolerance of that scale).
   */
  toSnappedScaleFactor(touchDist) {
    const newScale = this.initialViewportScale * touchDist / this.startTouchDist;
    const currentScale = this.editor.viewport.getScaleFactor();
    const logNewScale = Math.log(newScale) / Math.log(10);
    const roundedLogNewScale = Math.round(logNewScale);
    const logTolerance = 0.04;
    if (Math.abs(roundedLogNewScale - logNewScale) < logTolerance) {
      return Math.pow(10, roundedLogNewScale) / currentScale;
    }
    return touchDist / this.lastTouchDist;
  }
  handleTwoFingerMove(allPointers) {
    const { screenCenter, canvasCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);
    const delta = this.getCenterDelta(screenCenter);
    let deltaRotation;
    if (this.isRotationLocked()) {
      deltaRotation = 0;
    } else {
      deltaRotation = this.toSnappedRotationDelta(angle);
    }
    if (Math.abs(deltaRotation) > 1e-8) {
      this.isRotating = true;
    }
    this.updateVelocity(screenCenter);
    if (!this.isScaling) {
      const initialScaleFactor = dist / this.startTouchDist;
      const upperBound = this.pinchZoomStartThreshold;
      const lowerBound = 1 / this.pinchZoomStartThreshold;
      if (initialScaleFactor > upperBound || initialScaleFactor < lowerBound) {
        this.isScaling = true;
      }
    }
    let scaleFactor = 1;
    if (this.isScaling) {
      scaleFactor = this.toSnappedScaleFactor(dist);
      this.lastTouchDist = dist;
    }
    const transformUpdate = Mat33.translation(delta).rightMul(Mat33.scaling2D(scaleFactor, canvasCenter)).rightMul(Mat33.zRotation(deltaRotation, canvasCenter));
    this.lastScreenCenter = screenCenter;
    this.transform = Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));
    return transformUpdate;
  }
  handleOneFingerMove(pointer) {
    const delta = this.getCenterDelta(pointer.screenPos);
    const transformUpdate = Mat33.translation(delta);
    this.transform = Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));
    this.updateVelocity(pointer.screenPos);
    this.lastScreenCenter = pointer.screenPos;
    return transformUpdate;
  }
  onPointerMove({ allPointers }) {
    this.transform ?? (this.transform = Viewport.transformBy(Mat33.identity));
    let transformUpdate = Mat33.identity;
    if (allPointers.length === 2) {
      transformUpdate = this.handleTwoFingerMove(allPointers);
    } else if (allPointers.length === 1) {
      transformUpdate = this.handleOneFingerMove(allPointers[0]);
    }
    Viewport.transformBy(transformUpdate).apply(this.editor);
    this.lastTimestamp = performance.now();
  }
  onPointerUp(event) {
    var _a6;
    const onComplete = () => {
      if (this.transform) {
        this.transform.unapply(this.editor);
        this.editor.dispatch(this.transform, false);
      }
      this.editor.display.setDraftMode(false);
      this.transform = null;
      this.velocity = Vec2.zero;
    };
    const minInertialScrollDt = 30;
    const shouldInertialScroll = event.current.device === PointerDevice.Touch && event.allPointers.length === 1 && this.velocity !== null && event.current.timeStamp - this.lastPointerDownTimestamp > minInertialScrollDt;
    if (shouldInertialScroll && this.velocity !== null) {
      const oldVelocity = this.velocity;
      this.updateVelocity(event.current.screenPos);
      if (oldVelocity.magnitude() < this.velocity.magnitude()) {
        this.velocity = oldVelocity;
      }
      (_a6 = this.inertialScroller) == null ? void 0 : _a6.stop();
      this.inertialScroller = new InertialScroller(this.velocity, (scrollDelta) => {
        if (!this.transform) {
          return;
        }
        const canvasDelta = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollDelta);
        this.transform.unapply(this.editor);
        this.transform = Viewport.transformBy(this.transform.transform.rightMul(Mat33.translation(canvasDelta)));
        this.transform.apply(this.editor);
      }, onComplete);
    } else {
      onComplete();
    }
  }
  onGestureCancel() {
    var _a6, _b2;
    (_a6 = this.inertialScroller) == null ? void 0 : _a6.stop();
    this.velocity = Vec2.zero;
    (_b2 = this.transform) == null ? void 0 : _b2.unapply(this.editor);
    this.editor.display.setDraftMode(false);
    this.transform = null;
  }
  // Applies [transformUpdate] to the editor. This stacks on top of the
  // current transformation, if it exists.
  updateTransform(transformUpdate, announce = false) {
    var _a6;
    let newTransform = transformUpdate;
    if (this.transform) {
      newTransform = this.transform.transform.rightMul(transformUpdate);
    }
    (_a6 = this.transform) == null ? void 0 : _a6.unapply(this.editor);
    this.transform = Viewport.transformBy(newTransform);
    this.transform.apply(this.editor);
    if (announce) {
      this.editor.announceForAccessibility(this.transform.description(this.editor, this.editor.localization));
    }
  }
  /**
   * Updates the current transform and clears it. Use this method for events that are not part of
   * a larger gesture (i.e. have no start and end event). For example, this would be used for `onwheel`
   * events, but not for `onpointer` events.
   */
  applyAndFinalizeTransform(transformUpdate) {
    this.updateTransform(transformUpdate, true);
    this.transform = null;
  }
  onWheel({ delta, screenPos }) {
    var _a6;
    (_a6 = this.inertialScroller) == null ? void 0 : _a6.stop();
    this.transform = Viewport.transformBy(Mat33.identity);
    const canvasPos = this.editor.viewport.screenToCanvas(screenPos);
    const toCanvas = this.editor.viewport.screenToCanvasTransform;
    const translation = toCanvas.transformVec3(Vec3.of(-delta.x, -delta.y, 0));
    let pinchAmount = delta.z;
    pinchAmount = Math.atan(pinchAmount / 2) * 2;
    const pinchZoomScaleFactor = 1.04;
    const transformUpdate = Mat33.scaling2D(Math.max(0.4, Math.min(Math.pow(pinchZoomScaleFactor, -pinchAmount), 4)), canvasPos).rightMul(Mat33.translation(translation));
    this.applyAndFinalizeTransform(transformUpdate);
    return true;
  }
  onKeyPress(event) {
    var _a6;
    (_a6 = this.inertialScroller) == null ? void 0 : _a6.stop();
    if (!(this.mode & PanZoomMode.Keyboard)) {
      return false;
    }
    this.transform = Viewport.transformBy(Mat33.identity);
    let translation = Vec2.zero;
    let scale = 1;
    let rotation = 0;
    const shortcucts = this.editor.shortcuts;
    if (shortcucts.matchesShortcut(moveLeftKeyboardShortcutId, event)) {
      translation = Vec2.of(-1, 0);
    } else if (shortcucts.matchesShortcut(moveRightKeyboardShortcutId, event)) {
      translation = Vec2.of(1, 0);
    } else if (shortcucts.matchesShortcut(moveUpKeyboardShortcutId, event)) {
      translation = Vec2.of(0, -1);
    } else if (shortcucts.matchesShortcut(moveDownKeyboardShortcutId, event)) {
      translation = Vec2.of(0, 1);
    } else if (shortcucts.matchesShortcut(zoomInKeyboardShortcutId, event)) {
      scale = 1 / 2;
    } else if (shortcucts.matchesShortcut(zoomOutKeyboardShortcutId, event)) {
      scale = 2;
    } else if (shortcucts.matchesShortcut(rotateClockwiseKeyboardShortcutId, event)) {
      rotation = 1;
    } else if (shortcucts.matchesShortcut(rotateCounterClockwiseKeyboardShortcutId, event)) {
      rotation = -1;
    } else {
      return false;
    }
    translation = translation.times(30);
    rotation *= Math.PI / 8;
    translation = translation.times(-1);
    rotation = rotation * -1;
    scale = 1 / scale;
    if (rotation !== 0) {
      rotation += 1e-4;
    }
    if (this.isRotationLocked()) {
      rotation = 0;
    }
    const toCanvas = this.editor.viewport.screenToCanvasTransform;
    translation = toCanvas.transformVec3(translation);
    const transformCenter = this.editor.viewport.visibleRect.center;
    const transformUpdate = Mat33.scaling2D(scale, transformCenter).rightMul(Mat33.zRotation(rotation, transformCenter)).rightMul(Mat33.translation(translation));
    this.applyAndFinalizeTransform(transformUpdate);
    return true;
  }
  isRotationLocked() {
    return !!(this.mode & PanZoomMode.RotationLocked);
  }
  /**
   * Changes the types of gestures used by this pan/zoom tool.
   *
   * @see {@link PanZoomMode} {@link setMode}
   *
   * @example
   * ```ts,runnable
   * import { Editor, PanZoomTool, PanZoomMode } from 'js-draw';
   *
   * const editor = new Editor(document.body);
   *
   * // By default, there are multiple PanZoom tools that handle different events.
   * // This gets all PanZoomTools.
   * const panZoomToolList = editor.toolController.getMatchingTools(PanZoomTool);
   *
   * // The first PanZoomTool is the highest priority -- by default,
   * // this tool is responsible for handling multi-finger touch gestures.
   * //
   * // Lower-priority PanZoomTools handle one-finger touch gestures and
   * // key-presses.
   * const panZoomTool = panZoomToolList[0];
   *
   * // Lock rotation for multi-finger touch gestures.
   * panZoomTool.setModeEnabled(PanZoomMode.RotationLocked, true);
   * ```
   */
  setModeEnabled(mode, enabled) {
    let newMode = this.mode;
    if (enabled) {
      newMode |= mode;
    } else {
      newMode &= ~mode;
    }
    this.setMode(newMode);
  }
  /**
   * Sets all modes for this tool using a bitmask.
   *
   * @see {@link setModeEnabled}
   *
   * @example
   * ```ts
   * tool.setMode(PanZoomMode.RotationLocked|PanZoomMode.TwoFingerTouchGestures);
   * ```
   */
  setMode(mode) {
    if (mode !== this.mode) {
      this.mode = mode;
      this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
        kind: EditorEventType.ToolUpdated,
        tool: this
      });
    }
  }
  /**
   * Returns a bitmask indicating the currently-enabled modes.
   * @see {@link setModeEnabled}
   */
  getMode() {
    return this.mode;
  }
};

// node_modules/js-draw/dist/mjs/rendering/RenderingStyle.mjs
var cloneStyle = (style) => {
  return {
    fill: style.fill,
    stroke: style.stroke ? {
      ...style.stroke
    } : void 0
  };
};
var stylesEqual = (a, b) => {
  var _a6, _b2, _c2, _d, _e;
  const result = a === b || a.fill.eq(b.fill) && a.stroke == void 0 === (b.stroke == void 0) && (((_c2 = (_a6 = a.stroke) == null ? void 0 : _a6.color) == null ? void 0 : _c2.eq((_b2 = b.stroke) == null ? void 0 : _b2.color)) ?? true) && ((_d = a.stroke) == null ? void 0 : _d.width) === ((_e = b.stroke) == null ? void 0 : _e.width);
  return result ?? false;
};
var styleToJSON = (style) => {
  const stroke = !style.stroke ? void 0 : {
    color: style.stroke.color.toHexString(),
    width: style.stroke.width
  };
  return {
    fill: style.fill.toHexString(),
    stroke
  };
};
var styleFromJSON = (json) => {
  const stroke = json.stroke ? {
    color: Color4.fromHex(json.stroke.color),
    width: json.stroke.width
  } : void 0;
  return {
    fill: Color4.fromHex(json.fill),
    stroke
  };
};

// node_modules/js-draw/dist/mjs/rendering/TextRenderingStyle.mjs
var cloneTextStyle = (style) => {
  return {
    ...style,
    renderingStyle: cloneStyle(style.renderingStyle)
  };
};
var textStyleFromJSON = (json) => {
  if (typeof json === "string") {
    json = JSON.parse(json);
  }
  if (typeof json.fontFamily !== "string") {
    throw new Error("Serialized textStyle missing string fontFamily attribute!");
  }
  const style = {
    renderingStyle: styleFromJSON(json.renderingStyle),
    size: json.size,
    fontWeight: json.fontWeight,
    fontVariant: json.fontVariant,
    fontFamily: json.fontFamily
  };
  return style;
};
var textStyleToJSON = (style) => {
  return {
    ...style,
    renderingStyle: styleToJSON(style.renderingStyle)
  };
};

// node_modules/js-draw/dist/mjs/components/RestylableComponent.mjs
var serializeComponentStyle = (style) => {
  const result = {};
  if (style.color) {
    result.color = style.color.toHexString();
  }
  if (style.textStyle) {
    result.textStyle = textStyleToJSON(style.textStyle);
  }
  return result;
};
var deserializeComponentStyle = (json) => {
  const color = json.color ? Color4.fromHex(json.color) : void 0;
  const textStyle = json.textStyle ? textStyleFromJSON(json.textStyle) : void 0;
  return {
    color,
    textStyle
  };
};
var createRestyleComponentCommand = (initialStyle, newStyle, component) => {
  return new DefaultRestyleComponentCommand(initialStyle, newStyle, component.getId(), component);
};
var isRestylableComponent = (component) => {
  const hasMethods = "getStyle" in component && "updateStyle" in component && "forceStyle" in component;
  if (!hasMethods) {
    return false;
  }
  if (!("isRestylableComponent" in component) || !component["isRestylableComponent"]) {
    return false;
  }
  return true;
};
var defaultRestyleComponentCommandId = "default-restyle-element";
var DefaultRestyleComponentCommand = class extends UnresolvedSerializableCommand {
  constructor(originalStyle, newStyle, componentID, component) {
    super(defaultRestyleComponentCommandId, componentID, component);
    this.originalStyle = originalStyle;
    this.newStyle = newStyle;
  }
  getComponent(editor) {
    this.resolveComponent(editor.image);
    const component = this.component;
    if (!component || !component["forceStyle"] || !component["updateStyle"]) {
      throw new Error("this.component is missing forceStyle and/or updateStyle methods!");
    }
    return component;
  }
  apply(editor) {
    this.getComponent(editor).forceStyle(this.newStyle, editor);
  }
  unapply(editor) {
    this.getComponent(editor).forceStyle(this.originalStyle, editor);
  }
  description(editor, localizationTable) {
    return localizationTable.restyledElement(this.getComponent(editor).description(localizationTable));
  }
  serializeToJSON() {
    return {
      id: this.componentID,
      originalStyle: serializeComponentStyle(this.originalStyle),
      newStyle: serializeComponentStyle(this.newStyle)
    };
  }
};
(() => {
  SerializableCommand_default.register(defaultRestyleComponentCommandId, (json, _editor) => {
    const origStyle = deserializeComponentStyle(json.originalStyle);
    const newStyle = deserializeComponentStyle(json.newStyle);
    const id = json.id;
    if (typeof json.id !== "string") {
      throw new Error(`json.id is of type ${typeof json.id}, not string.`);
    }
    return new DefaultRestyleComponentCommand(origStyle, newStyle, id);
  });
})();

// node_modules/js-draw/dist/mjs/rendering/RenderablePathSpec.mjs
var pathFromRenderable = (renderable) => {
  if (renderable.path) {
    return renderable.path;
  }
  return new Path(renderable.startPoint, renderable.commands);
};
var pathToRenderable = (path, style) => {
  return {
    startPoint: path.startPoint,
    style,
    commands: path.parts,
    path
  };
};
var pathIncluded = (renderablePath, path) => {
  if (renderablePath.path) {
    return renderablePath;
  }
  return {
    ...renderablePath,
    path
  };
};
var simplifyPathToFullScreenOrEmpty = (renderablePath, visibleRect, options = {
  fastCheck: true,
  expensiveCheck: true
}) => {
  var _a6;
  const path = pathFromRenderable(renderablePath);
  const strokeWidth = ((_a6 = renderablePath.style.stroke) == null ? void 0 : _a6.width) ?? 0;
  const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;
  const styledPathBBox = path.bbox.grownBy(strokeWidth);
  const isOnlyStrokedAndCouldFillScreen = onlyStroked && strokeWidth > visibleRect.maxDimension && styledPathBBox.containsRect(visibleRect);
  if (options.fastCheck && isOnlyStrokedAndCouldFillScreen && renderablePath.style.stroke) {
    const strokeRadius = strokeWidth / 2;
    for (const point of path.startEndPoints()) {
      if (visibleRect.isWithinRadiusOf(strokeRadius, point)) {
        return {
          rectangle: visibleRect,
          path: pathToRenderable(Path.fromRect(visibleRect), {
            fill: renderablePath.style.stroke.color
          }),
          fullScreen: true
        };
      }
    }
  }
  if (options.expensiveCheck && isOnlyStrokedAndCouldFillScreen && renderablePath.style.stroke && strokeWidth > visibleRect.maxDimension * 3) {
    const signedDist = path.signedDistance(visibleRect.center, strokeWidth / 2);
    const margin = strokeWidth / 6;
    if (signedDist < -visibleRect.maxDimension / 2 - margin) {
      return {
        path: pathToRenderable(Path.fromRect(visibleRect), {
          fill: renderablePath.style.stroke.color
        }),
        rectangle: visibleRect,
        fullScreen: true
      };
    } else if (signedDist > visibleRect.maxDimension / 2 + margin) {
      return {
        path: pathToRenderable(Path.empty, { fill: Color4.transparent }),
        rectangle: Rect2.empty,
        fullScreen: false
      };
    }
  }
  return null;
};
var visualEquivalent = (renderablePath, visibleRect) => {
  var _a6;
  const path = pathFromRenderable(renderablePath);
  const strokeWidth = ((_a6 = renderablePath.style.stroke) == null ? void 0 : _a6.width) ?? 0;
  const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;
  const styledPathBBox = path.bbox.grownBy(strokeWidth);
  let rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {
    fastCheck: true,
    expensiveCheck: false
  });
  if (rectangleSimplification) {
    return rectangleSimplification.path;
  }
  const expandedRect = visibleRect.grownBy(strokeWidth).transformedBoundingBox(Mat33.scaling2D(4, visibleRect.center));
  if (expandedRect.containsRect(styledPathBBox)) {
    return pathIncluded(renderablePath, path);
  }
  const parts = [];
  let startPoint = path.startPoint;
  for (const part of path.parts) {
    const partBBox = Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);
    let endPoint;
    if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {
      endPoint = part.point;
    } else {
      endPoint = part.endPoint;
    }
    const intersectsVisible = partBBox.intersects(visibleRect);
    if (intersectsVisible) {
      parts.push(part);
    } else if (onlyStroked || part.kind === PathCommandType.MoveTo) {
      parts.push({
        kind: PathCommandType.MoveTo,
        point: endPoint
      });
    } else {
      parts.push({
        kind: PathCommandType.LineTo,
        point: endPoint
      });
    }
    startPoint = endPoint;
  }
  const newPath = new Path(path.startPoint, parts);
  const newStyle = renderablePath.style;
  rectangleSimplification = simplifyPathToFullScreenOrEmpty(renderablePath, visibleRect, {
    fastCheck: false,
    expensiveCheck: true
  });
  if (rectangleSimplification) {
    return rectangleSimplification.path;
  }
  return pathToRenderable(newPath, newStyle);
};

// node_modules/js-draw/dist/mjs/components/Stroke.mjs
var Stroke = class _Stroke extends AbstractComponent_default {
  /**
   * Creates a `Stroke` from the given `parts`. All parts should have the
   * same color.
   *
   * @example
   * ```ts
   * // A path that starts at (1,1), moves to the right by (2, 0),
   * // then moves down and right by (3, 3)
   * const path = Path.fromString('m1,1 2,0 3,3');
   *
   * const stroke = new Stroke([
   *     // Fill with red
   *     pathToRenderable(path, { fill: Color4.red })
   * ]);
   * ```
   */
  constructor(parts, initialZIndex) {
    super("stroke", initialZIndex);
    this.isRestylableComponent = true;
    this.simplifiedPath = null;
    this.approximateRenderingTime = 0;
    this.parts = [];
    for (const section of parts) {
      const path = pathFromRenderable(section);
      const pathBBox = this.bboxForPart(path.bbox, section.style);
      if (!this.contentBBox) {
        this.contentBBox = pathBBox;
      } else {
        this.contentBBox = this.contentBBox.union(pathBBox);
      }
      this.parts.push({
        path,
        // To implement RenderablePathSpec
        startPoint: path.startPoint,
        style: section.style,
        commands: path.parts
      });
      this.approximateRenderingTime += path.parts.length;
    }
    this.contentBBox ?? (this.contentBBox = Rect2.empty);
  }
  /**
   * Creates a new `Stroke` from a {@link Path} and `style`. Strokes created
   * with this method have transparent fill.
   *
   * Example:
   * ```ts,runnable
   * import { Editor, Stroke, Color4 } from 'js-draw';
   * const editor = new Editor(document.body);
   * ---visible---
   * const stroke = Stroke.fromStroked('m0,0 l10,10', { width: 10, color: Color4.red });
   * editor.dispatch(editor.image.addComponent(stroke));
   * ```
   * Notice that `path` can be a string that specifies an SVG path
   *
   * @see fromFilled
   */
  static fromStroked(path, style) {
    if (typeof path === "string") {
      path = Path.fromString(path);
    }
    return new _Stroke([pathToRenderable(path, { fill: Color4.transparent, stroke: style })]);
  }
  /** @see fromStroked */
  static fromFilled(path, fill) {
    if (typeof path === "string") {
      path = Path.fromString(path);
    }
    return new _Stroke([pathToRenderable(path, { fill })]);
  }
  getStyle() {
    if (this.parts.length === 0) {
      return {};
    }
    const firstPart = this.parts[0];
    if (firstPart.style.stroke === void 0 || firstPart.style.stroke.width === 0) {
      return {
        color: firstPart.style.fill
      };
    }
    return {
      color: firstPart.style.stroke.color
    };
  }
  updateStyle(style) {
    return createRestyleComponentCommand(this.getStyle(), style, this);
  }
  forceStyle(style, editor) {
    if (!style.color) {
      return;
    }
    this.parts = this.parts.map((part) => {
      const newStyle = {
        ...part.style,
        stroke: part.style.stroke ? {
          ...part.style.stroke
        } : void 0
      };
      if (newStyle.stroke && newStyle.stroke.width > 0) {
        newStyle.stroke.color = style.color;
      } else {
        newStyle.fill = style.color;
      }
      return {
        path: part.path,
        startPoint: part.startPoint,
        commands: part.commands,
        style: newStyle
      };
    });
    if (editor) {
      editor.image.queueRerenderOf(this);
      editor.queueRerender();
    }
  }
  /** @beta -- May fail for concave `path`s */
  withRegionErased(eraserPath, viewport) {
    const polyline = eraserPath.polylineApproximation();
    const isPointInsideEraser = (point) => {
      return eraserPath.closedContainsPoint(point);
    };
    const newStrokes = [];
    let failedAssertions = false;
    for (const part of this.parts) {
      const path = part.path;
      const makeStroke = (path2) => {
        if (part.style.fill.a > 0) {
          if (path2.parts.length < 1 || path2.parts.length === 1 && path2.parts[0].kind === PathCommandType.LineTo) {
            return null;
          } else {
            path2 = path2.asClosed();
          }
        }
        if (isNaN(path2.getExactBBox().area)) {
          console.warn("Prevented creating a stroke with NaN area");
          failedAssertions = true;
          return null;
        }
        return new _Stroke([pathToRenderable(path2, part.style)], this.getZIndex());
      };
      const intersectionPoints = [];
      for (const segment of polyline) {
        intersectionPoints.push(...path.intersection(segment));
      }
      let isErasingFromEdge = false;
      if (intersectionPoints.length === 0 && part.style.stroke && part.style.stroke.width > eraserPath.bbox.minDimension * 0.3 && part.style.stroke.width < eraserPath.bbox.maxDimension * 30) {
        for (const segment of polyline) {
          intersectionPoints.push(...path.intersection(segment, part.style.stroke.width / 2));
        }
        isErasingFromEdge = true;
      }
      intersectionPoints.sort(compareCurveIndices);
      const isInsideJustBeforeFirst = (() => {
        if (intersectionPoints.length === 0) {
          return false;
        }
        if (isErasingFromEdge) {
          return intersectionPoints[0].curveIndex === 0 && intersectionPoints[0].parameterValue <= 0;
        }
        const justBeforeFirstIntersection = stepCurveIndexBy(intersectionPoints[0], -1e-10);
        return isPointInsideEraser(path.at(justBeforeFirstIntersection));
      })();
      let intersectionCount = isInsideJustBeforeFirst ? 1 : 0;
      const addNewPath = (path2, knownToBeInside) => {
        const component = makeStroke(path2);
        let isInside = intersectionCount % 2 === 1;
        intersectionCount++;
        if (knownToBeInside !== void 0) {
          isInside = knownToBeInside;
        }
        if (knownToBeInside === void 0 && !isInside && eraserPath.closedContainsPoint(path2.getExactBBox().center)) {
          isInside = !isInside;
        }
        if (!component) {
          return;
        }
        failedAssertions || (failedAssertions = isInside && path2.getExactBBox().maxDimension > eraserPath.getExactBBox().maxDimension * 2);
        if (!isInside) {
          newStrokes.push(component);
        }
      };
      if (part.style.fill.a === 0) {
        const shouldEraseCompletely = eraserPath.getExactBBox().maxDimension / 10 > path.getExactBBox().maxDimension;
        if (!shouldEraseCompletely) {
          const split = path.splitAt(intersectionPoints, {
            mapNewPoint: (p) => viewport.roundPoint(p)
          });
          for (const splitPart of split) {
            addNewPath(splitPart);
          }
        }
      } else if (intersectionPoints.length >= 2 && intersectionPoints.length % 2 === 0) {
        const parts = path.splitAt(intersectionPoints, {
          mapNewPoint: (p) => viewport.roundPoint(p)
        });
        for (let i = 0; i < Math.floor(parts.length / 2); i++) {
          addNewPath(parts[i].union(parts[parts.length - i - 1]).asClosed());
        }
        if (parts.length % 2 !== 0) {
          addNewPath(parts[Math.floor(parts.length / 2)].asClosed());
        }
      } else {
        addNewPath(path, false);
      }
    }
    if (failedAssertions) {
      return [this];
    }
    return newStrokes;
  }
  intersects(line) {
    var _a6;
    for (const part of this.parts) {
      const strokeWidth = (_a6 = part.style.stroke) == null ? void 0 : _a6.width;
      const strokeRadius = strokeWidth ? strokeWidth / 2 : void 0;
      if (part.path.intersection(line, strokeRadius).length > 0) {
        return true;
      }
    }
    return false;
  }
  keyPoints() {
    return this.parts.map((part) => {
      return part.startPoint;
    }).flat();
  }
  intersectsRect(rect) {
    var _a6;
    if (!rect.intersects(this.getBBox())) {
      return false;
    }
    for (const part of this.parts) {
      const interiorRect = rect.grownBy(-(((_a6 = part.style.stroke) == null ? void 0 : _a6.width) ?? 0));
      if (interiorRect.area === 0) {
        continue;
      }
      for (const point of part.path.startEndPoints()) {
        if (interiorRect.containsPoint(point)) {
          return true;
        }
      }
    }
    return super.intersectsRect(rect);
  }
  computeSimplifiedPathFor(visibleRect) {
    const simplifiedParts = [];
    let occludes = false;
    let skipSimplification = false;
    for (const part of this.parts) {
      if (skipSimplification || // Simplification currently only works for stroked paths
      !part.style.stroke || // One of the main purposes of this is to check for occlusion.
      // We can't occlude things if the stroke is partially transparent.
      part.style.stroke.color.a < 0.99) {
        simplifiedParts.push(part);
        continue;
      }
      const mapping = simplifyPathToFullScreenOrEmpty(part, visibleRect);
      if (mapping) {
        simplifiedParts.push(mapping.path);
        if (mapping.fullScreen) {
          occludes = true;
          skipSimplification = true;
        }
      } else {
        simplifiedParts.push(part);
      }
    }
    return {
      forVisibleRect: visibleRect,
      parts: simplifiedParts,
      occludes
    };
  }
  occludesEverythingBelowWhenRenderedInRect(rect) {
    if (!this.getBBox().containsRect(rect)) {
      return false;
    }
    if (!this.simplifiedPath || !this.simplifiedPath.forVisibleRect.eq(rect)) {
      this.simplifiedPath = this.computeSimplifiedPathFor(rect);
    }
    return this.simplifiedPath.occludes;
  }
  render(canvas, visibleRect) {
    var _a6, _b2, _c2;
    canvas.startObject(this.getBBox());
    let parts = this.parts;
    if (visibleRect && ((_b2 = (_a6 = this.simplifiedPath) == null ? void 0 : _a6.forVisibleRect) == null ? void 0 : _b2.containsRect(visibleRect))) {
      parts = this.simplifiedPath.parts;
    } else {
      this.simplifiedPath = null;
    }
    for (const part of parts) {
      const bbox = this.bboxForPart(part.path.bbox, part.style);
      if (visibleRect) {
        if (!bbox.intersects(visibleRect)) {
          continue;
        }
        const muchBiggerThanVisible = bbox.size.x > visibleRect.size.x * 3 || bbox.size.y > visibleRect.size.y * 3;
        if (muchBiggerThanVisible && !part.path.roughlyIntersects(visibleRect, ((_c2 = part.style.stroke) == null ? void 0 : _c2.width) ?? 0)) {
          continue;
        }
      }
      canvas.drawPath(part);
    }
    canvas.endObject(this.getLoadSaveData());
  }
  getProportionalRenderingTime() {
    return this.approximateRenderingTime;
  }
  // Grows the bounding box for a given stroke part based on that part's style.
  bboxForPart(origBBox, style) {
    if (!style.stroke) {
      return origBBox;
    }
    return origBBox.grownBy(style.stroke.width / 2);
  }
  getExactBBox() {
    let bbox = null;
    for (const { path, style } of this.parts) {
      const partBBox = this.bboxForPart(path.getExactBBox(), style);
      bbox ?? (bbox = partBBox);
      bbox = bbox.union(partBBox);
    }
    return bbox ?? Rect2.empty;
  }
  applyTransformation(affineTransfm) {
    this.contentBBox = Rect2.empty;
    let isFirstPart = true;
    this.parts = this.parts.map((part) => {
      const newPath = part.path.transformedBy(affineTransfm);
      const newStyle = {
        ...part.style,
        stroke: part.style.stroke ? {
          ...part.style.stroke
        } : void 0
      };
      if (newStyle.stroke) {
        const scaleFactor = affineTransfm.getScaleFactor();
        newStyle.stroke.width *= scaleFactor;
      }
      const newBBox = this.bboxForPart(newPath.bbox, newStyle);
      if (isFirstPart) {
        this.contentBBox = newBBox;
        isFirstPart = false;
      } else {
        this.contentBBox = this.contentBBox.union(newBBox);
      }
      return {
        path: newPath,
        startPoint: newPath.startPoint,
        commands: newPath.parts,
        style: newStyle
      };
    });
  }
  /**
   * @returns A list of the parts that make up this path. Many paths only have one part.
   *
   * Each part (a {@link RenderablePathSpec}) contains information about the style and geometry
   * of that part of the stroke. Use the `.path` property to do collision detection and other
   * operations involving the stroke's geometry.
   *
   * Note that many of {@link Path}'s methods (e.g. {@link Path.intersection}) take a
   * `strokeWidth` parameter that can be gotten from {@link RenderablePathSpec.style} `.stroke.width`.
   */
  getParts() {
    return [...this.parts];
  }
  /**
   * @returns the {@link Path.union} of all paths that make up this stroke.
   */
  getPath() {
    let result = null;
    for (const part of this.parts) {
      if (result) {
        result = result.union(part.path);
      } else {
        result ?? (result = part.path);
      }
    }
    return result ?? Path.empty;
  }
  description(localization4) {
    return localization4.stroke;
  }
  createClone() {
    return new _Stroke(this.parts);
  }
  serializeToJSON() {
    return this.parts.map((part) => {
      return {
        style: styleToJSON(part.style),
        path: part.path.serialize()
      };
    });
  }
  /** @internal */
  static deserializeFromJSON(json) {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    if (typeof json !== "object" || typeof json.length !== "number") {
      throw new Error(`${json} is missing required field, parts, or parts is of the wrong type.`);
    }
    const pathSpec = json.map((part) => {
      const style = styleFromJSON(part.style);
      return pathToRenderable(Path.fromString(part.path), style);
    });
    return new _Stroke(pathSpec);
  }
};
AbstractComponent_default.registerComponent("stroke", Stroke.deserializeFromJSON);

// node_modules/js-draw/dist/mjs/components/util/StrokeSmoother.mjs
var StrokeSmoother = class {
  constructor(startPoint, minFitAllowed, maxFitAllowed, onCurveAdded) {
    this.startPoint = startPoint;
    this.minFitAllowed = minFitAllowed;
    this.maxFitAllowed = maxFitAllowed;
    this.onCurveAdded = onCurveAdded;
    this.isFirstSegment = true;
    this.lastExitingVec = null;
    this.currentCurve = null;
    this.lastPoint = this.startPoint;
    this.buffer = [this.startPoint.pos];
    this.momentum = Vec2.zero;
    this.currentCurve = null;
    this.curveStartWidth = startPoint.width;
    this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
  }
  getBBox() {
    return this.bbox;
  }
  preview() {
    if (!this.currentCurve) {
      return null;
    }
    return this.currentSegmentToPath();
  }
  // Returns the distance between the start, control, and end points of the curve.
  approxCurrentCurveLength() {
    if (!this.currentCurve) {
      return 0;
    }
    const startPt = this.currentCurve.p0;
    const controlPt = this.currentCurve.p1;
    const endPt = this.currentCurve.p2;
    const toControlDist = startPt.distanceTo(controlPt);
    const toEndDist = endPt.distanceTo(controlPt);
    return toControlDist + toEndDist;
  }
  finalizeCurrentCurve() {
    if (!this.currentCurve) {
      return;
    }
    this.onCurveAdded(this.currentSegmentToPath());
    const lastPoint = this.buffer[this.buffer.length - 1];
    this.lastExitingVec = this.currentCurve.p2.minus(this.currentCurve.p1);
    console.assert(this.lastExitingVec.magnitude() !== 0, "lastExitingVec has zero length!");
    this.buffer = [this.buffer[this.buffer.length - 2], lastPoint];
    this.currentCurve = null;
    this.isFirstSegment = false;
  }
  // Returns [upper curve, connector, lower curve]
  currentSegmentToPath() {
    if (this.currentCurve == null) {
      throw new Error("Invalid State: currentCurve is null!");
    }
    const startVec = this.currentCurve.normal(0).normalized();
    if (!isFinite(startVec.magnitude())) {
      throw new Error(`startVec(${startVec}) is NaN or ∞`);
    }
    const startPt = this.currentCurve.at(0);
    const endPt = this.currentCurve.at(1);
    const controlPoint = this.currentCurve.p1;
    return {
      startPoint: startPt,
      controlPoint,
      endPoint: endPt,
      startWidth: this.curveStartWidth,
      endWidth: this.curveEndWidth
    };
  }
  // Compute the direction of the velocity at the end of this.buffer
  computeExitingVec() {
    return this.momentum.normalized().times(this.lastPoint.width / 2);
  }
  addPoint(newPoint) {
    if (this.lastPoint) {
      const fuzzEq = 1e-10;
      const deltaTime = newPoint.time - this.lastPoint.time;
      if (newPoint.pos.eq(this.lastPoint.pos, fuzzEq) || deltaTime === 0) {
        return;
      } else if (isNaN(newPoint.pos.magnitude())) {
        console.warn("Discarding NaN point.", newPoint);
        return;
      }
      const threshold = Math.min(this.lastPoint.width, newPoint.width) / 3;
      const shouldSnapToInitial = this.startPoint.pos.distanceTo(newPoint.pos) < threshold && this.isFirstSegment;
      if (shouldSnapToInitial) {
        return;
      }
      const deltaTimeSeconds = deltaTime / 1e3;
      const velocity = newPoint.pos.minus(this.lastPoint.pos).times(1 / deltaTimeSeconds);
      this.momentum = velocity;
    }
    const lastPoint = this.lastPoint ?? newPoint;
    this.lastPoint = newPoint;
    this.buffer.push(newPoint.pos);
    const pointRadius = newPoint.width;
    const prevEndWidth = this.curveEndWidth;
    this.curveEndWidth = pointRadius;
    this.bbox = this.bbox.grownToPoint(newPoint.pos, pointRadius);
    if (this.currentCurve === null) {
      const p1 = lastPoint.pos;
      const p2 = lastPoint.pos.plus(this.lastExitingVec ?? Vec2.unitX);
      const p3 = newPoint.pos;
      this.currentCurve = new QuadraticBezier(p1, p2, p3);
      console.assert(!isNaN(p1.magnitude()) && !isNaN(p2.magnitude()) && !isNaN(p3.magnitude()), "Expected !NaN");
      if (this.isFirstSegment) {
        this.curveStartWidth = (this.curveStartWidth + pointRadius) / 2;
      } else {
        this.curveStartWidth = prevEndWidth;
      }
    }
    let enteringVec = this.lastExitingVec;
    if (!enteringVec) {
      let sampleIdx = Math.ceil(this.buffer.length / 2);
      if (sampleIdx === 0 || sampleIdx >= this.buffer.length) {
        sampleIdx = this.buffer.length - 1;
      }
      enteringVec = this.buffer[sampleIdx].minus(this.buffer[0]);
    }
    let exitingVec = this.computeExitingVec();
    const maxRelativeLength = 1.7;
    const segmentStart = this.buffer[0];
    const segmentEnd = newPoint.pos;
    const startEndDist = segmentEnd.distanceTo(segmentStart);
    const maxControlPointDist = maxRelativeLength * startEndDist;
    if (maxControlPointDist === 0 || exitingVec.magnitude() === 0 || !isFinite(exitingVec.magnitude())) {
      return;
    }
    console.assert(isFinite(enteringVec.magnitude()), "Pre-normalized enteringVec has NaN or ∞ magnitude!");
    enteringVec = enteringVec.normalized();
    exitingVec = exitingVec.normalized();
    console.assert(isFinite(enteringVec.magnitude()), "Normalized enteringVec has NaN or ∞ magnitude!");
    const lineFromStart = new LineSegment2(segmentStart, segmentStart.plus(enteringVec.times(maxControlPointDist)));
    const lineFromEnd = new LineSegment2(segmentEnd.minus(exitingVec.times(maxControlPointDist)), segmentEnd);
    const intersection = lineFromEnd.intersection(lineFromStart);
    let controlPoint = null;
    if (intersection) {
      controlPoint = intersection.point;
    }
    if (!controlPoint) {
      controlPoint = segmentStart.lerp(segmentEnd, 0.5).lerp(segmentStart.plus(enteringVec.times(startEndDist)), 0.1);
    }
    if (segmentStart.eq(controlPoint) || segmentEnd.eq(controlPoint)) {
      controlPoint = segmentStart.plus(enteringVec.times(startEndDist / 5));
    }
    console.assert(!segmentStart.eq(controlPoint, 1e-11), "Start and control points are equal!");
    console.assert(!controlPoint.eq(segmentEnd, 1e-11), "Control and end points are equal!");
    const prevCurve = this.currentCurve;
    this.currentCurve = new QuadraticBezier(segmentStart, controlPoint, segmentEnd);
    if (isNaN(this.currentCurve.normal(0).magnitude())) {
      console.error("NaN normal at 0. Curve:", this.currentCurve);
      this.currentCurve = prevCurve;
    }
    const curveMatchesPoints = (curve) => {
      const minFit = Math.min(Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 4, this.minFitAllowed), this.maxFitAllowed);
      const maxNonMatchingDistSum = minFit;
      let nonMatchingDistSum = 0;
      for (const point of this.buffer) {
        let dist = curve.approximateDistance(point);
        if (dist > minFit) {
          dist = curve.distance(point);
          nonMatchingDistSum += Math.max(0, dist - minFit);
          if (nonMatchingDistSum > maxNonMatchingDistSum) {
            return false;
          }
        }
      }
      return true;
    };
    if (this.buffer.length > 3 && this.approxCurrentCurveLength() > this.curveStartWidth / 2) {
      if (!curveMatchesPoints(this.currentCurve)) {
        this.currentCurve = prevCurve;
        this.curveEndWidth = prevEndWidth;
        this.lastPoint = lastPoint;
        this.finalizeCurrentCurve();
        return;
      }
    }
  }
};
var StrokeSmoother_default = StrokeSmoother;

// node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeShapeFitAutocorrect.mjs
var makeShapeFitAutocorrect = (sourceFactory) => {
  return (startPoint, viewport) => {
    return new ShapeFitBuilder(sourceFactory, startPoint, viewport);
  };
};
var makeShapeFitAutocorrect_default = makeShapeFitAutocorrect;
var makeLineTemplate = (startPoint, points, _bbox) => {
  const templatePoints = [startPoint, points[points.length - 1]];
  return { points: templatePoints };
};
var makeRectangleTemplate = (_startPoint, _points, bbox) => {
  return { points: [...bbox.corners, bbox.corners[0]] };
};
var ShapeFitBuilder = class {
  constructor(sourceFactory, startPoint, viewport) {
    this.sourceFactory = sourceFactory;
    this.startPoint = startPoint;
    this.viewport = viewport;
    this.builder = sourceFactory(startPoint, viewport);
    this.points = [startPoint];
  }
  getBBox() {
    return this.builder.getBBox();
  }
  build() {
    return this.builder.build();
  }
  preview(renderer) {
    this.builder.preview(renderer);
  }
  addPoint(point) {
    this.points.push(point);
    this.builder.addPoint(point);
  }
  async autocorrectShape() {
    const startPoint = this.viewport.canvasToScreen(this.startPoint.pos);
    const points = this.points.map((point) => this.viewport.canvasToScreen(point.pos));
    const bbox = Rect2.bboxOf(points);
    const snappedStartPoint = this.viewport.canvasToScreen(this.viewport.snapToGrid(this.startPoint.pos));
    const snappedPoints = this.points.map((point) => this.viewport.canvasToScreen(this.viewport.snapToGrid(point.pos)));
    const snappedBBox = Rect2.bboxOf(snappedPoints);
    if (bbox.maxDimension < 32) {
      return null;
    }
    const maxError = Math.min(30, bbox.maxDimension / 4);
    const templates = [
      {
        ...makeLineTemplate(snappedStartPoint, snappedPoints, snappedBBox),
        toleranceMultiplier: 0.5
      },
      makeLineTemplate(startPoint, points, bbox),
      {
        ...makeRectangleTemplate(snappedStartPoint, snappedPoints, snappedBBox),
        toleranceMultiplier: 0.6
      },
      makeRectangleTemplate(startPoint, points, bbox)
    ];
    const selectTemplate = (maximumAllowedError) => {
      for (const template2 of templates) {
        const templatePoints = template2.points;
        const acceptMaximumSquareError = maximumAllowedError * maximumAllowedError * (template2.toleranceMultiplier ?? 1);
        const templateAt = (index) => {
          while (index < 0) {
            index += templatePoints.length;
          }
          index %= templatePoints.length;
          return templatePoints[index];
        };
        let closestToFirst = null;
        let closestToFirstSqrDist = Infinity;
        let templateStartIndex = 0;
        for (let i = 0; i < templatePoints.length; i++) {
          const current = templatePoints[i];
          const currentSqrDist = current.squareDistanceTo(startPoint);
          if (!closestToFirst || currentSqrDist < closestToFirstSqrDist) {
            closestToFirstSqrDist = currentSqrDist;
            closestToFirst = current;
            templateStartIndex = i;
          }
        }
        let maximumSqrError = 0;
        let templateIndex = templateStartIndex;
        for (const point of points) {
          let minimumCurrentSqrError = Infinity;
          let minimumErrorAtIndex = templateIndex;
          const windowRadius = 6;
          for (let i = -windowRadius; i <= windowRadius; i++) {
            const index = templateIndex + i;
            const prevTemplatePoint = templateAt(index - 1);
            const currentTemplatePoint = templateAt(index);
            const nextTemplatePoint = templateAt(index + 1);
            const prevToCurrent = new LineSegment2(prevTemplatePoint, currentTemplatePoint);
            const currentToNext = new LineSegment2(currentTemplatePoint, nextTemplatePoint);
            const prevToCurrentDist = prevToCurrent.distance(point);
            const nextToCurrentDist = currentToNext.distance(point);
            const error = Math.min(prevToCurrentDist, nextToCurrentDist);
            const squareError = error * error;
            if (squareError < minimumCurrentSqrError) {
              minimumCurrentSqrError = squareError;
              minimumErrorAtIndex = index;
            }
          }
          templateIndex = minimumErrorAtIndex;
          maximumSqrError = Math.max(minimumCurrentSqrError, maximumSqrError);
          if (maximumSqrError > acceptMaximumSquareError) {
            break;
          }
        }
        if (maximumSqrError < acceptMaximumSquareError) {
          return templatePoints;
        }
      }
      return null;
    };
    const template = selectTemplate(maxError);
    if (!template) {
      return null;
    }
    const lastDataPoint = this.points[this.points.length - 1];
    const startWidth = this.startPoint.width;
    const endWidth = lastDataPoint.width;
    const startColor = this.startPoint.color;
    const endColor = lastDataPoint.color;
    const startTime = this.startPoint.time;
    const endTime = lastDataPoint.time;
    const templateIndexToStrokeDataPoint = (index) => {
      const prevPoint = template[Math.max(0, Math.floor(index))];
      const nextPoint = template[Math.min(Math.ceil(index), template.length - 1)];
      const point = prevPoint.lerp(nextPoint, index - Math.floor(index));
      const fractionToEnd = index / template.length;
      return {
        pos: this.viewport.screenToCanvas(point),
        width: startWidth * (1 - fractionToEnd) + endWidth * fractionToEnd,
        color: startColor.mix(endColor, fractionToEnd),
        time: startTime * (1 - fractionToEnd) + endTime * fractionToEnd
      };
    };
    const builder = this.sourceFactory(templateIndexToStrokeDataPoint(0), this.viewport);
    const preventSmoothing = template.length < 10;
    for (let i = 0; i < template.length; i++) {
      if (preventSmoothing) {
        builder.addPoint(templateIndexToStrokeDataPoint(i - 1e-3));
      }
      builder.addPoint(templateIndexToStrokeDataPoint(i));
      if (preventSmoothing) {
        builder.addPoint(templateIndexToStrokeDataPoint(i + 1e-3));
      }
    }
    return builder.build();
  }
};

// node_modules/js-draw/dist/mjs/components/builders/FreehandLineBuilder.mjs
var makeFreehandLineBuilder = makeShapeFitAutocorrect_default((initialPoint, viewport) => {
  const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;
  const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();
  return new FreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);
});
var FreehandLineBuilder = class {
  constructor(startPoint, minFitAllowed, maxFitAllowed, viewport) {
    this.startPoint = startPoint;
    this.minFitAllowed = minFitAllowed;
    this.viewport = viewport;
    this.isFirstSegment = true;
    this.parts = [];
    this.widthAverageNumSamples = 1;
    this.curveFitter = new StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));
    this.averageWidth = startPoint.width;
    this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
  }
  getBBox() {
    return this.bbox;
  }
  getRenderingStyle() {
    return {
      fill: Color4.transparent,
      stroke: {
        color: this.startPoint.color,
        width: this.roundDistance(this.averageWidth)
      }
    };
  }
  previewCurrentPath() {
    const path = this.parts.slice();
    const commands = [...path, ...this.curveToPathCommands(this.curveFitter.preview())];
    const startPoint = this.startPoint.pos;
    return {
      startPoint,
      commands,
      style: this.getRenderingStyle()
    };
  }
  previewFullPath() {
    const preview = this.previewCurrentPath();
    if (preview) {
      return [preview];
    }
    return null;
  }
  previewStroke() {
    const pathPreview = this.previewFullPath();
    if (pathPreview) {
      return new Stroke(pathPreview);
    }
    return null;
  }
  preview(renderer) {
    const paths = this.previewFullPath();
    if (paths) {
      const approxBBox = this.viewport.visibleRect;
      renderer.startObject(approxBBox);
      for (const path of paths) {
        renderer.drawPath(path);
      }
      renderer.endObject();
    }
  }
  build() {
    this.curveFitter.finalizeCurrentCurve();
    return this.previewStroke();
  }
  getMinFit() {
    let minFit = Math.min(this.minFitAllowed, this.averageWidth / 3);
    if (minFit < 1e-10) {
      minFit = this.minFitAllowed;
    }
    return minFit;
  }
  roundPoint(point) {
    const minFit = this.getMinFit();
    return Viewport_default.roundPoint(point, minFit);
  }
  roundDistance(dist) {
    const minFit = this.getMinFit();
    return Viewport_default.roundPoint(dist, minFit);
  }
  curveToPathCommands(curve) {
    if (!curve) {
      if (!this.isFirstSegment) {
        return [];
      }
      const width = Viewport_default.roundPoint(this.averageWidth / 10, Math.min(this.minFitAllowed, this.averageWidth / 10));
      const center = this.roundPoint(this.startPoint.pos);
      return [
        {
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(width, width)),
          // Bottom of the circle
          //    |
          //  -----
          //    |
          //    ↑
          endPoint: center.plus(Vec2.of(0, width))
        },
        {
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(-width, width)),
          endPoint: center.plus(Vec2.of(-width, 0))
        },
        {
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(-width, -width)),
          endPoint: center.plus(Vec2.of(0, -width))
        },
        {
          kind: PathCommandType.QuadraticBezierTo,
          controlPoint: center.plus(Vec2.of(width, -width)),
          endPoint: center.plus(Vec2.of(width, 0))
        }
      ];
    }
    const result = [];
    if (this.isFirstSegment) {
      result.push({
        kind: PathCommandType.MoveTo,
        point: this.roundPoint(curve.startPoint)
      });
    }
    result.push({
      kind: PathCommandType.QuadraticBezierTo,
      controlPoint: this.roundPoint(curve.controlPoint),
      endPoint: this.roundPoint(curve.endPoint)
    });
    return result;
  }
  addCurve(curve) {
    const parts = this.curveToPathCommands(curve);
    this.parts.push(...parts);
    if (this.isFirstSegment) {
      this.isFirstSegment = false;
    }
  }
  addPoint(newPoint) {
    this.curveFitter.addPoint(newPoint);
    this.widthAverageNumSamples++;
    this.averageWidth = this.averageWidth * (this.widthAverageNumSamples - 1) / this.widthAverageNumSamples + newPoint.width / this.widthAverageNumSamples;
  }
};

// node_modules/js-draw/dist/mjs/tools/InputFilter/InputMapper.mjs
var __classPrivateFieldSet6 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet6 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InputMapper_listener;
var InputMapper = class {
  constructor() {
    _InputMapper_listener.set(this, null);
  }
  // @internal
  setEmitListener(listener) {
    if (listener && typeof listener === "object") {
      __classPrivateFieldSet6(this, _InputMapper_listener, (event) => {
        return listener.onEvent(event) ?? false;
      }, "f");
    } else {
      __classPrivateFieldSet6(this, _InputMapper_listener, listener, "f");
    }
  }
  emit(event) {
    var _a6;
    return ((_a6 = __classPrivateFieldGet6(this, _InputMapper_listener, "f")) == null ? void 0 : _a6.call(this, event)) ?? false;
  }
};
_InputMapper_listener = /* @__PURE__ */ new WeakMap();
var InputMapper_default = InputMapper;

// node_modules/js-draw/dist/mjs/tools/InputFilter/InputStabilizer.mjs
var StabilizerType;
(function(StabilizerType2) {
  StabilizerType2[StabilizerType2["IntertialStabilizer"] = 0] = "IntertialStabilizer";
})(StabilizerType || (StabilizerType = {}));
var defaultOptions = {
  kind: StabilizerType.IntertialStabilizer,
  mass: 0.4,
  // kg
  springConstant: 100,
  // N/m
  frictionCoefficient: 0.28,
  maxPointDist: 10,
  // screen units
  inertiaFraction: 0.75,
  minSimilarityToFinalize: 0,
  velocityDecayFactor: 0.1
};
var StylusInputStabilizer = class {
  constructor(start, updatePointer, options) {
    this.updatePointer = updatePointer;
    this.options = options;
    this.runLoop = true;
    this.lastUpdateTime = 0;
    this.velocity = Vec2.zero;
    this.strokePoint = start;
    this.targetPoint = start;
    this.targetInterval = 10;
    void this.loop();
  }
  async loop() {
    this.lastUpdateTime = performance.now();
    while (this.runLoop) {
      this.update(false);
      await untilNextAnimationFrame_default();
    }
  }
  setTarget(point) {
    this.targetPoint = point;
  }
  getNextVelocity(deltaTimeMs) {
    const toTarget = this.targetPoint.minus(this.strokePoint);
    const springForce = toTarget.times(this.options.springConstant);
    const gravityAccel = 10;
    const normalForceMagnitude = this.options.mass * gravityAccel;
    const frictionForce = this.velocity.normalizedOrZero().times(-this.options.frictionCoefficient * normalForceMagnitude);
    const acceleration = springForce.plus(frictionForce).times(1 / this.options.mass);
    const decayFactor = this.options.velocityDecayFactor;
    const springVelocity = this.velocity.times(1 - decayFactor).plus(acceleration.times(deltaTimeMs / 1e3));
    const toTargetVelocity = toTarget.normalizedOrZero().times(springVelocity.length());
    return toTargetVelocity.lerp(springVelocity, this.options.inertiaFraction);
  }
  update(force) {
    const nowTime = performance.now();
    const deltaTime = nowTime - this.lastUpdateTime;
    const reachedTarget = this.strokePoint.eq(this.targetPoint);
    if (deltaTime > this.targetInterval || force) {
      if (!reachedTarget) {
        let velocity;
        let deltaX;
        let parts = 1;
        do {
          velocity = this.getNextVelocity(deltaTime / parts);
          deltaX = velocity.times(deltaTime / 1e3);
          parts++;
        } while (deltaX.magnitude() > this.options.maxPointDist && parts < 10);
        for (let i = 0; i < parts; i++) {
          this.velocity = this.getNextVelocity(deltaTime / parts);
          deltaX = this.velocity.times(deltaTime / 1e3);
          this.strokePoint = this.strokePoint.plus(deltaX);
          if (i < parts - 1) {
            this.updatePointer(this.strokePoint, nowTime);
          }
        }
      }
      this.lastUpdateTime = nowTime;
      if (force || !reachedTarget) {
        return this.updatePointer(this.strokePoint, nowTime);
      }
    }
    return false;
  }
  /** Finalizes the current stroke. */
  finish() {
    this.runLoop = false;
    const toTarget = this.targetPoint.minus(this.strokePoint);
    if (this.velocity.dot(toTarget) > this.options.minSimilarityToFinalize) {
      this.updatePointer(this.targetPoint, performance.now());
    }
  }
  cancel() {
    this.runLoop = false;
  }
};
var InputStabilizer = class _InputStabilizer extends InputMapper_default {
  constructor(viewport, options = defaultOptions) {
    super();
    this.viewport = viewport;
    this.options = options;
    this.stabilizer = null;
    this.lastPointerEvent = null;
  }
  mapPointerEvent(event) {
    if (isPointerEvt(event) && event.kind !== InputEvtType.PointerUpEvt) {
      this.lastPointerEvent = event;
    }
    if (event.kind === InputEvtType.GestureCancelEvt || event.allPointers.length > 1 || this.stabilizer === null) {
      return this.emit(event);
    }
    this.stabilizer.setTarget(event.current.screenPos);
    if (event.kind === InputEvtType.PointerMoveEvt) {
      return this.stabilizer.update(true);
    } else if (event.kind === InputEvtType.PointerUpEvt) {
      this.stabilizer.finish();
      return this.emit(event);
    } else {
      return this.emit(event);
    }
  }
  // Assumes that there is exactly one pointer that is currently down.
  emitPointerMove(screenPoint, timeStamp) {
    if (!this.lastPointerEvent) {
      return false;
    }
    const pointer = this.lastPointerEvent.current.withScreenPosition(screenPoint, this.viewport).withTimestamp(timeStamp);
    const event = {
      kind: InputEvtType.PointerMoveEvt,
      current: pointer,
      allPointers: [pointer]
    };
    const handled = this.emit(event);
    return handled;
  }
  onEvent(event) {
    var _a6;
    if (isPointerEvt(event) || event.kind === InputEvtType.GestureCancelEvt) {
      if (event.kind === InputEvtType.PointerDownEvt) {
        if (this.stabilizer === null) {
          this.stabilizer = new StylusInputStabilizer(event.current.screenPos, (screenPoint, timeStamp) => this.emitPointerMove(screenPoint, timeStamp), this.options);
        } else if (event.allPointers.length > 1) {
          this.stabilizer.cancel();
          this.stabilizer = null;
        }
      }
      const handled = this.mapPointerEvent(event);
      if (event.kind === InputEvtType.PointerUpEvt || event.kind === InputEvtType.GestureCancelEvt) {
        (_a6 = this.stabilizer) == null ? void 0 : _a6.cancel();
        this.stabilizer = null;
      }
      return handled;
    }
    return this.emit(event);
  }
  static fromEditor(editor) {
    return new _InputStabilizer(editor.viewport);
  }
};

// node_modules/js-draw/dist/mjs/tools/util/StationaryPenDetector.mjs
var defaultStationaryDetectionConfig = {
  maxSpeed: 8.5,
  // screenPx/s
  maxRadius: 11,
  // screenPx
  minTimeSeconds: 0.5
  // s
};
var StationaryPenDetector = class {
  // Only handles one pen. As such, `startPointer` should be the same device/finger
  // as `updatedPointer` in `onPointerMove`.
  //
  // A new `StationaryPenDetector` should be created for each gesture.
  constructor(startPointer, config, onStationary) {
    this.config = config;
    this.onStationary = onStationary;
    this.timeout = null;
    this.stationaryStartPointer = startPointer;
    this.lastPointer = startPointer;
    this.averageVelocity = Vec2.zero;
    this.setStationaryTimeout(this.config.minTimeSeconds * 1e3);
  }
  // Returns true if stationary
  onPointerMove(currentPointer) {
    if (!this.stationaryStartPointer) {
      return;
    }
    if (currentPointer.id !== this.stationaryStartPointer.id) {
      return false;
    }
    const dxFromLast = currentPointer.screenPos.minus(this.lastPointer.screenPos);
    const dxFromStationaryStart = currentPointer.screenPos.minus(this.stationaryStartPointer.screenPos);
    let dtFromLast = (currentPointer.timeStamp - this.lastPointer.timeStamp) / 1e3;
    if (dtFromLast === 0) {
      dtFromLast = 1;
    }
    const currentVelocity = dxFromLast.times(1 / dtFromLast);
    this.averageVelocity = this.averageVelocity.lerp(currentVelocity, 0.5);
    const dtFromStart = currentPointer.timeStamp - this.stationaryStartPointer.timeStamp;
    const movedOutOfRadius = dxFromStationaryStart.length() > this.config.maxRadius;
    this.hasMovedOutOfRadius || (this.hasMovedOutOfRadius = movedOutOfRadius);
    if (movedOutOfRadius || this.averageVelocity.length() > this.config.maxSpeed || dtFromStart < this.config.minTimeSeconds) {
      this.stationaryStartPointer = currentPointer;
      this.lastPointer = currentPointer;
      this.setStationaryTimeout(this.config.minTimeSeconds * 1e3);
      return false;
    }
    const stationaryTimeoutMs = this.config.minTimeSeconds * 1e3 - dtFromStart;
    this.lastPointer = currentPointer;
    return stationaryTimeoutMs <= 0;
  }
  onPointerUp(pointer) {
    var _a6;
    if (pointer.id !== ((_a6 = this.stationaryStartPointer) == null ? void 0 : _a6.id)) {
      this.cancelStationaryTimeout();
    }
  }
  destroy() {
    this.cancelStationaryTimeout();
    this.stationaryStartPointer = null;
  }
  getHasMovedOutOfRadius() {
    return this.hasMovedOutOfRadius;
  }
  cancelStationaryTimeout() {
    if (this.timeout !== null) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
  setStationaryTimeout(timeoutMs) {
    if (this.timeout !== null) {
      return;
    }
    if (timeoutMs <= 0) {
      this.onStationary(this.lastPointer);
    } else {
      this.timeout = setTimeout(() => {
        this.timeout = null;
        if (!this.stationaryStartPointer) {
          return;
        }
        const timeSinceStationaryStart = performance.now() - this.stationaryStartPointer.timeStamp;
        const timeRemaining = this.config.minTimeSeconds * 1e3 - timeSinceStationaryStart;
        if (timeRemaining <= 0) {
          this.onStationary(this.lastPointer);
        } else {
          this.setStationaryTimeout(timeRemaining);
        }
      }, timeoutMs);
    }
  }
};

// node_modules/js-draw/dist/mjs/tools/Pen.mjs
var Pen = class extends BaseTool_default {
  constructor(editor, description, style) {
    super(editor.notifier, description);
    this.editor = editor;
    this.builder = null;
    this.lastPoint = null;
    this.startPoint = null;
    this.currentDeviceType = null;
    this.currentPointerId = null;
    this.shapeAutocompletionEnabled = false;
    this.pressureSensitivityEnabled = true;
    this.autocorrectedShape = null;
    this.lastAutocorrectedShape = null;
    this.removedAutocorrectedShapeTime = 0;
    this.stationaryDetector = null;
    this.styleValue = ReactiveValue.fromInitialValue({
      factory: makeFreehandLineBuilder,
      color: Color4.blue,
      thickness: 4,
      ...style
    });
    this.styleValue.onUpdateAndNow((newValue) => {
      this.style = newValue;
      this.noteUpdated();
    });
  }
  getPressureMultiplier() {
    const thickness = this.style.thickness;
    return 1 / this.editor.viewport.getScaleFactor() * thickness;
  }
  // Converts a `pointer` to a `StrokeDataPoint`.
  toStrokePoint(pointer) {
    const minPressure = 0.3;
    const defaultPressure = 0.5;
    let pressure = Math.max(pointer.pressure ?? 1, minPressure);
    if (!isFinite(pressure)) {
      console.warn("Non-finite pressure!", pointer);
      pressure = minPressure;
    }
    console.assert(isFinite(pointer.canvasPos.length()), "Non-finite canvas position!");
    console.assert(isFinite(pointer.screenPos.length()), "Non-finite screen position!");
    console.assert(isFinite(pointer.timeStamp), "Non-finite timeStamp on pointer!");
    const pos = pointer.canvasPos;
    if (!this.getPressureSensitivityEnabled()) {
      pressure = defaultPressure;
    }
    return {
      pos,
      width: pressure * this.getPressureMultiplier(),
      color: this.style.color,
      time: pointer.timeStamp
    };
  }
  // Displays the stroke that is currently being built with the display's `wetInkRenderer`.
  previewStroke() {
    var _a6;
    this.editor.clearWetInk();
    const wetInkRenderer = this.editor.display.getWetInkRenderer();
    if (this.autocorrectedShape) {
      const visibleRect = this.editor.viewport.visibleRect;
      this.autocorrectedShape.render(wetInkRenderer, visibleRect);
    } else {
      (_a6 = this.builder) == null ? void 0 : _a6.preview(wetInkRenderer);
    }
  }
  // Throws if no stroke builder exists.
  addPointToStroke(point) {
    if (!this.builder) {
      throw new Error("No stroke is currently being generated.");
    }
    this.builder.addPoint(point);
    this.lastPoint = point;
    this.previewStroke();
  }
  onPointerDown(event) {
    if (this.builder && !this.eventCanCancelStroke(event)) {
      return true;
    }
    const { current, allPointers } = event;
    const isEraser = current.device === PointerDevice.Eraser;
    const isPen = current.device === PointerDevice.Pen;
    if (allPointers.length === 1 && !isEraser || isPen) {
      this.startPoint = this.toStrokePoint(current);
      this.builder = this.style.factory(this.startPoint, this.editor.viewport);
      this.currentDeviceType = current.device;
      this.currentPointerId = current.id;
      if (this.shapeAutocompletionEnabled) {
        this.stationaryDetector = new StationaryPenDetector(current, defaultStationaryDetectionConfig, (pointer) => this.autocorrectShape(pointer));
      } else {
        this.stationaryDetector = null;
      }
      this.lastAutocorrectedShape = null;
      this.removedAutocorrectedShapeTime = 0;
      return true;
    }
    return false;
  }
  eventCanCancelStroke(event) {
    var _a6;
    const lastInputTime = ((_a6 = this.lastPoint) == null ? void 0 : _a6.time) ?? 0;
    if (event.current.timeStamp - lastInputTime > 1e3) {
      return true;
    }
    const isPenStroke = this.currentDeviceType === PointerDevice.Pen;
    const isTouchEvent = event.current.device === PointerDevice.Touch;
    if (isPenStroke && isTouchEvent) {
      return false;
    }
    return true;
  }
  eventCanBeDeliveredToNonActiveTool(event) {
    return this.eventCanCancelStroke(event);
  }
  onPointerMove({ current }) {
    var _a6;
    if (!this.builder)
      return;
    if (current.device !== this.currentDeviceType)
      return;
    if (current.id !== this.currentPointerId)
      return;
    const isStationary = (_a6 = this.stationaryDetector) == null ? void 0 : _a6.onPointerMove(current);
    if (!isStationary) {
      this.addPointToStroke(this.toStrokePoint(current));
      if (this.autocorrectedShape) {
        this.removedAutocorrectedShapeTime = performance.now();
        this.autocorrectedShape = null;
        this.editor.announceForAccessibility(this.editor.localization.autocorrectionCanceled);
      }
    }
  }
  onPointerUp({ current }) {
    var _a6, _b2;
    if (!this.builder)
      return false;
    if (current.id !== this.currentPointerId) {
      return true;
    }
    (_a6 = this.stationaryDetector) == null ? void 0 : _a6.onPointerUp(current);
    const currentPoint = this.toStrokePoint(current);
    const strokePoint = {
      ...currentPoint,
      width: ((_b2 = this.lastPoint) == null ? void 0 : _b2.width) ?? currentPoint.width
    };
    this.addPointToStroke(strokePoint);
    this.finalizeStroke();
    return false;
  }
  onGestureCancel() {
    var _a6;
    this.builder = null;
    this.editor.clearWetInk();
    (_a6 = this.stationaryDetector) == null ? void 0 : _a6.destroy();
    this.stationaryDetector = null;
  }
  removedAutocorrectedShapeRecently() {
    return this.removedAutocorrectedShapeTime > performance.now() - 320;
  }
  async autocorrectShape(_lastPointer) {
    if (!this.builder || !this.builder.autocorrectShape)
      return;
    if (!this.shapeAutocompletionEnabled)
      return;
    if (this.autocorrectedShape)
      return;
    const correctedShape = await this.builder.autocorrectShape();
    if (!this.builder || !correctedShape) {
      return;
    }
    const bboxArea = correctedShape.getBBox().area;
    if (bboxArea === 0 || !isFinite(bboxArea)) {
      return;
    }
    const shapeDescription = correctedShape.description(this.editor.localization);
    this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(shapeDescription));
    this.autocorrectedShape = correctedShape;
    this.lastAutocorrectedShape = correctedShape;
    this.previewStroke();
  }
  finalizeStroke() {
    var _a6;
    if (this.builder) {
      if (this.lastAutocorrectedShape && this.removedAutocorrectedShapeRecently()) {
        this.autocorrectedShape = this.lastAutocorrectedShape;
      }
      const stroke = this.autocorrectedShape ?? this.builder.build();
      this.previewStroke();
      if (stroke.getBBox().area > 0) {
        if (stroke === this.autocorrectedShape) {
          this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(stroke.description(this.editor.localization)));
        }
        const canFlatten = true;
        const action = EditorImage_default.addComponent(stroke, canFlatten);
        this.editor.dispatch(action);
      } else {
        console.warn("Pen: Not adding empty stroke", stroke, "to the canvas.");
      }
    }
    this.builder = null;
    this.lastPoint = null;
    this.autocorrectedShape = null;
    this.lastAutocorrectedShape = null;
    this.editor.clearWetInk();
    (_a6 = this.stationaryDetector) == null ? void 0 : _a6.destroy();
    this.stationaryDetector = null;
  }
  noteUpdated() {
    this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
      kind: EditorEventType.ToolUpdated,
      tool: this
    });
  }
  setColor(color) {
    if (color.toHexString() !== this.style.color.toHexString()) {
      this.styleValue.set({
        ...this.style,
        color
      });
    }
  }
  setThickness(thickness) {
    if (thickness !== this.style.thickness) {
      this.styleValue.set({
        ...this.style,
        thickness
      });
    }
  }
  /**
   * Changes the type of stroke created by the pen. The given `factory` can be one of the built-in
   * stroke factories (e.g. {@link makeFreehandLineBuilder}) or a custom stroke factory.
   *
   * Example:
   * [[include:doc-pages/inline-examples/changing-pen-types.md]]
   */
  setStrokeFactory(factory) {
    if (factory !== this.style.factory) {
      this.styleValue.set({
        ...this.style,
        factory
      });
    }
  }
  setHasStabilization(hasStabilization) {
    const hasInputMapper = !!this.getInputMapper();
    if (hasStabilization === hasInputMapper) {
      return;
    }
    if (hasInputMapper) {
      this.setInputMapper(null);
    } else {
      this.setInputMapper(new InputStabilizer(this.editor.viewport));
    }
    this.noteUpdated();
  }
  setStrokeAutocorrectEnabled(enabled) {
    if (enabled !== this.shapeAutocompletionEnabled) {
      this.shapeAutocompletionEnabled = enabled;
      this.noteUpdated();
    }
  }
  getStrokeAutocorrectionEnabled() {
    return this.shapeAutocompletionEnabled;
  }
  setPressureSensitivityEnabled(enabled) {
    if (enabled !== this.pressureSensitivityEnabled) {
      this.pressureSensitivityEnabled = enabled;
      this.noteUpdated();
    }
  }
  getPressureSensitivityEnabled() {
    return this.pressureSensitivityEnabled;
  }
  getThickness() {
    return this.style.thickness;
  }
  getColor() {
    return this.style.color;
  }
  getStrokeFactory() {
    return this.style.factory;
  }
  getStyleValue() {
    return this.styleValue;
  }
  onKeyPress(event) {
    const shortcuts = this.editor.shortcuts;
    const isCtrlZ = shortcuts.matchesShortcut(undoKeyboardShortcutId, event);
    if (this.builder && isCtrlZ) {
      this.finalizeStroke();
      return false;
    }
    let newThickness;
    if (shortcuts.matchesShortcut(decreaseSizeKeyboardShortcutId, event)) {
      newThickness = this.getThickness() * 2 / 3;
    } else if (shortcuts.matchesShortcut(increaseSizeKeyboardShortcutId, event)) {
      newThickness = this.getThickness() * 3 / 2;
    }
    if (newThickness !== void 0) {
      newThickness = Math.min(Math.max(1, newThickness), 256);
      this.setThickness(newThickness);
      return true;
    }
    return false;
  }
};

// node_modules/js-draw/dist/mjs/tools/ToolEnabledGroup.mjs
var ToolEnabledGroup = class {
  constructor() {
  }
  notifyEnabled(tool) {
    var _a6;
    if (tool !== this.activeTool) {
      (_a6 = this.activeTool) == null ? void 0 : _a6.setEnabled(false);
      this.activeTool = tool;
    }
  }
};

// node_modules/js-draw/dist/mjs/components/util/describeComponentList.mjs
var describeComponentList_default = (localizationTable, elems) => {
  if (elems.length === 0) {
    return null;
  }
  const description = elems[0].description(localizationTable);
  for (const elem of elems) {
    if (elem.description(localizationTable) !== description) {
      return null;
    }
  }
  return description;
};

// node_modules/js-draw/dist/mjs/commands/Erase.mjs
var Erase = class extends SerializableCommand_default {
  constructor(toRemove) {
    super("erase");
    this.toRemove = toRemove.map((elem) => elem);
    this.applied = false;
  }
  apply(editor) {
    for (const part of this.toRemove) {
      const parent = editor.image.findParent(part);
      if (parent) {
        parent.remove();
        editor.image.onDestroyElement(part);
      }
    }
    this.applied = true;
    editor.queueRerender();
  }
  unapply(editor) {
    for (const part of this.toRemove) {
      if (!editor.image.findParent(part)) {
        EditorImage_default.addComponent(part).apply(editor);
      }
    }
    this.applied = false;
    editor.queueRerender();
  }
  onDrop(editor) {
    if (this.applied) {
      for (const part of this.toRemove) {
        editor.image.onDestroyElement(part);
      }
    }
  }
  description(_editor, localizationTable) {
    if (this.toRemove.length === 0) {
      return localizationTable.erasedNoElements;
    }
    const description = describeComponentList_default(localizationTable, this.toRemove) ?? localizationTable.elements;
    return localizationTable.eraseAction(description, this.toRemove.length);
  }
  serializeToJSON() {
    const elems = this.toRemove.map((elem) => elem.serialize());
    return elems;
  }
};
(() => {
  SerializableCommand_default.register("erase", (json, editor) => {
    if (!Array.isArray(json)) {
      throw new Error("seralized erase data must be an array");
    }
    const elems = json.map((elemData) => {
      const componentId2 = typeof elemData === "string" ? elemData : `${elemData.id}`;
      const component = editor.image.lookupElement(componentId2) ?? AbstractComponent_default.deserialize(elemData);
      return component;
    });
    return new Erase(elems);
  });
})();
var Erase_default = Erase;

// node_modules/js-draw/dist/mjs/util/waitForAll.mjs
var waitForAll = (results) => {
  if (results.some((command) => command && command["then"])) {
    return Promise.all(results).then(() => {
    });
  }
  return;
};
var waitForAll_default = waitForAll;

// node_modules/js-draw/dist/mjs/commands/uniteCommands.mjs
var NonSerializableUnion = class extends Command_default {
  constructor(commands, applyChunkSize, descriptionOverride) {
    super();
    this.commands = commands;
    this.applyChunkSize = applyChunkSize;
    this.descriptionOverride = descriptionOverride;
  }
  apply(editor) {
    if (this.applyChunkSize === void 0) {
      const results = this.commands.map((cmd) => cmd.apply(editor));
      return waitForAll_default(results);
    } else {
      return editor.asyncApplyCommands(this.commands, this.applyChunkSize);
    }
  }
  unapply(editor) {
    const commands = [...this.commands];
    commands.reverse();
    if (this.applyChunkSize === void 0) {
      const results = commands.map((cmd) => cmd.unapply(editor));
      return waitForAll_default(results);
    } else {
      return editor.asyncUnapplyCommands(commands, this.applyChunkSize, false);
    }
  }
  onDrop(editor) {
    this.commands.forEach((command) => command.onDrop(editor));
  }
  description(editor, localizationTable) {
    if (this.descriptionOverride) {
      return this.descriptionOverride;
    }
    const descriptions = [];
    let lastDescription = null;
    let duplicateDescriptionCount = 0;
    let handledCommandCount = 0;
    for (const part of this.commands) {
      const description = part.description(editor, localizationTable);
      if (description !== lastDescription && lastDescription !== null) {
        descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));
        lastDescription = null;
        duplicateDescriptionCount = 0;
      }
      duplicateDescriptionCount++;
      handledCommandCount++;
      lastDescription ?? (lastDescription = description);
      const maxDescriptionLength = 12;
      if (descriptions.length > maxDescriptionLength) {
        break;
      }
    }
    if (duplicateDescriptionCount > 1) {
      descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));
    } else if (duplicateDescriptionCount === 1) {
      descriptions.push(lastDescription);
    }
    if (handledCommandCount < this.commands.length) {
      descriptions.push(localizationTable.andNMoreCommands(this.commands.length - handledCommandCount));
    }
    return descriptions.join(", ");
  }
};
var SerializableUnion = class extends SerializableCommand_default {
  constructor(commands, applyChunkSize, descriptionOverride) {
    super("union");
    this.commands = commands;
    this.applyChunkSize = applyChunkSize;
    this.descriptionOverride = descriptionOverride;
    this.nonserializableCommand = new NonSerializableUnion(commands, applyChunkSize, descriptionOverride);
  }
  serializeToJSON() {
    if (this.serializedData) {
      return this.serializedData;
    }
    return {
      applyChunkSize: this.applyChunkSize,
      data: this.commands.map((command) => command.serialize()),
      description: this.descriptionOverride
    };
  }
  apply(editor) {
    this.serializedData = this.serializeToJSON();
    return this.nonserializableCommand.apply(editor);
  }
  unapply(editor) {
    return this.nonserializableCommand.unapply(editor);
  }
  onDrop(editor) {
    this.nonserializableCommand.onDrop(editor);
  }
  description(editor, localizationTable) {
    return this.nonserializableCommand.description(editor, localizationTable);
  }
};
var uniteCommands = (commands, options) => {
  let allSerializable = true;
  for (const command of commands) {
    if (!(command instanceof SerializableCommand_default)) {
      allSerializable = false;
      break;
    }
  }
  let applyChunkSize;
  let description;
  if (typeof options === "number") {
    applyChunkSize = options;
  } else {
    applyChunkSize = options == null ? void 0 : options.applyChunkSize;
    description = options == null ? void 0 : options.description;
  }
  if (!allSerializable) {
    return new NonSerializableUnion(commands, applyChunkSize, description);
  } else {
    const castedCommands = commands;
    return new SerializableUnion(castedCommands, applyChunkSize, description);
  }
};
SerializableCommand_default.register("union", (data, editor) => {
  if (typeof data.data.length !== "number") {
    throw new Error("Unions of commands must serialize to lists of serialization data.");
  }
  const applyChunkSize = data.applyChunkSize;
  if (typeof applyChunkSize !== "number" && applyChunkSize !== void 0) {
    throw new Error("serialized applyChunkSize is neither undefined nor a number.");
  }
  const description = typeof data.description === "string" ? data.description : void 0;
  const commands = [];
  for (const part of data.data) {
    commands.push(SerializableCommand_default.deserialize(part, editor));
  }
  return uniteCommands(commands, { applyChunkSize, description });
});
var uniteCommands_default = uniteCommands;

// node_modules/js-draw/dist/mjs/tools/Eraser.mjs
var EraserMode;
(function(EraserMode2) {
  EraserMode2["PartialStroke"] = "partial-stroke";
  EraserMode2["FullStroke"] = "full-stroke";
})(EraserMode || (EraserMode = {}));
var EraserSwitcher = class extends BaseTool_default {
  constructor(editor, eraser) {
    super(editor.notifier, editor.localization.changeTool);
    this.editor = editor;
    this.eraser = eraser;
  }
  onPointerDown(event) {
    if (event.allPointers.length === 1 && event.current.device === PointerDevice.Eraser) {
      const toolController = this.editor.toolController;
      const enabledPrimaryTools = toolController.getPrimaryTools().filter((tool) => tool.isEnabled());
      if (enabledPrimaryTools.length) {
        this.previousEnabledTool = enabledPrimaryTools[0];
      } else {
        this.previousEnabledTool = null;
      }
      this.previousEraserEnabledState = this.eraser.isEnabled();
      this.eraser.setEnabled(true);
      if (this.eraser.onPointerDown(event)) {
        return true;
      } else {
        this.restoreOriginalTool();
      }
    }
    return false;
  }
  onPointerMove(event) {
    this.eraser.onPointerMove(event);
  }
  restoreOriginalTool() {
    this.eraser.setEnabled(this.previousEraserEnabledState);
    if (this.previousEnabledTool) {
      this.previousEnabledTool.setEnabled(true);
    }
  }
  onPointerUp(event) {
    this.eraser.onPointerUp(event);
    this.restoreOriginalTool();
  }
  onGestureCancel(event) {
    this.eraser.onGestureCancel(event);
    this.restoreOriginalTool();
  }
};
var Eraser = class extends BaseTool_default {
  constructor(editor, description, options) {
    super(editor.notifier, description);
    this.editor = editor;
    this.lastPoint = null;
    this.isFirstEraseEvt = true;
    this.toAdd = /* @__PURE__ */ new Set();
    this.eraseCommands = [];
    this.addCommands = [];
    this.thickness = (options == null ? void 0 : options.thickness) ?? 10;
    this.thicknessValue = ReactiveValue.fromInitialValue(this.thickness);
    this.thicknessValue.onUpdate((value) => {
      this.thickness = value;
      this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
        kind: EditorEventType.ToolUpdated,
        tool: this
      });
    });
    this.modeValue = ReactiveValue.fromInitialValue((options == null ? void 0 : options.mode) ?? EraserMode.FullStroke);
    this.modeValue.onUpdate((_value) => {
      this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
        kind: EditorEventType.ToolUpdated,
        tool: this
      });
    });
  }
  /**
   * @returns a tool that briefly enables the eraser when a physical eraser is used.
   * This tool should be added to the tool list after the primary tools.
   */
  makeEraserSwitcherTool() {
    return new EraserSwitcher(this.editor, this);
  }
  clearPreview() {
    this.editor.clearWetInk();
  }
  getSizeOnCanvas() {
    return this.thickness / this.editor.viewport.getScaleFactor();
  }
  drawPreviewAt(point) {
    this.clearPreview();
    const size = this.getSizeOnCanvas();
    const renderer = this.editor.display.getWetInkRenderer();
    const rect = this.getEraserRect(point);
    const rect2 = this.getEraserRect(this.lastPoint ?? point);
    const fill = {
      fill: Color4.transparent,
      stroke: { width: size / 10, color: Color4.gray }
    };
    renderer.drawPath(pathToRenderable(Path.fromConvexHullOf([...rect.corners, ...rect2.corners]), fill));
  }
  /**
   * @returns the eraser rectangle in canvas coordinates.
   *
   * For now, all erasers are rectangles or points.
   */
  getEraserRect(centerPoint) {
    const size = this.getSizeOnCanvas();
    const halfSize = Vec2.of(size / 2, size / 2);
    return Rect2.fromCorners(centerPoint.minus(halfSize), centerPoint.plus(halfSize));
  }
  /** Erases in a line from the last point to the current. */
  eraseTo(currentPoint) {
    if (!this.isFirstEraseEvt && currentPoint.distanceTo(this.lastPoint) === 0) {
      return;
    }
    this.isFirstEraseEvt = false;
    const eraserRect = this.getEraserRect(currentPoint);
    const line = new LineSegment2(this.lastPoint, currentPoint);
    const region = Rect2.union(line.bbox, eraserRect);
    const intersectingElems = this.editor.image.getComponentsIntersecting(region).filter((component) => {
      return component.intersects(line) || component.intersectsRect(eraserRect);
    });
    const eraseableElems = intersectingElems.filter((elem) => elem.isSelectable());
    if (this.modeValue.get() === EraserMode.FullStroke) {
      this.toRemove.push(...eraseableElems);
      const newPartialCommands = eraseableElems.map((elem) => new Erase_default([elem]));
      newPartialCommands.forEach((cmd) => cmd.apply(this.editor));
      this.eraseCommands.push(...newPartialCommands);
    } else {
      const toErase = [];
      const toAdd = [];
      for (const targetElem of eraseableElems) {
        toErase.push(targetElem);
        if (!targetElem.withRegionErased) {
          continue;
        }
        const grownRect = eraserRect.grownBy(eraserRect.maxDimension / 3);
        if (grownRect.containsRect(targetElem.getExactBBox())) {
          continue;
        }
        const erasePath = Path.fromConvexHullOf([
          ...eraserRect.corners,
          ...this.getEraserRect(this.lastPoint ?? currentPoint).corners
        ].map((p) => this.editor.viewport.roundPoint(p)));
        toAdd.push(...targetElem.withRegionErased(erasePath, this.editor.viewport));
      }
      const eraseCommand = new Erase_default(toErase);
      const newAddCommands = toAdd.map((elem) => EditorImage_default.addComponent(elem));
      eraseCommand.apply(this.editor);
      newAddCommands.forEach((command) => command.apply(this.editor));
      const finalToErase = [];
      for (const item of toErase) {
        if (this.toAdd.has(item)) {
          this.toAdd.delete(item);
        } else {
          finalToErase.push(item);
        }
      }
      this.toRemove.push(...finalToErase);
      for (const item of toAdd) {
        this.toAdd.add(item);
      }
      this.eraseCommands.push(new Erase_default(finalToErase));
      this.addCommands.push(...newAddCommands);
    }
    this.drawPreviewAt(currentPoint);
    this.lastPoint = currentPoint;
  }
  onPointerDown(event) {
    if (event.allPointers.length === 1 || event.current.device === PointerDevice.Eraser) {
      this.lastPoint = event.current.canvasPos;
      this.toRemove = [];
      this.toAdd.clear();
      this.isFirstEraseEvt = true;
      this.drawPreviewAt(event.current.canvasPos);
      return true;
    }
    return false;
  }
  onPointerMove(event) {
    const currentPoint = event.current.canvasPos;
    this.eraseTo(currentPoint);
  }
  onPointerUp(event) {
    this.eraseTo(event.current.canvasPos);
    const commands = [];
    if (this.addCommands.length > 0) {
      this.addCommands.forEach((cmd) => cmd.unapply(this.editor));
      for (const item of this.toAdd) {
        if (this.toRemove.includes(item)) {
          this.toAdd.delete(item);
          this.toRemove = this.toRemove.filter((other) => other !== item);
        }
      }
      for (const item of this.toRemove) {
        if (this.toAdd.has(item)) {
          this.toAdd.delete(item);
          this.toRemove = this.toRemove.filter((other) => other !== item);
        }
      }
      commands.push(...[...this.toAdd].map((a) => EditorImage_default.addComponent(a)));
      this.addCommands = [];
    }
    if (this.eraseCommands.length > 0) {
      this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));
      this.eraseCommands = [];
      const command = new Erase_default(this.toRemove);
      commands.push(command);
    }
    if (commands.length === 1) {
      this.editor.dispatch(commands[0]);
    } else {
      this.editor.dispatch(uniteCommands_default(commands));
    }
    this.clearPreview();
  }
  onGestureCancel(_event) {
    this.addCommands.forEach((cmd) => cmd.unapply(this.editor));
    this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));
    this.eraseCommands = [];
    this.addCommands = [];
    this.clearPreview();
  }
  onKeyPress(event) {
    const shortcuts = this.editor.shortcuts;
    let newThickness;
    if (shortcuts.matchesShortcut(decreaseSizeKeyboardShortcutId, event)) {
      newThickness = this.getThickness() * 2 / 3;
    } else if (shortcuts.matchesShortcut(increaseSizeKeyboardShortcutId, event)) {
      newThickness = this.getThickness() * 3 / 2;
    }
    if (newThickness !== void 0) {
      newThickness = Math.min(Math.max(1, newThickness), 200);
      this.setThickness(newThickness);
      return true;
    }
    return false;
  }
  /** Returns the side-length of the tip of this eraser. */
  getThickness() {
    return this.thickness;
  }
  /** Sets the side-length of this' tip. */
  setThickness(thickness) {
    this.thicknessValue.set(thickness);
  }
  /**
   * Returns a {@link MutableReactiveValue} that can be used to watch
   * this tool's thickness.
   */
  getThicknessValue() {
    return this.thicknessValue;
  }
  /** @returns An object that allows switching between a full stroke and a partial stroke eraser. */
  getModeValue() {
    return this.modeValue;
  }
};

// node_modules/js-draw/dist/mjs/components/TextComponent.mjs
var componentTypeId = "text";
var TextTransformMode;
(function(TextTransformMode2) {
  TextTransformMode2[TextTransformMode2["ABSOLUTE_XY"] = 0] = "ABSOLUTE_XY";
  TextTransformMode2[TextTransformMode2["RELATIVE_XY"] = 1] = "RELATIVE_XY";
  TextTransformMode2[TextTransformMode2["RELATIVE_X_ABSOLUTE_Y"] = 2] = "RELATIVE_X_ABSOLUTE_Y";
  TextTransformMode2[TextTransformMode2["RELATIVE_Y_ABSOLUTE_X"] = 3] = "RELATIVE_Y_ABSOLUTE_X";
})(TextTransformMode || (TextTransformMode = {}));
var defaultTextStyle = {
  fontFamily: "sans",
  size: 12,
  renderingStyle: { fill: Color4.purple }
};
var TextComponent = class _TextComponent extends AbstractComponent_default {
  /**
   * Creates a new text object from a list of component text or child TextComponents.
   *
   * @see {@link fromLines}
   */
  constructor(textObjects, transform, style = defaultTextStyle, transformMode = TextTransformMode.ABSOLUTE_XY) {
    super(componentTypeId);
    this.textObjects = textObjects;
    this.transform = transform;
    this.style = style;
    this.transformMode = transformMode;
    this.isRestylableComponent = true;
    this.recomputeBBox();
    const hasDirectContent = textObjects.some((obj) => typeof obj === "string");
    if (!hasDirectContent && textObjects.length > 0) {
      this.style = textObjects[0].getTextStyle();
    }
  }
  static applyTextStyles(ctx, style) {
    const hasSpaces = style.fontFamily.match(/\s/);
    const isQuoted = style.fontFamily.match(/^".*"$/);
    const fontFamily = hasSpaces && !isQuoted ? `"${style.fontFamily.replace(/["]/g, '\\"')}"` : style.fontFamily;
    ctx.font = [
      style.fontStyle ?? "",
      style.fontWeight ?? "",
      (style.size ?? 12) + "px",
      `${fontFamily}`
    ].join(" ");
    ctx.textAlign = "left";
  }
  // Roughly estimate the bounding box of `text`. Use if no CanvasRenderingContext2D is available.
  static estimateTextDimens(text, style) {
    const widthEst = text.length * style.size;
    const heightEst = style.size;
    return new Rect2(0, -heightEst * 2 / 3, widthEst, heightEst);
  }
  // Returns a set of TextMetrics for the given text, if a canvas is available.
  static getTextMetrics(text, style) {
    _TextComponent.textMeasuringCtx ?? (_TextComponent.textMeasuringCtx = document.createElement("canvas").getContext("2d") ?? null);
    if (!_TextComponent.textMeasuringCtx) {
      return null;
    }
    const ctx = _TextComponent.textMeasuringCtx;
    _TextComponent.applyTextStyles(ctx, style);
    return ctx.measureText(text);
  }
  // Returns the bounding box of `text`. This is approximate if no Canvas is available.
  static getTextDimens(text, style) {
    const metrics = this.getTextMetrics(text, style);
    if (!metrics) {
      return this.estimateTextDimens(text, style);
    }
    const textY = -metrics.actualBoundingBoxAscent;
    const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
    return new Rect2(0, textY, metrics.width, textHeight);
  }
  static getFontHeight(style) {
    return style.size;
  }
  computeUntransformedBBoxOfPart(part) {
    if (typeof part === "string") {
      return _TextComponent.getTextDimens(part, this.style);
    } else {
      return part.contentBBox;
    }
  }
  recomputeBBox() {
    let bbox = null;
    const cursor = new _TextComponent.TextCursor(this.transform, this.style);
    for (const textObject of this.textObjects) {
      const transform = cursor.update(textObject).transform;
      const currentBBox = this.computeUntransformedBBoxOfPart(textObject).transformedBoundingBox(transform);
      bbox ?? (bbox = currentBBox);
      bbox = bbox.union(currentBBox);
    }
    this.contentBBox = bbox ?? Rect2.empty;
  }
  /**
   * Renders a TextComponent or a TextComponent child onto a `canvas`.
   *
   * `visibleRect` can be provided as a performance optimization. If not the top-level
   * text node, `baseTransform` (specifies the transformation of the parent text component
   * in canvas space) should also be provided.
   *
   * Note that passing a `baseTransform` is preferable to transforming `visibleRect`. At high
   * zoom levels, transforming `visibleRect` by the inverse of the parent transform can lead to
   * inaccuracy due to precision loss.
   */
  renderInternal(canvas, visibleRect, baseTransform = Mat33.identity) {
    const cursor = new _TextComponent.TextCursor(this.transform, this.style);
    for (const textObject of this.textObjects) {
      const { transform, bbox } = cursor.update(textObject);
      if (visibleRect && !visibleRect.intersects(bbox.transformedBoundingBox(baseTransform))) {
        continue;
      }
      if (typeof textObject === "string") {
        canvas.drawText(textObject, transform, this.style);
      } else {
        canvas.pushTransform(transform);
        textObject.renderInternal(canvas, visibleRect, baseTransform.rightMul(transform));
        canvas.popTransform();
      }
    }
  }
  render(canvas, visibleRect) {
    canvas.startObject(this.contentBBox);
    this.renderInternal(canvas, visibleRect);
    canvas.endObject(this.getLoadSaveData());
  }
  getProportionalRenderingTime() {
    return this.textObjects.length;
  }
  intersects(lineSegment) {
    const cursor = new _TextComponent.TextCursor(this.transform, this.style);
    for (const subObject of this.textObjects) {
      const invTransform = cursor.update(subObject).transform.inverse();
      const transformedLine = lineSegment.transformedBy(invTransform);
      if (typeof subObject === "string") {
        const textBBox = _TextComponent.getTextDimens(subObject, this.style);
        if (textBBox.getEdges().some((edge) => transformedLine.intersection(edge) !== null)) {
          return true;
        }
      } else {
        if (subObject.intersects(transformedLine)) {
          return true;
        }
      }
    }
    return false;
  }
  getStyle() {
    return {
      color: this.style.renderingStyle.fill,
      // Make a copy
      textStyle: {
        ...this.style,
        renderingStyle: {
          ...this.style.renderingStyle
        }
      }
    };
  }
  updateStyle(style) {
    return createRestyleComponentCommand(this.getStyle(), style, this);
  }
  forceStyle(style, editor) {
    if (style.textStyle) {
      this.style = cloneTextStyle(style.textStyle);
    } else if (style.color) {
      this.style = {
        ...this.style,
        renderingStyle: {
          ...this.style.renderingStyle,
          fill: style.color
        }
      };
    } else {
      return;
    }
    for (const child of this.textObjects) {
      if (child instanceof _TextComponent) {
        child.forceStyle(style, editor);
      }
    }
    if (editor) {
      editor.image.queueRerenderOf(this);
      editor.queueRerender();
    }
  }
  // See {@link getStyle}
  getTextStyle() {
    return cloneTextStyle(this.style);
  }
  getBaselinePos() {
    return this.transform.transformVec2(Vec2.zero);
  }
  getTransform() {
    return this.transform;
  }
  applyTransformation(affineTransfm) {
    this.transform = affineTransfm.rightMul(this.transform);
    this.recomputeBBox();
  }
  createClone() {
    const clonedTextObjects = this.textObjects.map((obj) => {
      if (typeof obj === "string") {
        return obj;
      } else {
        return obj.createClone();
      }
    });
    return new _TextComponent(clonedTextObjects, this.transform, this.style);
  }
  getText() {
    const result = [];
    for (const textObject of this.textObjects) {
      if (typeof textObject === "string") {
        result.push(textObject);
      } else {
        result.push(textObject.getText());
      }
    }
    return result.join("\n");
  }
  description(localizationTable) {
    return localizationTable.text(this.getText());
  }
  // Do not rely on the output of `serializeToJSON` taking any particular format.
  serializeToJSON() {
    const serializableStyle = textStyleToJSON(this.style);
    const serializedTextObjects = this.textObjects.map((text) => {
      if (typeof text === "string") {
        return {
          text
        };
      } else {
        return {
          json: text.serializeToJSON()
        };
      }
    });
    return {
      textObjects: serializedTextObjects,
      transform: this.transform.toArray(),
      style: serializableStyle
    };
  }
  // @internal
  static deserializeFromString(json) {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    const style = textStyleFromJSON(json.style);
    const textObjects = json.textObjects.map((data) => {
      if ((data.text ?? null) !== null) {
        return data.text;
      }
      return _TextComponent.deserializeFromString(data.json);
    });
    json.transform = json.transform.filter((elem) => typeof elem === "number");
    if (json.transform.length !== 9) {
      throw new Error(`Unable to deserialize transform, ${json.transform}.`);
    }
    const transformData = json.transform;
    const transform = new Mat33(...transformData);
    return new _TextComponent(textObjects, transform, style);
  }
  /**
   * Creates a `TextComponent` from `lines`.
   *
   * @example
   * ```ts
   * const textStyle = {
   *   size: 12,
   *   fontFamily: 'serif',
   *   renderingStyle: { fill: Color4.black },
   * };
   *
   * const text = TextComponent.fromLines('foo\nbar'.split('\n'), Mat33.identity, textStyle);
   * ```
   */
  static fromLines(lines, transform, style) {
    let lastComponent = null;
    const components = [];
    const lineMargin = Math.round(this.getFontHeight(style));
    let position = Vec2.zero;
    for (const line of lines) {
      if (lastComponent) {
        position = position.plus(Vec2.unitY.times(lineMargin));
      }
      const component = new _TextComponent([line], Mat33.translation(position), style);
      components.push(component);
      lastComponent = component;
    }
    return new _TextComponent(components, transform, style);
  }
};
TextComponent.textMeasuringCtx = null;
TextComponent.TextCursor = class {
  constructor(parentTransform = Mat33.identity, parentStyle) {
    this.parentTransform = parentTransform;
    this.parentStyle = parentStyle;
    this.transform = Mat33.identity;
  }
  /**
   * Based on previous calls to `update`, returns the transformation and bounding box (relative
   * to the parent element, or if none, the canvas) of the given `element`. Note that
   * this is computed in part using the `parentTransform` provivded to this cursor's constructor.
   *
   * Warning: There may be edge cases here that are not taken into account.
   */
  update(elem) {
    let elementTransform = Mat33.identity;
    let elemInternalTransform = Mat33.identity;
    let textSize;
    if (typeof elem === "string") {
      textSize = TextComponent.getTextDimens(elem, this.parentStyle);
    } else {
      elemInternalTransform = elem.transform;
      textSize = elem.getBBox();
    }
    const positioning = typeof elem === "string" ? TextTransformMode.RELATIVE_XY : elem.transformMode;
    if (positioning === TextTransformMode.RELATIVE_XY) {
      elementTransform = this.transform.rightMul(elementTransform);
    } else if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y || positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {
      const transform2 = this.transform.mapEntries((component, [row, col]) => {
        if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {
          return row === 1 && col === 2 ? 0 : component;
        } else if (positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {
          return row === 0 && col === 2 ? 0 : component;
        }
        throw new Error("Unreachable");
        return 0;
      });
      elementTransform = transform2.rightMul(elementTransform);
    }
    const endShiftTransform = Mat33.translation(Vec2.of(textSize.width, 0));
    this.transform = elementTransform.rightMul(elemInternalTransform).rightMul(endShiftTransform);
    const transform = this.parentTransform.rightMul(elementTransform);
    return {
      transform,
      bbox: textSize.transformedBoundingBox(transform)
    };
  }
};
var TextComponent_default = TextComponent;
AbstractComponent_default.registerComponent(componentTypeId, (data) => TextComponent.deserializeFromString(data));

// node_modules/js-draw/dist/mjs/rendering/renderers/AbstractRenderer.mjs
var AbstractRenderer = class {
  constructor(viewport) {
    this.viewport = viewport;
    this.selfTransform = null;
    this.transformStack = [];
    this.objectLevel = 0;
    this.currentPaths = null;
  }
  /**
   * this.canvasToScreen, etc. should be used instead of the corresponding
   * methods on `Viewport`, because the viewport may not accurately reflect
   * what is rendered.
   */
  getViewport() {
    return this.viewport;
  }
  setDraftMode(_draftMode) {
  }
  flushPath() {
    if (!this.currentPaths) {
      return;
    }
    let lastStyle = null;
    for (const path of this.currentPaths) {
      const { startPoint, commands, style } = path;
      if (!lastStyle || !stylesEqual(lastStyle, style)) {
        if (lastStyle) {
          this.endPath(lastStyle);
        }
        this.beginPath(startPoint);
        lastStyle = style;
      } else {
        this.moveTo(startPoint);
      }
      for (const command of commands) {
        if (command.kind === PathCommandType.LineTo) {
          this.lineTo(command.point);
        } else if (command.kind === PathCommandType.MoveTo) {
          this.moveTo(command.point);
        } else if (command.kind === PathCommandType.CubicBezierTo) {
          this.traceCubicBezierCurve(command.controlPoint1, command.controlPoint2, command.endPoint);
        } else if (command.kind === PathCommandType.QuadraticBezierTo) {
          this.traceQuadraticBezierCurve(command.controlPoint, command.endPoint);
        }
      }
    }
    if (lastStyle) {
      this.endPath(lastStyle);
    }
    this.currentPaths = [];
  }
  /**
   * Draws a styled path. If within an object started by {@link startObject},
   * the resultant path may not be visible until {@link endObject} is called.
   */
  drawPath(path) {
    if (this.objectLevel === 0 || this.currentPaths === null) {
      this.currentPaths = [path];
      this.flushPath();
      this.currentPaths = null;
    } else {
      this.currentPaths.push(path);
    }
  }
  // Strokes a rectangle. Boundary lines have width [lineWidth] and are filled with [lineFill].
  // This is equivalent to `drawPath(Path.fromRect(...).toRenderable(...))`.
  drawRect(rect, lineWidth, lineFill) {
    const path = Path.fromRect(rect, lineWidth);
    this.drawPath(pathToRenderable(path, lineFill));
  }
  /** Draws a filled rectangle. */
  fillRect(rect, fill) {
    const path = Path.fromRect(rect);
    this.drawPath(pathToRenderable(path, { fill }));
  }
  /**
   * This should be called whenever a new object is being drawn.
   *
   * @param _boundingBox The bounding box of the object to be drawn.
   * @param _clip Whether content outside `_boundingBox` should be drawn. Renderers
   *              that override this method are not required to support `_clip`.
   */
  startObject(_boundingBox, _clip) {
    if (this.objectLevel > 0) {
      this.flushPath();
    }
    this.currentPaths = [];
    this.objectLevel++;
  }
  /**
   * Notes the end of an object.
   * @param _loaderData - a map from strings to JSON-ifyable objects
   * and contains properties attached to the object by whatever loader loaded the image. This
   * is used to preserve attributes not supported by js-draw when loading/saving an image.
   * Renderers may ignore this.
   *
   * @param _objectTags - a list of labels (e.g. `className`s) to be attached to the object.
   * Renderers may ignore this.
   */
  endObject(_loaderData, _objectTags) {
    this.flushPath();
    this.currentPaths = null;
    this.objectLevel--;
    if (this.objectLevel < 0) {
      throw new Error("More objects have ended than have been started (negative object nesting level)!");
    }
  }
  getNestingLevel() {
    return this.objectLevel;
  }
  // Returns true iff other can be rendered onto this without data loss.
  canRenderFromWithoutDataLoss(_other) {
    return false;
  }
  // MUST throw if other and this are not of the same base class.
  renderFromOtherOfSameType(_renderTo, other) {
    throw new Error(`Unable to render from ${other}: Not implemented`);
  }
  // Set a transformation to apply to things before rendering,
  // replacing the viewport's transform.
  setTransform(transform) {
    this.selfTransform = transform;
  }
  pushTransform(transform) {
    this.flushPath();
    this.transformStack.push(this.selfTransform);
    this.setTransform(this.getCanvasToScreenTransform().rightMul(transform));
  }
  popTransform() {
    if (this.transformStack.length === 0) {
      throw new Error("Unable to pop more transforms than have been pushed!");
    }
    this.flushPath();
    this.setTransform(this.transformStack.pop() ?? null);
  }
  // Get the matrix that transforms a vector on the canvas to a vector on this'
  // rendering target.
  getCanvasToScreenTransform() {
    if (this.selfTransform) {
      return this.selfTransform;
    }
    return this.viewport.canvasToScreenTransform;
  }
  canvasToScreen(vec) {
    return this.getCanvasToScreenTransform().transformVec2(vec);
  }
  getSizeOfCanvasPixelOnScreen() {
    return this.getCanvasToScreenTransform().transformVec3(Vec2.unitX).length();
  }
  /**
   * @internal
   */
  overrideVisibleRect(rect) {
    this.visibleRectOverride = rect;
  }
  // Returns the region in canvas space that is visible within the viewport this
  // canvas is rendering to.
  //
  // Note that in some cases this might not be the same as the `visibleRect` given
  // to components in their `render` method.
  getVisibleRect() {
    return this.visibleRectOverride ?? this.viewport.visibleRect;
  }
};

// node_modules/js-draw/dist/mjs/rendering/renderers/CanvasRenderer.mjs
var CanvasRenderer = class _CanvasRenderer extends AbstractRenderer {
  /**
   * Creates a new `CanvasRenderer` that renders to the given rendering context.
   * The `viewport` is used to determine the translation/rotation/scaling of the content
   * to draw.
   */
  constructor(ctx, viewport) {
    super(viewport);
    this.ctx = ctx;
    this.ignoreObjectsAboveLevel = null;
    this.ignoringObject = false;
    this.currentObjectBBox = null;
    this.clipLevels = [];
    this.setDraftMode(false);
  }
  transformBy(transformBy) {
    this.ctx.transform(
      transformBy.a1,
      transformBy.b1,
      // a, b
      transformBy.a2,
      transformBy.b2,
      // c, d
      transformBy.a3,
      transformBy.b3
    );
  }
  canRenderFromWithoutDataLoss(other) {
    return other instanceof _CanvasRenderer;
  }
  renderFromOtherOfSameType(transformBy, other) {
    if (!(other instanceof _CanvasRenderer)) {
      throw new Error(`${other} cannot be rendered onto ${this}`);
    }
    transformBy = this.getCanvasToScreenTransform().rightMul(transformBy);
    this.ctx.save();
    this.transformBy(transformBy);
    this.ctx.drawImage(other.ctx.canvas, 0, 0);
    this.ctx.restore();
  }
  // Set parameters for lower/higher quality rendering
  setDraftMode(draftMode) {
    if (draftMode) {
      this.minSquareCurveApproxDist = 9;
      this.minRenderSizeBothDimens = 1;
      this.minRenderSizeAnyDimen = 0.1;
    } else {
      this.minSquareCurveApproxDist = 0.5;
      this.minRenderSizeBothDimens = 0.1;
      this.minRenderSizeAnyDimen = 1e-6;
    }
  }
  displaySize() {
    return Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight);
  }
  clear() {
    this.ctx.save();
    this.ctx.resetTransform();
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }
  beginPath(startPoint) {
    startPoint = this.canvasToScreen(startPoint);
    this.ctx.beginPath();
    this.ctx.moveTo(startPoint.x, startPoint.y);
  }
  endPath(style) {
    if (style.fill.a > 0) {
      this.ctx.fillStyle = style.fill.toHexString();
      this.ctx.fill();
    }
    if (style.stroke) {
      this.ctx.strokeStyle = style.stroke.color.toHexString();
      this.ctx.lineWidth = this.getSizeOfCanvasPixelOnScreen() * style.stroke.width;
      this.ctx.lineCap = "round";
      this.ctx.lineJoin = "round";
      this.ctx.stroke();
      this.ctx.lineWidth = 1;
    }
    this.ctx.closePath();
  }
  lineTo(point) {
    point = this.canvasToScreen(point);
    this.ctx.lineTo(point.x, point.y);
  }
  moveTo(point) {
    point = this.canvasToScreen(point);
    this.ctx.moveTo(point.x, point.y);
  }
  traceCubicBezierCurve(p1, p2, p3) {
    p1 = this.canvasToScreen(p1);
    p2 = this.canvasToScreen(p2);
    p3 = this.canvasToScreen(p3);
    const delta1 = p2.minus(p1);
    const delta2 = p3.minus(p2);
    if (delta1.magnitudeSquared() < this.minSquareCurveApproxDist && delta2.magnitudeSquared() < this.minSquareCurveApproxDist) {
      this.ctx.lineTo(p3.x, p3.y);
    } else {
      this.ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    }
  }
  traceQuadraticBezierCurve(controlPoint, endPoint) {
    controlPoint = this.canvasToScreen(controlPoint);
    endPoint = this.canvasToScreen(endPoint);
    const delta = controlPoint.minus(endPoint);
    if (delta.magnitudeSquared() < this.minSquareCurveApproxDist) {
      this.ctx.lineTo(endPoint.x, endPoint.y);
    } else {
      this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);
    }
  }
  drawPath(path) {
    var _a6;
    if (this.ignoringObject) {
      return;
    }
    const visibleRect = this.getVisibleRect();
    if ((_a6 = this.currentObjectBBox) == null ? void 0 : _a6.containsRect(visibleRect)) {
      path = visualEquivalent(path, visibleRect);
    }
    super.drawPath(path);
  }
  drawText(text, transform, style) {
    this.ctx.save();
    transform = this.getCanvasToScreenTransform().rightMul(transform);
    this.transformBy(transform);
    TextComponent_default.applyTextStyles(this.ctx, style);
    if (style.renderingStyle.fill.a !== 0) {
      this.ctx.fillStyle = style.renderingStyle.fill.toHexString();
      this.ctx.fillText(text, 0, 0);
    }
    if (style.renderingStyle.stroke) {
      this.ctx.strokeStyle = style.renderingStyle.stroke.color.toHexString();
      this.ctx.lineWidth = style.renderingStyle.stroke.width;
      this.ctx.strokeText(text, 0, 0);
    }
    this.ctx.restore();
  }
  drawImage(image) {
    if (image.image.width === 0 || image.image.height === 0) {
      return;
    }
    this.ctx.save();
    const transform = this.getCanvasToScreenTransform().rightMul(image.transform);
    this.transformBy(transform);
    this.ctx.drawImage(image.image, 0, 0);
    this.ctx.restore();
  }
  startObject(boundingBox, clip) {
    if (this.isTooSmallToRender(boundingBox)) {
      this.ignoreObjectsAboveLevel = this.getNestingLevel();
      this.ignoringObject = true;
    }
    super.startObject(boundingBox);
    this.currentObjectBBox = boundingBox;
    if (!this.ignoringObject && clip) {
      const clippedIsOutsideScreen = boundingBox.containsRect(this.getVisibleRect());
      if (!clippedIsOutsideScreen) {
        this.clipLevels.push(this.objectLevel);
        this.ctx.save();
        this.ctx.beginPath();
        for (const corner of boundingBox.corners) {
          const screenCorner = this.canvasToScreen(corner);
          this.ctx.lineTo(screenCorner.x, screenCorner.y);
        }
        this.ctx.clip();
      }
    }
  }
  endObject() {
    const objectLevel = this.objectLevel;
    this.currentObjectBBox = null;
    super.endObject();
    if (!this.ignoringObject && this.clipLevels.length > 0) {
      if (this.clipLevels[this.clipLevels.length - 1] === objectLevel) {
        this.ctx.restore();
        this.clipLevels.pop();
      }
    }
    if (this.ignoreObjectsAboveLevel !== null && this.getNestingLevel() <= this.ignoreObjectsAboveLevel) {
      this.ignoreObjectsAboveLevel = null;
      this.ignoringObject = false;
    }
  }
  /**
   * Returns a reference to the underlying `CanvasRenderingContext2D`.
   * This can be used to render custom content not supported by {@link AbstractRenderer}.
   * However, such content won't support {@link SVGRenderer} or {@link TextOnlyRenderer}
   * by default.
   *
   * Use with caution.
   */
  drawWithRawRenderingContext(callback) {
    this.ctx.save();
    this.transformBy(this.getCanvasToScreenTransform());
    callback(this.ctx);
    this.ctx.restore();
  }
  // @internal
  drawPoints(...points) {
    const pointRadius = 10;
    for (let i = 0; i < points.length; i++) {
      const point = this.canvasToScreen(points[i]);
      this.ctx.beginPath();
      this.ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
      this.ctx.fillStyle = Color4.ofRGBA(0.5 + Math.sin(i) / 2, 1, 0.5 + Math.cos(i * 0.2) / 4, 0.5).toHexString();
      this.ctx.lineWidth = 2;
      this.ctx.fill();
      this.ctx.stroke();
      this.ctx.closePath();
      this.ctx.textAlign = "center";
      this.ctx.textBaseline = "middle";
      this.ctx.fillStyle = "black";
      this.ctx.fillText(`${i}`, point.x, point.y, pointRadius * 2);
    }
  }
  // @internal
  isTooSmallToRender(rect) {
    const diagonal = rect.size.times(this.getSizeOfCanvasPixelOnScreen());
    const bothDimenMinSize = this.minRenderSizeBothDimens;
    const bothTooSmall = Math.abs(diagonal.x) < bothDimenMinSize && Math.abs(diagonal.y) < bothDimenMinSize;
    const anyDimenMinSize = this.minRenderSizeAnyDimen;
    const anyTooSmall = Math.abs(diagonal.x) < anyDimenMinSize || Math.abs(diagonal.y) < anyDimenMinSize;
    return bothTooSmall || anyTooSmall;
  }
  // @internal
  static fromViewport(exportViewport, options = {}) {
    const canvas = document.createElement("canvas");
    const exportRectSize = exportViewport.getScreenRectSize();
    let canvasSize = options.canvasSize ?? exportRectSize;
    if (options.maxCanvasDimen && canvasSize.maximumEntryMagnitude() > options.maxCanvasDimen) {
      canvasSize = canvasSize.times(options.maxCanvasDimen / canvasSize.maximumEntryMagnitude());
    }
    canvas.width = canvasSize.x;
    canvas.height = canvasSize.y;
    const ctx = canvas.getContext("2d");
    const scaleFactor = Math.min(canvasSize.x / exportRectSize.x, canvasSize.y / exportRectSize.y);
    ctx.scale(scaleFactor, scaleFactor);
    return { renderer: new _CanvasRenderer(ctx, exportViewport), element: canvas };
  }
};

// node_modules/js-draw/dist/mjs/components/BackgroundComponent.mjs
var BackgroundType;
(function(BackgroundType2) {
  BackgroundType2[BackgroundType2["SolidColor"] = 0] = "SolidColor";
  BackgroundType2[BackgroundType2["Grid"] = 1] = "Grid";
  BackgroundType2[BackgroundType2["None"] = 2] = "None";
})(BackgroundType || (BackgroundType = {}));
var imageBackgroundCSSClassName = "js-draw-image-background";
var imageBackgroundGridSizeCSSPrefix = "js-draw-image-background-grid-";
var imageBackgroundNonAutomaticSecondaryColorCSSClassName = "js-draw-image-background-non-automatic-secondary-color";
var backgroundTypeToClassNameMap = {
  [BackgroundType.Grid]: "js-draw-image-background-grid",
  [BackgroundType.SolidColor]: imageBackgroundCSSClassName,
  [BackgroundType.None]: ""
};
var BackgroundComponent = class _BackgroundComponent extends AbstractComponent_default {
  constructor(backgroundType, mainColor) {
    super("image-background", 0);
    this.backgroundType = backgroundType;
    this.mainColor = mainColor;
    this.viewportSizeChangeListener = null;
    this.autoresizeChangedListener = null;
    this.fillsScreen = false;
    this.gridSize = Viewport_default.getGridSize(2);
    this.gridStrokeWidth = 0.7;
    this.secondaryColor = null;
    this.isRestylableComponent = true;
    this.contentBBox = Rect2.empty;
  }
  static ofGrid(backgroundColor, gridSize, gridColor, gridStrokeWidth) {
    const background = new _BackgroundComponent(BackgroundType.Grid, backgroundColor);
    if (gridSize !== void 0) {
      background.gridSize = gridSize;
    }
    if (gridColor !== void 0) {
      background.secondaryColor = gridColor;
    }
    if (gridStrokeWidth !== void 0) {
      background.gridStrokeWidth = gridStrokeWidth;
    }
    return background;
  }
  getBackgroundType() {
    return this.backgroundType;
  }
  // @internal
  getMainColor() {
    return this.mainColor;
  }
  // @internal
  getSecondaryColor() {
    return this.secondaryColor;
  }
  // @internal
  getGridSize() {
    return this.gridSize;
  }
  getStyle() {
    let color = this.mainColor;
    if (this.backgroundType === BackgroundType.None) {
      color = void 0;
    }
    return {
      color
    };
  }
  updateStyle(style) {
    return createRestyleComponentCommand(this.getStyle(), style, this);
  }
  // @internal
  forceStyle(style, editor) {
    const fill = style.color;
    if (!fill) {
      return;
    }
    this.mainColor = fill;
    if (fill.eq(Color4.transparent) && this.backgroundType === BackgroundType.SolidColor) {
      this.backgroundType = BackgroundType.None;
    } else if (this.backgroundType === BackgroundType.None) {
      this.backgroundType = BackgroundType.SolidColor;
    }
    if (editor) {
      editor.image.queueRerenderOf(this);
      editor.queueRerender();
    }
  }
  onAddToImage(image) {
    if (this.viewportSizeChangeListener) {
      console.warn("onAddToImage called when background is already in an image");
      this.onRemoveFromImage();
    }
    this.viewportSizeChangeListener = image.notifier.on(EditorImageEventType.ExportViewportChanged, () => {
      this.recomputeBBox(image);
    });
    this.autoresizeChangedListener = image.notifier.on(EditorImageEventType.AutoresizeModeChanged, () => {
      this.recomputeBBox(image);
    });
    this.recomputeBBox(image);
  }
  onRemoveFromImage() {
    var _a6, _b2;
    (_a6 = this.viewportSizeChangeListener) == null ? void 0 : _a6.remove();
    (_b2 = this.autoresizeChangedListener) == null ? void 0 : _b2.remove();
    this.viewportSizeChangeListener = null;
    this.autoresizeChangedListener = null;
  }
  recomputeBBox(image) {
    const importExportRect = image.getImportExportViewport().visibleRect;
    let needsRerender = false;
    if (!this.contentBBox.eq(importExportRect)) {
      this.contentBBox = importExportRect;
      needsRerender || (needsRerender = !this.fillsScreen);
    }
    const imageAutoresizes = image.getAutoresizeEnabled();
    if (imageAutoresizes !== this.fillsScreen) {
      this.fillsScreen = imageAutoresizes;
      needsRerender = true;
    }
    if (needsRerender) {
      image.queueRerenderOf(this);
    }
  }
  generateGridPath(visibleRect) {
    const contentBBox = this.getFullBoundingBox(visibleRect);
    const targetRect = ((visibleRect == null ? void 0 : visibleRect.intersection(contentBBox)) ?? contentBBox).grownBy(this.gridStrokeWidth / 2);
    const roundDownToGrid = (coord) => Math.floor(coord / this.gridSize) * this.gridSize;
    const roundUpToGrid = (coord) => Math.ceil(coord / this.gridSize) * this.gridSize;
    const startY = roundUpToGrid(targetRect.y);
    const endY = roundDownToGrid(targetRect.y + targetRect.h);
    const startX = roundUpToGrid(targetRect.x);
    const endX = roundDownToGrid(targetRect.x + targetRect.w);
    const result = [];
    const rowCount = (endY - startY) / this.gridSize;
    const colCount = (endX - startX) / this.gridSize;
    const maxGridCols = 1e3;
    const maxGridRows = 1e3;
    if (rowCount > maxGridRows || colCount > maxGridCols) {
      return Path.empty;
    }
    const startPoint = Vec2.of(targetRect.x, startY);
    for (let y = startY; y <= endY; y += this.gridSize) {
      result.push({
        kind: PathCommandType.MoveTo,
        point: Vec2.of(targetRect.x, y)
      });
      result.push({
        kind: PathCommandType.LineTo,
        point: Vec2.of(targetRect.x + targetRect.w, y)
      });
    }
    for (let x = startX; x <= endX; x += this.gridSize) {
      result.push({
        kind: PathCommandType.MoveTo,
        point: Vec2.of(x, targetRect.y)
      });
      result.push({
        kind: PathCommandType.LineTo,
        point: Vec2.of(x, targetRect.y + targetRect.h)
      });
    }
    return new Path(startPoint, result);
  }
  /**
   * @returns this background's bounding box if the screen size is taken into
   * account (which may be necessary if this component is configured to fill the
   * entire screen).
   */
  getFullBoundingBox(visibleRect) {
    return (this.fillsScreen ? visibleRect : this.contentBBox) ?? this.contentBBox;
  }
  render(canvas, visibleRect) {
    if (this.backgroundType === BackgroundType.None) {
      return;
    }
    const mustRender = !visibleRect;
    if (this.fillsScreen) {
      visibleRect ?? (visibleRect = canvas.getVisibleRect());
    }
    const clip = this.backgroundType === BackgroundType.Grid;
    const contentBBox = this.getFullBoundingBox(visibleRect);
    canvas.startObject(contentBBox, clip);
    if (this.backgroundType === BackgroundType.SolidColor || this.backgroundType === BackgroundType.Grid) {
      const intersection = visibleRect == null ? void 0 : visibleRect.intersection(contentBBox);
      if (intersection) {
        canvas.fillRect(intersection, this.mainColor);
      } else if (mustRender) {
        canvas.fillRect(contentBBox, this.mainColor);
      }
    }
    if (this.backgroundType === BackgroundType.Grid) {
      let gridColor = this.secondaryColor;
      gridColor ?? (gridColor = Color4.ofRGBA(1 - this.mainColor.r, 1 - this.mainColor.g, 1 - this.mainColor.b, 0.2));
      if (this.mainColor.a === 0) {
        gridColor = Color4.ofRGBA(0.5, 0.5, 0.5, 0.2);
      }
      const style = {
        fill: Color4.transparent,
        stroke: { width: this.gridStrokeWidth, color: gridColor }
      };
      canvas.drawPath(pathToRenderable(this.generateGridPath(visibleRect), style));
    }
    const backgroundTypeCSSClass = backgroundTypeToClassNameMap[this.backgroundType];
    const classNames = [imageBackgroundCSSClassName];
    if (backgroundTypeCSSClass !== imageBackgroundCSSClassName) {
      classNames.push(backgroundTypeCSSClass);
      const gridSizeStr = toRoundedString(this.gridSize).replace(/[.]/g, "p");
      classNames.push(imageBackgroundGridSizeCSSPrefix + gridSizeStr);
    }
    if (this.secondaryColor !== null) {
      classNames.push(imageBackgroundNonAutomaticSecondaryColorCSSClassName);
    }
    canvas.endObject(this.getLoadSaveData(), classNames);
  }
  intersects(lineSegment) {
    return this.contentBBox.getEdges().some((edge) => edge.intersects(lineSegment));
  }
  isSelectable() {
    return false;
  }
  isBackground() {
    return true;
  }
  getSizingMode() {
    return this.fillsScreen ? ComponentSizingMode.FillScreen : ComponentSizingMode.BoundingBox;
  }
  serializeToJSON() {
    var _a6;
    return {
      mainColor: this.mainColor.toHexString(),
      secondaryColor: (_a6 = this.secondaryColor) == null ? void 0 : _a6.toHexString(),
      backgroundType: this.backgroundType,
      gridSize: this.gridSize,
      gridStrokeWidth: this.gridStrokeWidth
    };
  }
  applyTransformation(_affineTransfm) {
  }
  description(localizationTable) {
    if (this.backgroundType === BackgroundType.SolidColor) {
      return localizationTable.filledBackgroundWithColor(this.mainColor.toString());
    } else if (this.backgroundType === BackgroundType.None) {
      return localizationTable.emptyBackground;
    } else if (this.backgroundType === BackgroundType.Grid) {
      return localizationTable.gridBackground;
    } else {
      const exhaustivenessCheck = this.backgroundType;
      return exhaustivenessCheck;
    }
  }
  createClone() {
    return new _BackgroundComponent(this.backgroundType, this.mainColor);
  }
  // @internal
  static deserializeFromJSON(json) {
    if (typeof json === "string") {
      json = JSON.parse(json);
    }
    if (typeof json.mainColor !== "string") {
      throw new Error("Error deserializing — mainColor must be of type string.");
    }
    let backgroundType;
    const jsonBackgroundType = json.backgroundType;
    if (jsonBackgroundType === BackgroundType.None || jsonBackgroundType === BackgroundType.Grid || jsonBackgroundType === BackgroundType.SolidColor) {
      backgroundType = jsonBackgroundType;
    } else {
      const exhaustivenessCheck = jsonBackgroundType;
      return exhaustivenessCheck;
    }
    const mainColor = Color4.fromHex(json.mainColor);
    const secondaryColor = json.secondaryColor ? Color4.fromHex(json.secondaryColor) : null;
    const gridSize = json.gridSize ?? void 0;
    const gridStrokeWidth = json.gridStrokeWidth ?? void 0;
    const result = new _BackgroundComponent(backgroundType, mainColor);
    result.secondaryColor = secondaryColor;
    if (gridSize) {
      result.gridSize = gridSize;
    }
    if (gridStrokeWidth) {
      result.gridStrokeWidth = gridStrokeWidth;
    }
    return result;
  }
};
AbstractComponent_default.registerComponent("image-background", BackgroundComponent.deserializeFromJSON);

// node_modules/js-draw/dist/mjs/util/waitForImageLoaded.mjs
var waitForImageLoad = async (image) => {
  if (!image.complete) {
    await new Promise((resolve, reject) => {
      image.onload = (event) => resolve(event);
      image.onerror = (event) => reject(event);
      image.onabort = (event) => reject(event);
    });
  }
};
var waitForImageLoaded_default = waitForImageLoad;

// node_modules/js-draw/dist/mjs/components/ImageComponent.mjs
var ImageComponent = class _ImageComponent extends AbstractComponent_default {
  constructor(image) {
    super("image-component");
    this.image = {
      ...image,
      label: image.label ?? image.image.getAttribute("alt") ?? image.image.getAttribute("aria-label") ?? void 0
    };
    const isHTMLImageElem = (elem) => {
      return elem.getAttribute("src") !== void 0;
    };
    if (isHTMLImageElem(image.image) && !image.image.complete) {
      image.image.onload = () => this.recomputeBBox();
    }
    this.recomputeBBox();
  }
  getImageRect() {
    return new Rect2(0, 0, this.image.image.width, this.image.image.height);
  }
  recomputeBBox() {
    this.contentBBox = this.getImageRect();
    this.contentBBox = this.contentBBox.transformedBoundingBox(this.image.transform);
  }
  /**
   * Load from an image. Waits for the image to load if incomplete.
   *
   * The image, `elem`, must not [taint](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image#security_and_tainted_canvases)
   * an HTMLCanvasElement when rendered.
   */
  static async fromImage(elem, transform) {
    await waitForImageLoaded_default(elem);
    let width, height;
    if (typeof elem.width === "number" && typeof elem.height === "number" && elem.width !== 0 && elem.height !== 0) {
      width = elem.width;
      height = elem.height;
    } else {
      width = elem.clientWidth;
      height = elem.clientHeight;
    }
    let image;
    let url = elem.src ?? "";
    if (!url.startsWith("data:image/")) {
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(elem, 0, 0, canvas.width, canvas.height);
      url = canvas.toDataURL();
      image = canvas;
    } else {
      image = new Image();
      image.src = url;
      image.width = width;
      image.height = height;
    }
    image.setAttribute("alt", elem.getAttribute("alt") ?? "");
    image.setAttribute("aria-label", elem.getAttribute("aria-label") ?? "");
    return new _ImageComponent({
      image,
      base64Url: url,
      transform
    });
  }
  render(canvas, _visibleRect) {
    canvas.startObject(this.contentBBox);
    canvas.drawImage(this.image);
    canvas.endObject(this.getLoadSaveData());
  }
  // A *very* rough estimate of how long it takes to render this component
  getProportionalRenderingTime() {
    return 10;
  }
  intersects(lineSegment) {
    const rect = this.getImageRect();
    const edges = rect.getEdges().map((edge) => edge.transformedBy(this.image.transform));
    for (const edge of edges) {
      if (edge.intersects(lineSegment)) {
        return true;
      }
    }
    return false;
  }
  applyTransformation(affineTransfm) {
    this.image.transform = affineTransfm.rightMul(this.image.transform);
    this.recomputeBBox();
  }
  description(localizationTable) {
    return this.image.label ? localizationTable.imageNode(this.image.label) : localizationTable.unlabeledImageNode;
  }
  getAltText() {
    return this.image.label;
  }
  // The base64 image URL of this image.
  getURL() {
    return this.image.base64Url;
  }
  getTransformation() {
    return this.image.transform;
  }
  createClone() {
    return new _ImageComponent({
      ...this.image
    });
  }
  serializeToJSON() {
    return {
      src: this.image.base64Url,
      label: this.image.label,
      // Store the width and height for bounding box computations while the image is loading.
      width: this.image.image.width,
      height: this.image.image.height,
      transform: this.image.transform.toArray()
    };
  }
  static deserializeFromJSON(data) {
    if (!(typeof data.src === "string")) {
      throw new Error(`${data} has invalid format! Expected src property.`);
    }
    assertIsNumberArray(data.transform);
    assertIsNumber(data.width);
    assertIsNumber(data.height);
    const image = new Image();
    image.src = data.src;
    image.width = data.width;
    image.height = data.height;
    const transform = new Mat33(...data.transform);
    return new _ImageComponent({
      image,
      base64Url: data.src,
      label: data.label,
      transform
    });
  }
};
AbstractComponent_default.registerComponent("image-component", ImageComponent.deserializeFromJSON);

// node_modules/js-draw/dist/mjs/components/SVGGlobalAttributesObject.mjs
var componentKind = "svg-global-attributes";
var SVGGlobalAttributesObject = class _SVGGlobalAttributesObject extends AbstractComponent_default {
  // Does not modify `attrs`
  constructor(attrs) {
    super(componentKind);
    this.contentBBox = Rect2.empty;
    const attrsManagedByRenderer = ["viewBox", "width", "height"];
    this.attrs = attrs.filter(([attr, _value]) => {
      return !attrsManagedByRenderer.includes(attr);
    });
  }
  render(canvas, _visibleRect) {
    if (!(canvas instanceof SVGRenderer)) {
      return;
    }
    for (const [attr, value] of this.attrs) {
      canvas.setRootSVGAttribute(attr, value);
    }
  }
  intersects(_lineSegment) {
    return false;
  }
  applyTransformation(_affineTransfm) {
  }
  isSelectable() {
    return false;
  }
  getSizingMode() {
    return ComponentSizingMode.Anywhere;
  }
  createClone() {
    return new _SVGGlobalAttributesObject(this.attrs);
  }
  description(localization4) {
    return localization4.svgObject;
  }
  serializeToJSON() {
    return JSON.stringify(this.attrs);
  }
  static deserializeFromString(_data) {
    return new _SVGGlobalAttributesObject([]);
  }
};
AbstractComponent_default.registerComponent(componentKind, SVGGlobalAttributesObject.deserializeFromString);

// node_modules/js-draw/dist/mjs/components/UnknownSVGObject.mjs
var componentId = "unknown-svg-object";
var UnknownSVGObject = class _UnknownSVGObject extends AbstractComponent_default {
  constructor(svgObject) {
    super(componentId);
    this.svgObject = svgObject;
    this.contentBBox = Rect2.of(svgObject.getBoundingClientRect());
  }
  render(canvas, _visibleRect) {
    if (!(canvas instanceof SVGRenderer)) {
      return;
    }
    canvas.startObject(this.contentBBox);
    canvas.drawSVGElem(this.svgObject);
    canvas.endObject(this.getLoadSaveData());
  }
  intersects(lineSegment) {
    return this.contentBBox.getEdges().some((edge) => edge.intersection(lineSegment) !== null);
  }
  applyTransformation(_affineTransfm) {
  }
  isSelectable() {
    return false;
  }
  getSizingMode() {
    return ComponentSizingMode.Anywhere;
  }
  createClone() {
    return new _UnknownSVGObject(this.svgObject.cloneNode(true));
  }
  description(localization4) {
    return localization4.svgObject;
  }
  serializeToJSON() {
    return JSON.stringify({
      html: this.svgObject.outerHTML
    });
  }
};
AbstractComponent_default.registerComponent(componentId, null);

// node_modules/js-draw/dist/mjs/SVGLoader/utils/determineFontSize.mjs
var determineFontSize = (elem, computedStyles, supportedStyleAttrs) => {
  var _a6, _b2;
  const fontSizeExp = /^([-0-9.e]+)px/i;
  let fontSizeMatch = fontSizeExp.exec(((_a6 = elem.style) == null ? void 0 : _a6.fontSize) ?? "");
  if (!fontSizeMatch && elem.tagName.toLowerCase() === "tspan" && elem.parentElement) {
    fontSizeMatch = fontSizeExp.exec(((_b2 = elem.parentElement.style) == null ? void 0 : _b2.fontSize) ?? "");
  }
  if (!fontSizeMatch && computedStyles) {
    fontSizeMatch = fontSizeExp.exec(computedStyles.fontSize);
  }
  let fontSize = 12;
  if (fontSizeMatch) {
    supportedStyleAttrs.add("fontSize");
    fontSize = parseFloat(fontSizeMatch[1]);
  }
  return fontSize;
};
var determineFontSize_default = determineFontSize;

// node_modules/js-draw/dist/mjs/SVGLoader/SVGLoader.mjs
var defaultSVGViewRect = new Rect2(0, 0, 500, 500);
var svgAttributesDataKey = "svgAttrs";
var svgStyleAttributesDataKey = "svgStyleAttrs";
var svgLoaderAttributeContainerID = "svgContainerID";
var svgLoaderAutoresizeClassName = "js-draw--autoresize";
var SVGLoaderLoadMethod;
(function(SVGLoaderLoadMethod2) {
  SVGLoaderLoadMethod2["IFrame"] = "iframe";
  SVGLoaderLoadMethod2["DOMParser"] = "domparser";
})(SVGLoaderLoadMethod || (SVGLoaderLoadMethod = {}));
var supportedStrokeFillStyleAttrs = ["stroke", "fill", "stroke-width"];
var SVGLoader = class _SVGLoader {
  constructor(source, onFinish, options) {
    this.source = source;
    this.onFinish = onFinish;
    this.onAddComponent = null;
    this.onProgress = null;
    this.onDetermineExportRect = null;
    this.processedCount = 0;
    this.totalToProcess = 0;
    this.containerGroupIDs = [];
    this.encounteredIDs = [];
    this.plugins = options.plugins ?? [];
    this.storeUnknown = !(options.sanitize ?? false);
    this.disableUnknownObjectWarnings = !!options.disableUnknownObjectWarnings;
  }
  // If [computedStyles] is given, it is preferred to directly accessing node's style object.
  getStyle(node, computedStyles) {
    var _a6, _b2, _c2;
    let fill = Color4.transparent;
    let stroke;
    const fillAttribute = node.getAttribute("fill") ?? ((computedStyles == null ? void 0 : computedStyles.fill) || ((_a6 = node.style) == null ? void 0 : _a6.fill));
    if (fillAttribute) {
      try {
        fill = Color4.fromString(fillAttribute);
      } catch {
        console.error("Unknown fill color,", fillAttribute);
      }
    }
    const strokeAttribute = node.getAttribute("stroke") ?? (computedStyles == null ? void 0 : computedStyles.stroke) ?? ((_b2 = node.style) == null ? void 0 : _b2.stroke) ?? "";
    const strokeWidthAttr = node.getAttribute("stroke-width") ?? (computedStyles == null ? void 0 : computedStyles.strokeWidth) ?? ((_c2 = node.style) == null ? void 0 : _c2.strokeWidth) ?? "";
    if (strokeAttribute && strokeWidthAttr) {
      try {
        let width = parseFloat(strokeWidthAttr ?? "1");
        if (!isFinite(width)) {
          width = 0;
        }
        const strokeColor = Color4.fromString(strokeAttribute);
        if (strokeColor.a > 0) {
          stroke = {
            width,
            color: strokeColor
          };
        }
      } catch (e) {
        console.error("Error parsing stroke data:", e);
      }
    }
    const style = {
      fill,
      stroke
    };
    return style;
  }
  strokeDataFromElem(node) {
    const result = [];
    const pathData = node.getAttribute("d") ?? "";
    const style = this.getStyle(node);
    const parts = pathData.split("M");
    let isFirst = true;
    for (const part of parts) {
      const isNoOpMoveTo = /^[0-9., \t\n]+$/.exec(part);
      if (part !== "" && !isNoOpMoveTo) {
        const current = !isFirst ? `M${part}` : part;
        const path = Path.fromString(current);
        const spec = pathToRenderable(path, style);
        result.push(spec);
      }
      isFirst = false;
    }
    return result;
  }
  attachUnrecognisedAttrs(elem, node, supportedAttrs, supportedStyleAttrs) {
    if (!this.storeUnknown) {
      return;
    }
    for (const attr of node.getAttributeNames()) {
      if (supportedAttrs.has(attr) || attr === "style" && supportedStyleAttrs) {
        continue;
      }
      elem.attachLoadSaveData(svgAttributesDataKey, [
        attr,
        node.getAttribute(attr)
      ]);
    }
    if (supportedStyleAttrs && node.style) {
      for (let i = 0; i < node.style.length; i++) {
        const attr = node.style[i];
        if (attr === "" || !attr) {
          continue;
        }
        if (supportedStyleAttrs.has(attr)) {
          continue;
        }
        elem.attachLoadSaveData(svgStyleAttributesDataKey, {
          key: attr,
          value: node.style.getPropertyValue(attr),
          priority: node.style.getPropertyPriority(attr)
        });
      }
    }
  }
  // Adds a stroke with a single path
  async addPath(node) {
    let elem;
    try {
      const strokeData = this.strokeDataFromElem(node);
      elem = new Stroke(strokeData);
      this.attachUnrecognisedAttrs(elem, node, /* @__PURE__ */ new Set([...supportedStrokeFillStyleAttrs, "d"]), new Set(supportedStrokeFillStyleAttrs));
    } catch (e) {
      console.error("Invalid path in node", node, "\nError:", e, "\nAdding as an unknown object.");
      if (this.storeUnknown) {
        elem = new UnknownSVGObject(node);
      } else {
        return;
      }
    }
    await this.addComponent(elem);
  }
  async addBackground(node) {
    if (node.classList.contains(backgroundTypeToClassNameMap[BackgroundType.Grid])) {
      let foregroundStr;
      let backgroundStr;
      let gridStrokeWidthStr;
      if (node.tagName.toLowerCase() === "g") {
        if (node.children.length !== 2) {
          await this.addUnknownNode(node);
          return;
        }
        const background = node.children[0];
        const grid = node.children[1];
        backgroundStr = background.getAttribute("fill");
        foregroundStr = grid.getAttribute("stroke");
        gridStrokeWidthStr = grid.getAttribute("stroke-width");
      } else {
        backgroundStr = node.getAttribute("fill");
        foregroundStr = node.getAttribute("stroke");
        gridStrokeWidthStr = node.getAttribute("stroke-width");
      }
      backgroundStr ?? (backgroundStr = Color4.transparent.toHexString());
      if (!foregroundStr) {
        await this.addUnknownNode(node);
        return;
      }
      let gridSize = void 0;
      for (const className of node.classList) {
        if (className.startsWith(imageBackgroundGridSizeCSSPrefix)) {
          const sizeStr = className.substring(imageBackgroundGridSizeCSSPrefix.length);
          gridSize = parseFloat(sizeStr.replace(/p/g, "."));
        }
      }
      let gridStrokeWidth = void 0;
      if (gridStrokeWidthStr) {
        gridStrokeWidth = parseFloat(gridStrokeWidthStr);
      }
      const backgroundColor = Color4.fromString(backgroundStr);
      let foregroundColor = Color4.fromString(foregroundStr);
      if (!node.classList.contains(imageBackgroundNonAutomaticSecondaryColorCSSClassName)) {
        foregroundColor = void 0;
      }
      const elem = BackgroundComponent.ofGrid(backgroundColor, gridSize, foregroundColor, gridStrokeWidth);
      await this.addComponent(elem);
    } else if (node.tagName.toLowerCase() === "path") {
      const fill = Color4.fromString(node.getAttribute("fill") ?? node.style.fill ?? "black");
      const elem = new BackgroundComponent(BackgroundType.SolidColor, fill);
      await this.addComponent(elem);
    } else {
      await this.addUnknownNode(node);
    }
  }
  getComputedStyle(element) {
    try {
      return window.getComputedStyle(element);
    } catch (error) {
      console.warn("Error computing style", error);
      return void 0;
    }
  }
  // If given, 'supportedAttrs' will have x, y, etc. attributes that were used in computing the transform added to it,
  // to prevent storing duplicate transform information when saving the component.
  getTransform(elem, supportedAttrs, computedStyles) {
    var _a6;
    const highpTransformAttribute = "data-highp-transform";
    const rawTransformData = elem.getAttribute(highpTransformAttribute);
    let transform;
    if (rawTransformData) {
      try {
        transform = Mat33.fromCSSMatrix(rawTransformData);
        supportedAttrs == null ? void 0 : supportedAttrs.push(highpTransformAttribute);
      } catch (e) {
        console.warn(`Unable to parse raw transform data, ${rawTransformData}. Falling back to CSS data. Error:`, e);
      }
    }
    if (!transform) {
      computedStyles ?? (computedStyles = this.getComputedStyle(elem));
      let transformProperty = computedStyles == null ? void 0 : computedStyles.transform;
      if (!transformProperty || transformProperty === "none") {
        transformProperty = ((_a6 = elem.style) == null ? void 0 : _a6.transform) || "none";
      }
      try {
        transform = Mat33.fromCSSMatrix(elem.style.transform);
      } catch (_e) {
        console.warn("matrix parse error", _e);
        transform = Mat33.fromCSSMatrix(transformProperty);
      }
      const elemX = elem.getAttribute("x");
      const elemY = elem.getAttribute("y");
      if (elemX || elemY) {
        const x = parseFloat(elemX ?? "0");
        const y = parseFloat(elemY ?? "0");
        if (!isNaN(x) && !isNaN(y)) {
          supportedAttrs == null ? void 0 : supportedAttrs.push("x", "y");
          transform = transform.rightMul(Mat33.translation(Vec2.of(x, y)));
        }
      }
    }
    return transform;
  }
  makeText(elem) {
    var _a6, _b2, _c2;
    const contentList = [];
    for (const child of elem.childNodes) {
      if (child.nodeType === Node.TEXT_NODE) {
        contentList.push(child.nodeValue ?? "");
      } else if (child.nodeType === Node.ELEMENT_NODE) {
        const subElem = child;
        if (subElem.tagName.toLowerCase() === "tspan") {
          contentList.push(this.makeText(subElem));
        } else {
          throw new Error(`Unrecognized text child element: ${subElem}`);
        }
      } else {
        throw new Error(`Unrecognized text child node: ${child}.`);
      }
    }
    if (contentList.length === 0) {
      contentList.push("");
    }
    const computedStyles = this.getComputedStyle(elem);
    const supportedStyleAttrs = /* @__PURE__ */ new Set([
      "fontFamily",
      "transform",
      ...supportedStrokeFillStyleAttrs
    ]);
    const style = {
      size: determineFontSize_default(elem, computedStyles, supportedStyleAttrs),
      fontFamily: (computedStyles == null ? void 0 : computedStyles.fontFamily) || ((_a6 = elem.style) == null ? void 0 : _a6.fontFamily) || "sans-serif",
      fontWeight: (computedStyles == null ? void 0 : computedStyles.fontWeight) || ((_b2 = elem.style) == null ? void 0 : _b2.fontWeight) || void 0,
      fontStyle: (computedStyles == null ? void 0 : computedStyles.fontStyle) || ((_c2 = elem.style) == null ? void 0 : _c2.fontStyle) || void 0,
      renderingStyle: this.getStyle(elem, computedStyles)
    };
    const supportedAttrs = [];
    let transform = this.getTransform(elem, supportedAttrs, computedStyles);
    let transformMode = TextTransformMode.ABSOLUTE_XY;
    const elemDX = elem.getAttribute("dx");
    if (elemDX) {
      transformMode = TextTransformMode.RELATIVE_X_ABSOLUTE_Y;
      transform = transform.rightMul(Mat33.translation(Vec2.of(parseFloat(elemDX), 0)));
      supportedAttrs.push("dx");
    }
    const elemDY = elem.getAttribute("dy");
    if (elemDY) {
      if (transformMode === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {
        transformMode = TextTransformMode.RELATIVE_XY;
      } else {
        transformMode = TextTransformMode.RELATIVE_Y_ABSOLUTE_X;
      }
      transform = transform.rightMul(Mat33.translation(Vec2.of(0, parseFloat(elemDY))));
      supportedAttrs.push("dy");
    }
    const result = new TextComponent_default(contentList, transform, style, transformMode);
    this.attachUnrecognisedAttrs(result, elem, new Set(supportedAttrs), new Set(supportedStyleAttrs));
    return result;
  }
  async addText(elem) {
    try {
      const textElem = this.makeText(elem);
      await this.addComponent(textElem);
    } catch (e) {
      console.error("Invalid text object in node", elem, ". Continuing.... Error:", e);
      this.addUnknownNode(elem);
    }
  }
  async addImage(elem) {
    const image = new Image();
    image.src = elem.getAttribute("xlink:href") ?? elem.href.baseVal;
    image.setAttribute("alt", elem.getAttribute("aria-label") ?? "");
    try {
      const supportedAttrs = [];
      const transform = this.getTransform(elem, supportedAttrs);
      const imageElem = await ImageComponent.fromImage(image, transform);
      this.attachUnrecognisedAttrs(imageElem, elem, new Set(supportedAttrs), /* @__PURE__ */ new Set(["transform"]));
      await this.addComponent(imageElem);
    } catch (e) {
      console.error("Error loading image:", e, ". Element: ", elem, ". Continuing...");
      await this.addUnknownNode(elem);
    }
  }
  async addUnknownNode(node) {
    if (this.storeUnknown) {
      const component = new UnknownSVGObject(node);
      await this.addComponent(component);
    }
  }
  async startGroup(node) {
    node = node.cloneNode(false);
    let id = node.id || `id-${this.encounteredIDs.length}`;
    let idSuffixCounter = 0;
    let suffix = "";
    while (this.encounteredIDs.includes(id + suffix)) {
      idSuffixCounter++;
      suffix = "--" + idSuffixCounter;
    }
    id += suffix;
    node.replaceChildren();
    node.id = id;
    const component = new UnknownSVGObject(node);
    this.addComponent(component);
    this.containerGroupIDs.push(node.id);
    this.encounteredIDs.push(node.id);
  }
  // Ends the most recent group started by .startGroup
  async endGroup() {
    this.containerGroupIDs.pop();
  }
  async addComponent(component) {
    var _a6;
    if (this.containerGroupIDs.length > 0) {
      component.attachLoadSaveData(svgLoaderAttributeContainerID, [...this.containerGroupIDs]);
    }
    await ((_a6 = this.onAddComponent) == null ? void 0 : _a6.call(this, component));
  }
  updateViewBox(node) {
    var _a6;
    const viewBoxAttr = node.getAttribute("viewBox");
    if (this.rootViewBox || !viewBoxAttr) {
      return;
    }
    const components = viewBoxAttr.split(/[ \t\n,]+/);
    const x = parseFloat(components[0]);
    const y = parseFloat(components[1]);
    const width = parseFloat(components[2]);
    const height = parseFloat(components[3]);
    if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {
      console.warn(`node ${node} has an unparsable viewbox. Viewbox: ${viewBoxAttr}. Match: ${components}.`);
      return;
    }
    const autoresize = node.classList.contains(svgLoaderAutoresizeClassName);
    this.rootViewBox = new Rect2(x, y, width, height);
    (_a6 = this.onDetermineExportRect) == null ? void 0 : _a6.call(this, this.rootViewBox, { autoresize });
  }
  async updateSVGAttrs(node) {
    var _a6;
    if (this.storeUnknown) {
      await ((_a6 = this.onAddComponent) == null ? void 0 : _a6.call(this, new SVGGlobalAttributesObject(this.getSourceAttrs(node))));
    }
  }
  async visit(node) {
    var _a6;
    this.totalToProcess += node.childElementCount;
    let visitChildren = true;
    const visitPlugin = async () => {
      for (const plugin of this.plugins) {
        const processed = await plugin.visit(node, {
          addComponent: (component) => {
            var _a7;
            return (_a7 = this.onAddComponent) == null ? void 0 : _a7.call(this, component);
          }
        });
        if (processed) {
          visitChildren = false;
          return true;
        }
      }
      return false;
    };
    const visitBuiltIn = async () => {
      switch (node.tagName.toLowerCase()) {
        case "g":
          if (node.classList.contains(imageBackgroundCSSClassName)) {
            await this.addBackground(node);
            visitChildren = false;
          } else {
            await this.startGroup(node);
          }
          break;
        case "path":
          if (node.classList.contains(imageBackgroundCSSClassName)) {
            await this.addBackground(node);
          } else {
            await this.addPath(node);
          }
          break;
        case "text":
          await this.addText(node);
          visitChildren = false;
          break;
        case "image":
          await this.addImage(node);
          visitChildren = false;
          break;
        case "svg":
          this.updateViewBox(node);
          this.updateSVGAttrs(node);
          break;
        case "style":
          if (node.getAttribute("id") !== renderedStylesheetId) {
            await this.addUnknownNode(node);
          }
          break;
        default:
          if (!this.disableUnknownObjectWarnings) {
            console.warn("Unknown SVG element,", node, node.tagName);
            if (!(node instanceof SVGElement)) {
              console.warn("Element", node, "is not an SVGElement!", this.storeUnknown ? "Continuing anyway." : "Skipping.");
            }
          }
          await this.addUnknownNode(node);
          return;
      }
    };
    if (await visitPlugin()) {
      visitChildren = false;
    } else {
      await visitBuiltIn();
    }
    if (visitChildren) {
      for (const child of node.children) {
        await this.visit(child);
      }
      if (node.tagName.toLowerCase() === "g") {
        await this.endGroup();
      }
    }
    this.processedCount++;
    await ((_a6 = this.onProgress) == null ? void 0 : _a6.call(this, this.processedCount, this.totalToProcess));
  }
  // Get SVG element attributes (e.g. xlink=...)
  getSourceAttrs(node) {
    return node.getAttributeNames().map((attr) => {
      return [attr, node.getAttribute(attr)];
    });
  }
  async start(onAddComponent, onProgress, onDetermineExportRect = null) {
    var _a6, _b2;
    this.onAddComponent = onAddComponent;
    this.onProgress = onProgress;
    this.onDetermineExportRect = onDetermineExportRect;
    this.totalToProcess = this.source.childElementCount;
    this.processedCount = 0;
    this.rootViewBox = null;
    await this.visit(this.source);
    const viewBox = this.rootViewBox;
    if (!viewBox) {
      (_a6 = this.onDetermineExportRect) == null ? void 0 : _a6.call(this, defaultSVGViewRect);
    }
    (_b2 = this.onFinish) == null ? void 0 : _b2.call(this);
    this.onFinish = null;
  }
  /**
   * Create an `SVGLoader` from the content of an SVG image. SVGs are loaded within a sandboxed
   * iframe with `sandbox="allow-same-origin"`
   * [thereby disabling JavaScript](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox).
   *
   * @see {@link Editor.loadFrom}
   * @param text - Textual representation of the SVG (e.g. `<svg viewbox='...'>...</svg>`).
   * @param options - if `true` or `false`, treated as the `sanitize` option -- don't store unknown attributes.
   */
  static fromString(text, options = false) {
    const domParserLoad = typeof options !== "boolean" && (options == null ? void 0 : options.loadMethod) === SVGLoaderLoadMethod.DOMParser;
    const { svgElem, cleanUp } = (() => {
      var _a6;
      if (!domParserLoad) {
        try {
          const sandbox = document.createElement("iframe");
          sandbox.src = "about:blank";
          sandbox.setAttribute("sandbox", "allow-same-origin");
          sandbox.setAttribute("csp", "default-src 'about:blank'");
          sandbox.style.display = "none";
          document.body.appendChild(sandbox);
          if (!sandbox.hasAttribute("sandbox")) {
            sandbox.remove();
            throw new Error("SVG loading iframe is not sandboxed.");
          }
          const sandboxDoc = ((_a6 = sandbox.contentWindow) == null ? void 0 : _a6.document) ?? sandbox.contentDocument;
          if (sandboxDoc == null)
            throw new Error("Unable to open a sandboxed iframe!");
          sandboxDoc.open();
          sandboxDoc.write(`
						<!DOCTYPE html>
						<html>
							<head>
								<title>SVG Loading Sandbox</title>
								<meta name='viewport' conent='width=device-width,initial-scale=1.0'/>
								<meta charset='utf-8'/>
							</head>
							<body style='font-size: 12px;'>
								<script>
									console.error('JavaScript should not be able to run here!');
									throw new Error(
										'The SVG sandbox is broken! Please double-check the sandboxing setting.'
									);
								<\/script>
							</body>
						</html>
					`);
          sandboxDoc.close();
          const svgElem3 = sandboxDoc.createElementNS("http://www.w3.org/2000/svg", "svg");
          svgElem3.innerHTML = text;
          sandboxDoc.body.appendChild(svgElem3);
          const cleanUp3 = () => {
            svgElem3.remove();
            sandbox.remove();
            sandbox.src = "";
          };
          return { svgElem: svgElem3, cleanUp: cleanUp3 };
        } catch (error) {
          console.warn("Failed loading SVG via a sandboxed iframe. Some styles may not be loaded correctly. Error: ", error);
        }
      }
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${text}</svg>`, "text/html");
      const svgElem2 = doc.querySelector("svg");
      const errorReportNode = doc.querySelector("parsererror");
      if (errorReportNode) {
        throw new Error("Parse error: " + errorReportNode.textContent);
      }
      const cleanUp2 = () => {
      };
      return { svgElem: svgElem2, cleanUp: cleanUp2 };
    })();
    let sanitize;
    let disableUnknownObjectWarnings;
    let plugins;
    if (typeof options === "boolean") {
      sanitize = options;
      disableUnknownObjectWarnings = false;
      plugins = [];
    } else {
      sanitize = options.sanitize ?? false;
      disableUnknownObjectWarnings = options.disableUnknownObjectWarnings ?? false;
      plugins = options.plugins;
    }
    return new _SVGLoader(svgElem, cleanUp, {
      sanitize,
      disableUnknownObjectWarnings,
      plugins
    });
  }
};

// node_modules/js-draw/dist/mjs/util/listPrefixMatch.mjs
var listPrefixMatch = (a, b) => {
  const shorter = a.length < b.length ? a : b;
  const longer = shorter === a ? b : a;
  for (let i = 0; i < shorter.length; i++) {
    if (shorter[i] !== longer[i]) {
      return false;
    }
  }
  return true;
};
var listPrefixMatch_default = listPrefixMatch;

// node_modules/js-draw/dist/mjs/rendering/renderers/SVGRenderer.mjs
var renderedStylesheetId = "js-draw-style-sheet";
var svgNameSpace = "http://www.w3.org/2000/svg";
var defaultTextStyle2 = {
  fontWeight: "400",
  fontStyle: "normal"
};
var SVGRenderer = class _SVGRenderer extends AbstractRenderer {
  /**
   * Creates a renderer that renders onto `elem`. If `sanitize`, don't render potentially untrusted data.
   *
   * `viewport` is used to determine the translation/rotation/scaling/output size of the rendered
   * data.
   */
  constructor(elem, viewport, sanitize = false) {
    super(viewport);
    this.elem = elem;
    this.sanitize = sanitize;
    this.lastPathStyle = null;
    this.lastPathString = [];
    this.lastContainerIDList = [];
    this.objectElems = null;
    this.overwrittenAttrs = {};
    this.textContainer = null;
    this.textContainerTransform = null;
    this.textParentStyle = defaultTextStyle2;
    this.clear();
    this.addStyleSheet();
  }
  addStyleSheet() {
    if (!this.elem.querySelector(`#${renderedStylesheetId}`)) {
      const styleSheet = document.createElementNS("http://www.w3.org/2000/svg", "style");
      styleSheet.appendChild(document.createTextNode(`
				path {
					stroke-linecap: round;
					stroke-linejoin: round;
				}

				text {
					white-space: pre;
				}
			`.replace(/\s+/g, "")));
      styleSheet.setAttribute("id", renderedStylesheetId);
      this.elem.appendChild(styleSheet);
    }
  }
  // Sets an attribute on the root SVG element.
  setRootSVGAttribute(name, value) {
    if (this.sanitize) {
      return;
    }
    if (!(name in this.overwrittenAttrs)) {
      this.overwrittenAttrs[name] = this.elem.getAttribute(name);
    }
    if (value !== null) {
      this.elem.setAttribute(name, value);
    } else {
      this.elem.removeAttribute(name);
    }
  }
  displaySize() {
    return Vec2.of(this.elem.clientWidth, this.elem.clientHeight);
  }
  clear() {
    this.lastPathString = [];
    this.lastContainerIDList = [];
    if (!this.sanitize) {
      for (const attrName in this.overwrittenAttrs) {
        const value = this.overwrittenAttrs[attrName];
        if (value) {
          this.elem.setAttribute(attrName, value);
        } else {
          this.elem.removeAttribute(attrName);
        }
      }
      this.overwrittenAttrs = {};
    }
  }
  // Push `this.fullPath` to the SVG. Returns the path added to the SVG, if any.
  // @internal
  addPathToSVG() {
    var _a6;
    if (!this.lastPathStyle || this.lastPathString.length === 0) {
      return null;
    }
    const pathElem = document.createElementNS(svgNameSpace, "path");
    pathElem.setAttribute("d", this.lastPathString.join(" "));
    const style = this.lastPathStyle;
    if (style.fill.a > 0) {
      pathElem.setAttribute("fill", style.fill.toHexString());
    } else {
      pathElem.setAttribute("fill", "none");
    }
    if (style.stroke) {
      pathElem.setAttribute("stroke", style.stroke.color.toHexString());
      pathElem.setAttribute("stroke-width", toRoundedString(style.stroke.width * this.getSizeOfCanvasPixelOnScreen()));
    }
    this.elem.appendChild(pathElem);
    (_a6 = this.objectElems) == null ? void 0 : _a6.push(pathElem);
    return pathElem;
  }
  drawPath(pathSpec) {
    const style = pathSpec.style;
    const path = pathFromRenderable(pathSpec).transformedBy(this.getCanvasToScreenTransform());
    if (this.lastPathString.length === 0 || !this.lastPathStyle || !stylesEqual(this.lastPathStyle, style)) {
      this.addPathToSVG();
      this.lastPathStyle = style;
      this.lastPathString = [];
    }
    this.lastPathString.push(path.toString());
  }
  // Apply [elemTransform] to [elem]. Uses both a `matrix` and `.x`, `.y` properties if `setXY` is true.
  // Otherwise, just uses a `matrix`.
  transformFrom(elemTransform, elem, inCanvasSpace = false) {
    const transform = !inCanvasSpace ? this.getCanvasToScreenTransform().rightMul(elemTransform) : elemTransform;
    if (!transform.eq(Mat33.identity)) {
      const matrixString = transform.toCSSMatrix();
      elem.style.transform = matrixString;
      elem.setAttribute("data-highp-transform", matrixString);
    } else {
      elem.style.transform = "";
    }
  }
  drawText(text, transform, style) {
    var _a6;
    const applyTextStyles = (elem, style2) => {
      var _a7, _b2, _c2, _d, _e;
      if (style2.fontFamily !== ((_a7 = this.textParentStyle) == null ? void 0 : _a7.fontFamily)) {
        elem.style.fontFamily = style2.fontFamily;
      }
      if (style2.fontVariant !== ((_b2 = this.textParentStyle) == null ? void 0 : _b2.fontVariant)) {
        elem.style.fontVariant = style2.fontVariant ?? "";
      }
      if (style2.fontWeight !== ((_c2 = this.textParentStyle) == null ? void 0 : _c2.fontWeight)) {
        elem.style.fontWeight = style2.fontWeight ?? "";
      }
      if (style2.fontStyle !== ((_d = this.textParentStyle) == null ? void 0 : _d.fontStyle)) {
        elem.style.fontStyle = style2.fontStyle ?? "";
      }
      if (style2.size !== ((_e = this.textParentStyle) == null ? void 0 : _e.size)) {
        elem.style.fontSize = style2.size + "px";
      }
      const fillString = style2.renderingStyle.fill.toHexString();
      elem.style.fill = fillString;
      if (style2.renderingStyle.stroke) {
        const strokeStyle = style2.renderingStyle.stroke;
        elem.style.stroke = strokeStyle.color.toHexString();
        elem.style.strokeWidth = strokeStyle.width + "px";
      }
    };
    transform = this.getCanvasToScreenTransform().rightMul(transform);
    if (!this.textContainer) {
      const container = document.createElementNS(svgNameSpace, "text");
      container.appendChild(document.createTextNode(text));
      this.transformFrom(transform, container, true);
      applyTextStyles(container, style);
      this.elem.appendChild(container);
      (_a6 = this.objectElems) == null ? void 0 : _a6.push(container);
      if (this.objectLevel > 0) {
        this.textContainer = container;
        this.textContainerTransform = transform;
        this.textParentStyle = { ...defaultTextStyle2, ...style };
      }
    } else {
      const elem = document.createElementNS(svgNameSpace, "tspan");
      elem.appendChild(document.createTextNode(text));
      this.textContainer.appendChild(elem);
      transform = this.textContainerTransform.inverse().rightMul(transform);
      const translation = transform.transformVec2(Vec2.zero);
      elem.setAttribute("x", `${toRoundedString(translation.x)}`);
      elem.setAttribute("y", `${toRoundedString(translation.y)}`);
      applyTextStyles(elem, style);
    }
  }
  drawImage(image) {
    var _a6;
    let label = image.label ?? image.image.getAttribute("aria-label") ?? "";
    if (label === "") {
      label = image.image.getAttribute("alt") ?? "";
    }
    const svgImgElem = document.createElementNS(svgNameSpace, "image");
    svgImgElem.setAttribute("href", image.base64Url);
    svgImgElem.setAttribute("width", image.image.getAttribute("width") ?? "");
    svgImgElem.setAttribute("height", image.image.getAttribute("height") ?? "");
    svgImgElem.setAttribute("aria-label", label);
    this.transformFrom(image.transform, svgImgElem);
    this.elem.appendChild(svgImgElem);
    (_a6 = this.objectElems) == null ? void 0 : _a6.push(svgImgElem);
  }
  startObject(boundingBox) {
    super.startObject(boundingBox);
    this.lastPathString = [];
    this.lastPathStyle = null;
    this.textContainer = null;
    this.textParentStyle = defaultTextStyle2;
    this.objectElems = [];
  }
  endObject(loaderData, elemClassNames) {
    super.endObject(loaderData);
    this.addPathToSVG();
    if (!this.objectElems) {
      return;
    }
    if (loaderData && !this.sanitize) {
      for (const elem of this.objectElems) {
        const attrs = loaderData[svgAttributesDataKey];
        const styleAttrs = loaderData[svgStyleAttributesDataKey];
        if (attrs) {
          for (const [attr, value] of attrs) {
            elem.setAttribute(attr, value);
          }
        }
        if (styleAttrs) {
          for (const attr of styleAttrs) {
            elem.style.setProperty(attr.key, attr.value, attr.priority);
          }
        }
      }
      const containerIDData = loaderData[svgLoaderAttributeContainerID];
      let containerIDList = [];
      if (containerIDData && containerIDData[0]) {
        if (containerIDData[0].length) {
          containerIDList = containerIDData[0];
        }
      }
      if (containerIDList.length > 0 && // containerIDList must share a prefix with the last ID list
      // otherwise, the z order of elements may have been changed from
      // the original image.
      // In the case that the z order has been changed, keep the current
      // element as a child of the root to preserve z order.
      listPrefixMatch_default(this.lastContainerIDList, containerIDList) && // The component can add at most one more parent than the previous item.
      this.lastContainerIDList.length >= containerIDList.length - 1) {
        const containerID = containerIDList[containerIDList.length - 1];
        const containerCandidates = this.elem.querySelectorAll(`g#${containerID}`);
        if (containerCandidates.length >= 1) {
          const container = containerCandidates[0];
          if (container.children.length === 0 || this.lastContainerIDList.length >= containerIDList.length) {
            for (const elem of this.objectElems) {
              elem.remove();
              container.appendChild(elem);
            }
          } else {
            containerIDList = [];
          }
        }
      } else {
        containerIDList = [];
      }
      this.lastContainerIDList = containerIDList;
    }
    if (elemClassNames && this.objectElems) {
      if (this.objectElems.length === 1) {
        this.objectElems[0].classList.add(...elemClassNames);
      } else {
        const wrapper = document.createElementNS(svgNameSpace, "g");
        wrapper.classList.add(...elemClassNames);
        for (const elem of this.objectElems) {
          elem.remove();
          wrapper.appendChild(elem);
        }
        this.elem.appendChild(wrapper);
      }
    }
  }
  // Not implemented -- use drawPath instead.
  unimplementedMessage() {
    throw new Error("Not implemenented!");
  }
  beginPath(_startPoint) {
    this.unimplementedMessage();
  }
  endPath(_style) {
    this.unimplementedMessage();
  }
  lineTo(_point) {
    this.unimplementedMessage();
  }
  moveTo(_point) {
    this.unimplementedMessage();
  }
  traceCubicBezierCurve(_controlPoint1, _controlPoint2, _endPoint) {
    this.unimplementedMessage();
  }
  traceQuadraticBezierCurve(_controlPoint, _endPoint) {
    this.unimplementedMessage();
  }
  drawPoints(...points) {
    points.map((point) => {
      const elem = document.createElementNS(svgNameSpace, "circle");
      elem.setAttribute("cx", `${point.x}`);
      elem.setAttribute("cy", `${point.y}`);
      elem.setAttribute("r", "15");
      this.elem.appendChild(elem);
    });
  }
  /**
   * Adds a **copy** of the given element directly to the container
   * SVG element, **without applying transforms**.
   *
   * If `sanitize` is enabled, this does nothing.
   */
  drawSVGElem(elem) {
    var _a6;
    if (this.sanitize) {
      return;
    }
    if (elem.tagName.toLowerCase() === "style" && elem.getAttribute("id") === renderedStylesheetId) {
      return;
    }
    const elemToDraw = elem.cloneNode(true);
    this.elem.appendChild(elemToDraw);
    (_a6 = this.objectElems) == null ? void 0 : _a6.push(elemToDraw);
  }
  /**
   * Allows rendering directly to the underlying SVG element. Rendered
   * content is added to a `<g>` element that's passed as `parent` to `callback`.
   *
   * **Note**: Unlike {@link drawSVGElem}, this method can be used even if `sanitize` is `true`.
   * In this case, it's the responsibility of `callback` to ensure that everything added
   * to `parent` is safe to render.
   */
  drawWithSVGParent(callback) {
    var _a6;
    const parent = document.createElementNS(svgNameSpace, "g");
    this.transformFrom(Mat33.identity, parent, true);
    callback(parent, { sanitize: this.sanitize });
    this.elem.appendChild(parent);
    (_a6 = this.objectElems) == null ? void 0 : _a6.push(parent);
  }
  isTooSmallToRender(_rect) {
    return false;
  }
  /**
   * Creates a new SVG element and `SVGRenerer` with `width`, `height`, `viewBox`,
   * and other metadata attributes set for the given `Viewport`.
   *
   * If `options` is a `boolean`, it is interpreted as whether to sanitize (not add unknown
   * SVG entities to) the output.
   */
  static fromViewport(viewport, options = true) {
    let sanitize;
    let useViewBoxForPositioning;
    if (typeof options === "boolean") {
      sanitize = options;
      useViewBoxForPositioning = false;
    } else {
      sanitize = options.sanitize ?? true;
      useViewBoxForPositioning = options.useViewBoxForPositioning ?? false;
    }
    const svgNameSpace2 = "http://www.w3.org/2000/svg";
    const result = document.createElementNS(svgNameSpace2, "svg");
    const screenRectSize = viewport.getScreenRectSize();
    const visibleRect = viewport.visibleRect;
    let viewBoxComponents;
    if (useViewBoxForPositioning) {
      const exportRect = viewport.visibleRect;
      viewBoxComponents = [exportRect.x, exportRect.y, exportRect.w, exportRect.h];
      viewport = viewport.getTemporaryClone();
      viewport.resetTransform(Mat33.identity);
    } else {
      viewBoxComponents = [0, 0, screenRectSize.x, screenRectSize.y];
    }
    result.setAttribute("viewBox", viewBoxComponents.map((part) => toRoundedString(part)).join(" "));
    result.setAttribute("width", toRoundedString(screenRectSize.x));
    result.setAttribute("height", toRoundedString(screenRectSize.y));
    result.setAttribute("version", "1.1");
    result.setAttribute("baseProfile", "full");
    result.setAttribute("xmlns", svgNameSpace2);
    const renderer = new _SVGRenderer(result, viewport, sanitize);
    if (!visibleRect.eq(viewport.visibleRect)) {
      renderer.overrideVisibleRect(visibleRect);
    }
    return { element: result, renderer };
  }
};

// node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionHandle.mjs
var HandleShape;
(function(HandleShape2) {
  HandleShape2[HandleShape2["Circle"] = 0] = "Circle";
  HandleShape2[HandleShape2["Square"] = 1] = "Square";
})(HandleShape || (HandleShape = {}));
var HandleAction;
(function(HandleAction2) {
  HandleAction2["ResizeXY"] = "resize-xy";
  HandleAction2["Rotate"] = "rotate";
  HandleAction2["ResizeX"] = "resize-x";
  HandleAction2["ResizeY"] = "resize-y";
})(HandleAction || (HandleAction = {}));
var handleSize = 30;
var SelectionHandle = class {
  constructor(presentation, parent, viewport, onDragStart, onDragUpdate, onDragEnd) {
    this.presentation = presentation;
    this.parent = parent;
    this.viewport = viewport;
    this.onDragStart = onDragStart;
    this.onDragUpdate = onDragUpdate;
    this.onDragEnd = onDragEnd;
    this.dragLastPos = null;
    this.element = document.createElement("div");
    this.element.classList.add(`${cssPrefix}handle`, `${cssPrefix}${presentation.action}`);
    const visibleContent = document.createElement("div");
    visibleContent.classList.add(`${cssPrefix}content`);
    this.element.appendChild(visibleContent);
    this.parentSide = presentation.side;
    const icon = presentation.icon;
    if (icon) {
      visibleContent.appendChild(icon);
      icon.classList.add("icon");
    }
    if (presentation.action === HandleAction.Rotate) {
      this.shape = HandleShape.Circle;
    } else {
      this.shape = HandleShape.Square;
    }
    switch (this.shape) {
      case HandleShape.Circle:
        this.element.classList.add(`${cssPrefix}circle`);
        break;
      case HandleShape.Square:
        this.element.classList.add(`${cssPrefix}square`);
        break;
      default:
        assertUnreachable(this.shape);
    }
    this.updatePosition();
  }
  /**
   * Adds this to `container`, where `conatiner` should be the background/selection
   * element visible on the screen.
   */
  addTo(container) {
    container.appendChild(this.element);
  }
  /**
   * Removes this element from its container. Should only be called
   * after {@link addTo}.
   */
  remove() {
    this.element.remove();
  }
  /**
   * Returns this handle's bounding box relative to the top left of the
   * selection box.
   */
  getBBoxParentCoords() {
    const parentRect = this.parent.getScreenRegion();
    const size = Vec2.of(handleSize, handleSize);
    const topLeft = parentRect.size.scale(this.parentSide).minus(size.times(1 / 2));
    return new Rect2(topLeft.x, topLeft.y, size.x, size.y);
  }
  /** @returns this handle's bounding box relative to the canvas. */
  getBBoxCanvasCoords() {
    const parentRect = this.parent.region;
    const size = Vec2.of(handleSize, handleSize).times(1 / this.viewport.getScaleFactor());
    const topLeftFromParent = parentRect.size.scale(this.parentSide).minus(size.times(0.5));
    return new Rect2(topLeftFromParent.x, topLeftFromParent.y, size.x, size.y).translatedBy(parentRect.topLeft);
  }
  /**
   * Moves the HTML representation of this to the location matching its internal representation.
   */
  updatePosition() {
    const bbox = this.getBBoxParentCoords();
    this.element.style.marginLeft = `${bbox.topLeft.x}px`;
    this.element.style.marginTop = `${bbox.topLeft.y}px`;
    this.element.style.width = `${bbox.w}px`;
    this.element.style.height = `${bbox.h}px`;
  }
  /** @returns true iff `point` (in editor **canvas** coordinates) is in this. */
  containsPoint(point) {
    const bbox = this.getBBoxCanvasCoords();
    const delta = point.minus(bbox.center);
    const radius = bbox.size.x / 2;
    let result;
    if (this.shape === HandleShape.Circle) {
      result = delta.magnitude() <= radius;
    } else {
      result = Math.abs(delta.x) <= radius && Math.abs(delta.y) <= radius;
    }
    return result;
  }
  handleDragStart(pointer) {
    this.onDragStart(pointer.canvasPos);
    this.dragLastPos = pointer.canvasPos;
    return true;
  }
  handleDragUpdate(pointer) {
    if (!this.dragLastPos) {
      return;
    }
    this.onDragUpdate(pointer.canvasPos);
  }
  handleDragEnd() {
    if (!this.dragLastPos) {
      return;
    }
    return this.onDragEnd();
  }
  setSnapToGrid(snap) {
    this.snapToGrid = snap;
  }
  isSnappingToGrid() {
    return this.snapToGrid;
  }
};

// node_modules/js-draw/dist/mjs/commands/Duplicate.mjs
var Duplicate = class extends SerializableCommand_default {
  constructor(toDuplicate, idsForDuplicates) {
    super("duplicate");
    this.toDuplicate = toDuplicate;
    this.duplicates = toDuplicate.map((elem, idx) => {
      if (idsForDuplicates && idsForDuplicates[idx]) {
        return elem.cloneWithId(idsForDuplicates[idx]);
      } else {
        return elem.clone();
      }
    });
    this.reverse = new Erase_default(this.duplicates);
  }
  apply(editor) {
    this.reverse.unapply(editor);
  }
  unapply(editor) {
    this.reverse.apply(editor);
  }
  onDrop(editor) {
    this.reverse.onDrop(editor);
  }
  description(_editor, localizationTable) {
    if (this.duplicates.length === 0) {
      return localizationTable.duplicatedNoElements;
    }
    return localizationTable.duplicateAction(describeComponentList_default(localizationTable, this.duplicates) ?? localizationTable.elements, this.duplicates.length);
  }
  serializeToJSON() {
    return {
      originalIds: this.toDuplicate.map((elem) => elem.getId()),
      cloneIds: this.duplicates.map((elem) => elem.getId())
    };
  }
};
(() => {
  SerializableCommand_default.register("duplicate", (json, editor) => {
    let originalIds;
    let cloneIds;
    if (Array.isArray(json)) {
      originalIds = json;
      cloneIds = [];
    } else {
      originalIds = json.originalIds;
      cloneIds = json.cloneIds;
    }
    assertIsStringArray(originalIds);
    assertIsStringArray(cloneIds);
    const resolvedElements = [];
    const filteredCloneIds = [];
    for (let i = 0; i < originalIds.length; i++) {
      const originalId = originalIds[i];
      const foundElement = editor.image.lookupElement(originalId);
      if (!foundElement) {
        console.warn("Duplicate command: Could not find element with ID", originalId);
      } else {
        filteredCloneIds.push(cloneIds[i]);
        resolvedElements.push(foundElement);
      }
    }
    return new Duplicate(resolvedElements, filteredCloneIds);
  });
})();
var Duplicate_default = Duplicate;

// node_modules/js-draw/dist/mjs/tools/SelectionTool/types.mjs
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2["Lasso"] = "lasso";
  SelectionMode2["Rectangle"] = "rect";
})(SelectionMode || (SelectionMode = {}));
var ResizeMode;
(function(ResizeMode2) {
  ResizeMode2[ResizeMode2["Both"] = 0] = "Both";
  ResizeMode2[ResizeMode2["HorizontalOnly"] = 1] = "HorizontalOnly";
  ResizeMode2[ResizeMode2["VerticalOnly"] = 2] = "VerticalOnly";
})(ResizeMode || (ResizeMode = {}));
var TransformMode;
(function(TransformMode2) {
  TransformMode2[TransformMode2["Snap"] = 0] = "Snap";
  TransformMode2[TransformMode2["NoSnap"] = 1] = "NoSnap";
})(TransformMode || (TransformMode = {}));

// node_modules/js-draw/dist/mjs/tools/SelectionTool/TransformMode.mjs
var DragTransformer = class {
  constructor(editor, selection) {
    this.editor = editor;
    this.selection = selection;
  }
  onDragStart(startPoint) {
    this.selection.setTransform(Mat33.identity);
    this.dragStartPoint = startPoint;
  }
  onDragUpdate(canvasPos) {
    const delta = this.editor.viewport.roundPoint(canvasPos.minus(this.dragStartPoint));
    this.selection.setTransform(Mat33.translation(delta));
  }
  onDragEnd() {
    return this.selection.finalizeTransform();
  }
};
var ResizeTransformer = class {
  constructor(editor, selection) {
    this.editor = editor;
    this.selection = selection;
    this.mode = ResizeMode.Both;
  }
  onDragStart(startPoint, mode) {
    this.selection.setTransform(Mat33.identity);
    this.mode = mode;
    this.dragStartPoint = startPoint;
    this.computeOriginAndScaleRate();
  }
  computeOriginAndScaleRate() {
    const selectionRect = this.selection.preTransformRegion;
    const selectionBoxCorners = selectionRect.corners;
    let largestDistSquared = 0;
    for (let i = 0; i < selectionBoxCorners.length; i++) {
      const currentCorner = selectionBoxCorners[i];
      const distSquaredToCurrent = this.dragStartPoint.minus(currentCorner).magnitudeSquared();
      if (distSquaredToCurrent > largestDistSquared) {
        largestDistSquared = distSquaredToCurrent;
        this.transformOrigin = currentCorner;
      }
    }
    let widthScaleRate = 1;
    let heightScaleRate = 1;
    if (this.transformOrigin.x > selectionRect.center.x) {
      widthScaleRate = -1;
    }
    if (this.transformOrigin.y > selectionRect.center.y) {
      heightScaleRate = -1;
    }
    this.scaleRate = Vec2.of(widthScaleRate, heightScaleRate);
  }
  onDragUpdate(canvasPos) {
    const canvasDelta = canvasPos.minus(this.dragStartPoint);
    const origWidth = this.selection.preTransformRegion.width;
    const origHeight = this.selection.preTransformRegion.height;
    let scale = Vec2.of(1, 1);
    if (this.mode === ResizeMode.HorizontalOnly) {
      const newWidth = origWidth + canvasDelta.x * this.scaleRate.x;
      scale = Vec2.of(newWidth / origWidth, scale.y);
    }
    if (this.mode === ResizeMode.VerticalOnly) {
      const newHeight = origHeight + canvasDelta.y * this.scaleRate.y;
      scale = Vec2.of(scale.x, newHeight / origHeight);
    }
    if (this.mode === ResizeMode.Both) {
      const delta = Math.abs(canvasDelta.x) > Math.abs(canvasDelta.y) ? canvasDelta.x : canvasDelta.y;
      const newWidth = origWidth + delta;
      scale = Vec2.of(newWidth / origWidth, newWidth / origWidth);
    }
    scale = scale.map((component) => Viewport_default.roundScaleRatio(component, 2));
    if (scale.x !== 0 && scale.y !== 0) {
      const origin = this.editor.viewport.roundPoint(this.transformOrigin);
      this.selection.setTransform(Mat33.scaling2D(scale, origin));
    }
  }
  onDragEnd() {
    return this.selection.finalizeTransform();
  }
};
var RotateTransformer = class {
  constructor(editor, selection) {
    this.editor = editor;
    this.selection = selection;
    this.startAngle = 0;
    this.targetRotation = 0;
    this.maximumDistFromStart = 0;
  }
  getAngle(canvasPoint) {
    const selectionCenter = this.selection.preTransformRegion.center;
    const offset = canvasPoint.minus(selectionCenter);
    return offset.angle();
  }
  roundAngle(angle) {
    const roundingFactor = 16 / 2 / Math.PI;
    return Math.round(angle * roundingFactor) / roundingFactor;
  }
  onDragStart(startPoint) {
    this.startPoint = startPoint;
    this.selection.setTransform(Mat33.identity);
    this.startAngle = this.getAngle(startPoint);
    this.targetRotation = 0;
    this.maximumDistFromStart = 0;
    this.startTime = performance.now();
  }
  setRotationTo(angle) {
    const canvasSelCenter = this.editor.viewport.roundPoint(this.selection.preTransformRegion.center);
    const unrounded = Mat33.zRotation(angle);
    const roundedRotationTransform = unrounded.mapEntries((entry) => Viewport_default.roundScaleRatio(entry));
    const fullRoundedTransform = Mat33.translation(canvasSelCenter).rightMul(roundedRotationTransform).rightMul(Mat33.translation(canvasSelCenter.times(-1)));
    this.selection.setTransform(fullRoundedTransform);
  }
  onDragUpdate(canvasPos) {
    this.targetRotation = this.roundAngle(this.getAngle(canvasPos) - this.startAngle);
    this.setRotationTo(this.targetRotation);
    const distFromStart = canvasPos.minus(this.startPoint).magnitude();
    if (distFromStart > this.maximumDistFromStart) {
      this.maximumDistFromStart = distFromStart;
    }
  }
  onDragEnd() {
    const clickThresholdDist = 10;
    const clickThresholdTime = 0.4;
    const dragTimeSeconds = (performance.now() - this.startTime) / 1e3;
    if (dragTimeSeconds < clickThresholdTime && this.maximumDistFromStart < clickThresholdDist && this.targetRotation === 0) {
      this.setRotationTo(-Math.PI / 2);
    }
    return this.selection.finalizeTransform();
  }
};

// node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionMenuShortcut.mjs
var verticalOffset = 40;
var SelectionMenuShortcut = class {
  constructor(parent, viewport, icon, showContextMenu, localization4) {
    this.parent = parent;
    this.viewport = viewport;
    this.icon = icon;
    this.localization = localization4;
    this.lastDragPointer = null;
    this.element = document.createElement("div");
    this.element.classList.add(`${cssPrefix}handle`, `${cssPrefix}selection-menu`);
    this.element.style.setProperty("--vertical-offset", `${verticalOffset}px`);
    this.onClick = () => {
      var _a6;
      (_a6 = this.button) == null ? void 0 : _a6.focus({ preventScroll: true });
      const anchor = this.getBBoxCanvasCoords().center;
      showContextMenu(anchor);
    };
    this.initUI();
    this.updatePosition();
  }
  initUI() {
    const button = document.createElement("button");
    this.icon.classList.add("icon");
    button.replaceChildren(this.icon);
    button.ariaLabel = this.localization.selectionMenu__show;
    button.title = button.ariaLabel;
    this.button = button;
    button.onkeydown = (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        this.onClick();
      }
    };
    this.element.appendChild(button);
    requestAnimationFrame(() => {
      this.updatePosition();
    });
  }
  addTo(container) {
    container.appendChild(this.element);
  }
  remove() {
    this.element.remove();
  }
  getElementScreenSize() {
    return Vec2.of(this.element.clientWidth, this.element.clientHeight);
  }
  /** Gets this menu's bounding box relative to the top left of its parent. */
  getBBoxParentCoords() {
    const topLeft = Vec2.of(0, -verticalOffset);
    const screenSize = this.getElementScreenSize();
    return new Rect2(topLeft.x, topLeft.y, screenSize.x, screenSize.y);
  }
  getBBoxCanvasCoords() {
    const parentCanvasRect = this.parent.region;
    const toCanvasScale = this.viewport.getSizeOfPixelOnCanvas();
    const contentCanvasSize = this.getElementScreenSize().times(toCanvasScale);
    const handleSizeCanvas = verticalOffset / this.viewport.getScaleFactor();
    const topLeft = Vec2.of(parentCanvasRect.x, parentCanvasRect.y - handleSizeCanvas);
    const minSize = Vec2.of(48, 48).times(toCanvasScale);
    return new Rect2(topLeft.x, topLeft.y, contentCanvasSize.x, contentCanvasSize.y).grownToSize(minSize);
  }
  updatePosition() {
    const bbox = this.getBBoxParentCoords();
    this.element.style.marginLeft = `${bbox.topLeft.x}px`;
    this.element.style.marginTop = `${bbox.topLeft.y}px`;
  }
  containsPoint(canvasPoint) {
    return this.getBBoxCanvasCoords().containsPoint(canvasPoint);
  }
  handleDragStart(pointer) {
    this.lastDragPointer = pointer;
    return true;
  }
  handleDragUpdate(pointer) {
    this.lastDragPointer = pointer;
  }
  handleDragEnd() {
    if (this.lastDragPointer && this.containsPoint(this.lastDragPointer.canvasPos)) {
      this.onClick();
    }
    this.lastDragPointer = null;
  }
};

// node_modules/js-draw/dist/mjs/tools/SelectionTool/Selection.mjs
var _a4;
var updateChunkSize = 100;
var maxPreviewElemCount = 500;
var Selection = class {
  constructor(selectedElems, editor, showContextMenu) {
    this.editor = editor;
    this.selectionTightBoundingBox = null;
    this.transform = Mat33.identity;
    this.selectedElems = [];
    this.hasParent = true;
    this.removedFromImage = {};
    this.activeHandle = null;
    this.backgroundDragging = false;
    this.selectionDuplicatedAnimationTimeout = null;
    selectedElems = [...selectedElems];
    this.selectedElems = selectedElems;
    this.originalRegion = Rect2.empty;
    this.transformers = {
      drag: new DragTransformer(editor, this),
      resize: new ResizeTransformer(editor, this),
      rotate: new RotateTransformer(editor, this)
    };
    this.outerContainer = document.createElement("div");
    this.outerContainer.classList.add(`${cssPrefix}selection-outer-container`);
    this.innerContainer = document.createElement("div");
    this.innerContainer.classList.add(`${cssPrefix}selection-inner-container`);
    this.backgroundElem = document.createElement("div");
    this.backgroundElem.classList.add(`${cssPrefix}selection-background`);
    this.innerContainer.appendChild(this.backgroundElem);
    this.outerContainer.appendChild(this.innerContainer);
    const makeResizeHandle = (mode, side) => {
      const modeToAction = {
        [ResizeMode.Both]: HandleAction.ResizeXY,
        [ResizeMode.HorizontalOnly]: HandleAction.ResizeX,
        [ResizeMode.VerticalOnly]: HandleAction.ResizeY
      };
      return new SelectionHandle({
        action: modeToAction[mode],
        side
      }, this, this.editor.viewport, (startPoint) => this.transformers.resize.onDragStart(startPoint, mode), (currentPoint) => this.transformers.resize.onDragUpdate(currentPoint), () => this.transformers.resize.onDragEnd());
    };
    const resizeHorizontalHandles = [
      makeResizeHandle(ResizeMode.HorizontalOnly, Vec2.of(0, 0.5)),
      makeResizeHandle(ResizeMode.HorizontalOnly, Vec2.of(1, 0.5))
    ];
    const resizeVerticalHandle = makeResizeHandle(ResizeMode.VerticalOnly, Vec2.of(0.5, 1));
    const resizeBothHandle = makeResizeHandle(ResizeMode.Both, Vec2.of(1, 1));
    const rotationHandle = new SelectionHandle({
      action: HandleAction.Rotate,
      side: Vec2.of(0.5, 0),
      icon: this.editor.icons.makeRotateIcon()
    }, this, this.editor.viewport, (startPoint) => this.transformers.rotate.onDragStart(startPoint), (currentPoint) => this.transformers.rotate.onDragUpdate(currentPoint), () => this.transformers.rotate.onDragEnd());
    const menuToggleButton = new SelectionMenuShortcut(this, this.editor.viewport, this.editor.icons.makeOverflowIcon(), showContextMenu, this.editor.localization);
    this.childwidgets = [
      menuToggleButton,
      resizeBothHandle,
      ...resizeHorizontalHandles,
      resizeVerticalHandle,
      rotationHandle
    ];
    for (const widget of this.childwidgets) {
      widget.addTo(this.backgroundElem);
    }
    this.recomputeRegion();
    this.updateUI();
  }
  // @internal Intended for unit tests
  getBackgroundElem() {
    return this.backgroundElem;
  }
  getTransform() {
    return this.transform;
  }
  get preTransformRegion() {
    return this.originalRegion;
  }
  // The **canvas** region.
  get region() {
    const rotationMatrix = Mat33.zRotation(this.regionRotation, this.originalRegion.center);
    const scaleAndTranslateMat = this.transform.rightMul(rotationMatrix.inverse());
    return this.originalRegion.transformedBoundingBox(scaleAndTranslateMat);
  }
  /**
   * Computes and returns the bounding box of the selection without
   * any additional padding. Computes directly from the elements that are selected.
   * @internal
   */
  computeTightBoundingBox() {
    const bbox = this.selectedElems.reduce((accumulator, elem) => {
      return (accumulator ?? elem.getBBox()).union(elem.getBBox());
    }, null);
    return bbox ?? Rect2.empty;
  }
  get regionRotation() {
    return this.transform.transformVec3(Vec2.unitX).angle();
  }
  get preTransformedScreenRegion() {
    const toScreen = (vec) => this.editor.viewport.canvasToScreen(vec);
    return Rect2.fromCorners(toScreen(this.preTransformRegion.topLeft), toScreen(this.preTransformRegion.bottomRight));
  }
  get preTransformedScreenRegionRotation() {
    return this.editor.viewport.getRotationAngle();
  }
  getScreenRegion() {
    const toScreen = this.editor.viewport.canvasToScreenTransform;
    const scaleFactor = this.editor.viewport.getScaleFactor();
    const screenCenter = toScreen.transformVec2(this.region.center);
    return new Rect2(screenCenter.x, screenCenter.y, scaleFactor * this.region.width, scaleFactor * this.region.height).translatedBy(this.region.size.times(-scaleFactor / 2));
  }
  get screenRegionRotation() {
    return this.regionRotation + this.editor.viewport.getRotationAngle();
  }
  // Applies, previews, but doesn't finalize the given transformation.
  setTransform(transform, preview = true) {
    this.transform = transform;
    if (preview && this.hasParent) {
      this.previewTransformCmds();
    }
  }
  getDeltaZIndexToMoveSelectionToTop() {
    var _a6;
    if (this.selectedElems.length === 0) {
      return 0;
    }
    const selectedBottommostZIndex = this.selectedElems[0].getZIndex();
    const visibleObjects = this.editor.image.getComponentsIntersecting(this.region);
    const topMostVisibleZIndex = ((_a6 = visibleObjects[visibleObjects.length - 1]) == null ? void 0 : _a6.getZIndex()) ?? selectedBottommostZIndex;
    const deltaZIndex = topMostVisibleZIndex + 1 - selectedBottommostZIndex;
    return deltaZIndex;
  }
  // Applies the current transformation to the selection
  finalizeTransform() {
    const fullTransform = this.transform;
    const selectedElems = this.selectedElems;
    this.originalRegion = this.originalRegion.transformedBoundingBox(this.transform);
    this.transform = Mat33.identity;
    this.scrollTo();
    let transformPromise = void 0;
    if (this.selectedElems.length > 0) {
      const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();
      transformPromise = this.editor.dispatch(new _a4.ApplyTransformationCommand(this, selectedElems, this.originalRegion.center, fullTransform, deltaZIndex));
    }
    return transformPromise;
  }
  /** Sends all selected elements to the bottom of the visible image. */
  sendToBack() {
    var _a6, _b2;
    const visibleObjects = this.editor.image.getComponentsIntersecting(this.editor.viewport.visibleRect);
    const lowestVisibleZIndex = ((_a6 = visibleObjects[0]) == null ? void 0 : _a6.getZIndex()) ?? 0;
    const highestSelectedZIndex = ((_b2 = this.selectedElems[this.selectedElems.length - 1]) == null ? void 0 : _b2.getZIndex()) ?? 0;
    const targetHighestZIndex = lowestVisibleZIndex - 1;
    const deltaZIndex = targetHighestZIndex - highestSelectedZIndex;
    if (deltaZIndex !== 0) {
      const commands = this.selectedElems.map((elem) => {
        return elem.setZIndex(elem.getZIndex() + deltaZIndex);
      });
      return uniteCommands_default(commands, updateChunkSize);
    }
    return null;
  }
  // Preview the effects of the current transformation on the selection
  previewTransformCmds() {
    if (this.selectedElems.length === 0) {
      return;
    }
    if (this.selectedElems.length > maxPreviewElemCount) {
      this.updateUI();
      return;
    }
    const wetInkRenderer = this.editor.display.getWetInkRenderer();
    wetInkRenderer.clear();
    wetInkRenderer.pushTransform(this.transform);
    const viewportVisibleRect = this.editor.viewport.visibleRect.union(this.region);
    const visibleRect = viewportVisibleRect.transformedBoundingBox(this.transform.inverse());
    for (const elem of this.selectedElems) {
      elem.render(wetInkRenderer, visibleRect);
    }
    wetInkRenderer.popTransform();
    this.updateUI();
  }
  // Recompute this' region from the selected elements.
  // Returns false if the selection is empty.
  recomputeRegion() {
    const newRegion = this.computeTightBoundingBox();
    this.selectionTightBoundingBox = newRegion;
    if (!newRegion) {
      this.cancelSelection();
      return false;
    }
    this.originalRegion = newRegion;
    this.padRegion();
    return true;
  }
  // Applies padding to the current region if it is too small.
  // @internal
  padRegion() {
    const sourceRegion = this.selectionTightBoundingBox ?? this.originalRegion;
    const minSize = this.getMinCanvasSize();
    if (sourceRegion.w < minSize || sourceRegion.h < minSize) {
      const padding = minSize / 2;
      this.originalRegion = Rect2.bboxOf(sourceRegion.corners, padding);
      this.updateUI();
    }
  }
  getMinCanvasSize() {
    const canvasHandleSize = handleSize / this.editor.viewport.getScaleFactor();
    return canvasHandleSize * 2;
  }
  getSelectedItemCount() {
    return this.selectedElems.length;
  }
  // @internal
  updateUI() {
    if (!this.hasParent) {
      return;
    }
    const screenRegion = this.getScreenRegion();
    this.backgroundElem.style.marginLeft = `${screenRegion.topLeft.x}px`;
    this.backgroundElem.style.marginTop = `${screenRegion.topLeft.y}px`;
    this.backgroundElem.style.width = `${screenRegion.width}px`;
    this.backgroundElem.style.height = `${screenRegion.height}px`;
    const rotationDeg = this.screenRegionRotation * 180 / Math.PI;
    this.backgroundElem.style.transform = `rotate(${rotationDeg}deg)`;
    this.backgroundElem.style.transformOrigin = "center";
    const perpendicularClassName = `${cssPrefix}rotated-near-perpendicular`;
    if (Math.abs(Math.sin(this.screenRegionRotation)) > 0.5) {
      this.innerContainer.classList.add(perpendicularClassName);
    } else {
      this.innerContainer.classList.remove(perpendicularClassName);
    }
    if (screenRegion.width === 0 && screenRegion.height === 0) {
      this.innerContainer.classList.add("-empty");
    } else {
      this.innerContainer.classList.remove("-empty");
    }
    for (const widget of this.childwidgets) {
      widget.updatePosition(this.getScreenRegion());
    }
  }
  // Add/remove the contents of this seleciton from the editor.
  // Used to prevent previewed content from looking like duplicate content
  // while dragging.
  //
  // Does nothing if a large number of elements are selected (and so modifying
  // the editor image is likely to be slow.)
  //
  // If removed from the image, selected elements are drawn as wet ink.
  //
  // [inImage] should be `true` if the selected elements should be added to the
  // main image, `false` if they should be removed.
  addRemoveSelectionFromImage(inImage) {
    if (!inImage && this.selectedElems.length > maxPreviewElemCount) {
      return;
    }
    for (const elem of this.selectedElems) {
      const parent = this.editor.image.findParent(elem);
      if (!inImage && parent) {
        this.removedFromImage[elem.getId()] = true;
        parent.remove();
      } else if (!parent && this.removedFromImage[elem.getId()]) {
        EditorImage_default.addComponent(elem).apply(this.editor);
        this.removedFromImage[elem.getId()] = false;
        delete this.removedFromImage[elem.getId()];
      }
    }
    this.editor.queueRerender().then(() => {
      if (!inImage) {
        this.previewTransformCmds();
      } else {
        const wetInkRenderer = this.editor.display.getWetInkRenderer();
        wetInkRenderer.clear();
      }
    });
  }
  removeDeletedElemsFromSelection() {
    this.selectedElems = this.selectedElems.filter((elem) => {
      const hasParent = !!this.editor.image.findParent(elem);
      const weRemoved = this.removedFromImage[elem.getId()];
      return hasParent || weRemoved;
    });
  }
  onDragStart(pointer) {
    var _a6;
    if (this.selectedElems.length === 0) {
      return false;
    }
    (_a6 = document.getSelection()) == null ? void 0 : _a6.removeAllRanges();
    this.activeHandle = null;
    let result = false;
    this.backgroundDragging = false;
    if (this.region.containsPoint(pointer.canvasPos)) {
      this.backgroundDragging = true;
      result = true;
    }
    for (const widget of this.childwidgets) {
      if (widget.containsPoint(pointer.canvasPos)) {
        this.activeHandle = widget;
        this.backgroundDragging = false;
        result = true;
      }
    }
    if (result) {
      this.removeDeletedElemsFromSelection();
      this.addRemoveSelectionFromImage(false);
    }
    if (this.activeHandle) {
      this.activeHandle.handleDragStart(pointer);
    }
    if (this.backgroundDragging) {
      this.transformers.drag.onDragStart(pointer.canvasPos);
    }
    return result;
  }
  onDragUpdate(pointer) {
    if (this.backgroundDragging) {
      this.transformers.drag.onDragUpdate(pointer.canvasPos);
    }
    if (this.activeHandle) {
      this.activeHandle.handleDragUpdate(pointer);
    }
  }
  onDragEnd() {
    if (this.backgroundDragging) {
      this.transformers.drag.onDragEnd();
    } else if (this.activeHandle) {
      this.activeHandle.handleDragEnd();
    }
    this.addRemoveSelectionFromImage(true);
    this.backgroundDragging = false;
    this.activeHandle = null;
    this.updateUI();
  }
  onDragCancel() {
    this.backgroundDragging = false;
    this.activeHandle = null;
    this.setTransform(Mat33.identity);
    this.addRemoveSelectionFromImage(true);
    this.updateUI();
  }
  // Scroll the viewport to this. Does not zoom
  scrollTo() {
    if (this.selectedElems.length === 0) {
      return false;
    }
    const screenSize = this.editor.viewport.getScreenRectSize();
    const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);
    const selectionScreenRegion = this.getScreenRegion();
    if (!screenRect.containsPoint(selectionScreenRegion.center)) {
      const targetPointScreen = selectionScreenRegion.center;
      const closestPointScreen = screenRect.getClosestPointOnBoundaryTo(targetPointScreen);
      const closestPointCanvas = this.editor.viewport.screenToCanvas(closestPointScreen);
      const targetPointCanvas = this.region.center;
      const delta = closestPointCanvas.minus(targetPointCanvas);
      this.editor.dispatchNoAnnounce(Viewport_default.transformBy(Mat33.translation(delta.times(0.5))), false);
      this.editor.queueRerender().then(() => {
        this.previewTransformCmds();
      });
      return true;
    }
    return false;
  }
  deleteSelectedObjects() {
    if (this.backgroundDragging || this.activeHandle) {
      this.onDragEnd();
    }
    return new Erase_default(this.selectedElems);
  }
  runSelectionDuplicatedAnimation() {
    if (this.selectionDuplicatedAnimationTimeout) {
      clearTimeout(this.selectionDuplicatedAnimationTimeout);
    }
    const animationDuration = 400;
    this.backgroundElem.style.animation = `${animationDuration}ms ease selection-duplicated-animation`;
    this.selectionDuplicatedAnimationTimeout = setTimeout(() => {
      this.backgroundElem.style.animation = "";
      this.selectionDuplicatedAnimationTimeout = null;
    }, animationDuration);
  }
  async duplicateSelectedObjects() {
    const wasTransforming = this.backgroundDragging || this.activeHandle;
    let tmpApplyCommand = null;
    if (!wasTransforming) {
      this.runSelectionDuplicatedAnimation();
    }
    let command;
    if (wasTransforming) {
      const selectionToUpdate = null;
      const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();
      tmpApplyCommand = new _a4.ApplyTransformationCommand(selectionToUpdate, this.selectedElems, this.region.center, this.transform, deltaZIndex);
      await tmpApplyCommand.apply(this.editor);
      this.addRemoveSelectionFromImage(true);
      command = uniteCommands_default(this.selectedElems.map((elem) => {
        return EditorImage_default.addComponent(elem.clone());
      }));
      await (tmpApplyCommand == null ? void 0 : tmpApplyCommand.unapply(this.editor));
      this.addRemoveSelectionFromImage(false);
      this.previewTransformCmds();
      this.updateUI();
    } else {
      command = new Duplicate_default(this.selectedElems);
    }
    return command;
  }
  snapSelectedObjectsToGrid() {
    const viewport = this.editor.viewport;
    const topLeftOfBBox = this.computeTightBoundingBox().topLeft;
    const snappedTopLeft = viewport.snapToGrid(topLeftOfBBox);
    const snapDelta = snappedTopLeft.minus(topLeftOfBBox);
    const oldTransform = this.getTransform();
    this.setTransform(oldTransform.rightMul(Mat33.translation(snapDelta)));
    this.finalizeTransform();
  }
  setHandlesVisible(showHandles) {
    if (!showHandles) {
      this.innerContainer.classList.add("-hide-handles");
    } else {
      this.innerContainer.classList.remove("-hide-handles");
    }
  }
  addTo(elem) {
    if (this.outerContainer.parentElement) {
      this.outerContainer.remove();
    }
    elem.appendChild(this.outerContainer);
    this.hasParent = true;
  }
  setToPoint(point) {
    this.originalRegion = this.originalRegion.grownToPoint(point);
    this.selectionTightBoundingBox = null;
    this.updateUI();
  }
  cancelSelection() {
    if (this.outerContainer.parentElement) {
      this.outerContainer.remove();
    }
    this.originalRegion = Rect2.empty;
    this.selectionTightBoundingBox = null;
    this.hasParent = false;
  }
  getSelectedObjects() {
    return [...this.selectedElems];
  }
};
_a4 = Selection;
(() => {
  SerializableCommand_default.register("selection-tool-transform", (json, _editor) => {
    const rawTransformArray = json.transform;
    const rawCenterArray = json.selectionCenter ?? [0, 0];
    const rawElementIds = json.elems ?? [];
    assertIsNumberArray(rawTransformArray);
    assertIsNumberArray(rawCenterArray);
    assertIsStringArray(rawElementIds);
    const fullTransform = new Mat33(...rawTransformArray);
    const elemIds = rawElementIds;
    const deltaZIndex = parseInt(json.deltaZIndex ?? 0);
    const center = Vec2.of(rawCenterArray[0] ?? 0, rawCenterArray[1] ?? 0);
    return new _a4.ApplyTransformationCommand(null, elemIds, center, fullTransform, deltaZIndex);
  });
})();
Selection.ApplyTransformationCommand = class extends SerializableCommand_default {
  constructor(selection, selectedElems, selectionCenter, fullTransform, deltaZIndex) {
    super("selection-tool-transform");
    this.selection = selection;
    this.selectionCenter = selectionCenter;
    this.fullTransform = fullTransform;
    this.deltaZIndex = deltaZIndex;
    const isIDList = (arr) => {
      return typeof arr[0] === "string";
    };
    if (isIDList(selectedElems)) {
      this.selectedElemIds = selectedElems;
    } else {
      this.selectedElemIds = selectedElems.map((elem) => elem.getId());
      this.transformCommands = selectedElems.map((elem) => {
        return elem.setZIndexAndTransformBy(this.fullTransform, elem.getZIndex() + deltaZIndex);
      });
    }
  }
  resolveToElems(editor, isUndoing) {
    if (this.transformCommands) {
      return;
    }
    this.transformCommands = this.selectedElemIds.map((id) => {
      const elem = editor.image.lookupElement(id);
      if (!elem) {
        console.warn(`Unable to find element with ID, ${id}.`);
        return null;
      }
      let originalZIndex = elem.getZIndex();
      let targetZIndex = elem.getZIndex() + this.deltaZIndex;
      if (isUndoing) {
        targetZIndex = elem.getZIndex();
        originalZIndex = elem.getZIndex() - this.deltaZIndex;
      }
      return elem.setZIndexAndTransformBy(this.fullTransform, targetZIndex, originalZIndex);
    }).filter(
      // Remove all null commands
      (command) => command !== null
    );
  }
  async apply(editor) {
    var _a6, _b2, _c2, _d, _e;
    this.resolveToElems(editor, false);
    (_a6 = this.selection) == null ? void 0 : _a6.setTransform(this.fullTransform, false);
    (_b2 = this.selection) == null ? void 0 : _b2.updateUI();
    await editor.asyncApplyCommands(this.transformCommands, updateChunkSize);
    (_c2 = this.selection) == null ? void 0 : _c2.setTransform(Mat33.identity, false);
    (_d = this.selection) == null ? void 0 : _d.recomputeRegion();
    (_e = this.selection) == null ? void 0 : _e.updateUI();
  }
  async unapply(editor) {
    var _a6, _b2, _c2, _d, _e;
    this.resolveToElems(editor, true);
    (_a6 = this.selection) == null ? void 0 : _a6.setTransform(this.fullTransform.inverse(), false);
    (_b2 = this.selection) == null ? void 0 : _b2.updateUI();
    await editor.asyncUnapplyCommands(this.transformCommands, updateChunkSize, true);
    (_c2 = this.selection) == null ? void 0 : _c2.setTransform(Mat33.identity, false);
    (_d = this.selection) == null ? void 0 : _d.recomputeRegion();
    (_e = this.selection) == null ? void 0 : _e.updateUI();
  }
  serializeToJSON() {
    return {
      elems: this.selectedElemIds,
      transform: this.fullTransform.toArray(),
      deltaZIndex: this.deltaZIndex,
      selectionCenter: this.selectionCenter.asArray()
    };
  }
  description(_editor, localizationTable) {
    return localizationTable.transformedElements(this.selectedElemIds.length, describeTransformation_default(this.selectionCenter, this.fullTransform, false, localizationTable));
  }
};
var Selection_default = Selection;

// node_modules/js-draw/dist/mjs/tools/SelectionTool/ToPointerAutoscroller.mjs
var ToPointerAutoscroller = class {
  constructor(viewport, scrollByCanvasDelta) {
    this.viewport = viewport;
    this.scrollByCanvasDelta = scrollByCanvasDelta;
    this.started = false;
    this.updateLoopId = 0;
    this.updateLoopRunning = false;
    this.targetPoint = null;
    this.scrollRate = 1e3;
  }
  getScrollForPoint(screenPoint) {
    const screenSize = this.viewport.getScreenRectSize();
    const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);
    const marginSize = 44;
    const autoscrollBoundary = screenRect.grownBy(-marginSize);
    if (autoscrollBoundary.containsPoint(screenPoint)) {
      return Vec2.zero;
    }
    const closestEdgePoint = autoscrollBoundary.getClosestPointOnBoundaryTo(screenPoint);
    const distToEdge = closestEdgePoint.distanceTo(screenPoint);
    const toEdge = closestEdgePoint.minus(screenPoint);
    const maximumScaleFactor = 1.25;
    const scaleFactor = Math.min(distToEdge / marginSize, maximumScaleFactor);
    return toEdge.normalizedOrZero().times(scaleFactor);
  }
  start() {
    this.started = true;
  }
  onPointerMove(pointerScreenPosition) {
    if (!this.started) {
      return;
    }
    if (this.getScrollForPoint(pointerScreenPosition) === Vec2.zero) {
      this.stopUpdateLoop();
    } else {
      this.targetPoint = pointerScreenPosition;
      this.startUpdateLoop();
    }
  }
  stop() {
    this.targetPoint = null;
    this.started = false;
    this.stopUpdateLoop();
  }
  startUpdateLoop() {
    if (this.updateLoopRunning) {
      return;
    }
    (async () => {
      this.updateLoopId++;
      const currentUpdateLoopId = this.updateLoopId;
      let lastUpdateTime = performance.now();
      while (this.updateLoopId === currentUpdateLoopId && this.targetPoint) {
        this.updateLoopRunning = true;
        const currentTime = performance.now();
        const deltaTimeMs = currentTime - lastUpdateTime;
        const scrollDirection = this.getScrollForPoint(this.targetPoint);
        const screenScrollAmount = scrollDirection.times(this.scrollRate * deltaTimeMs / 1e3);
        this.scrollByCanvasDelta(this.viewport.screenToCanvasTransform.transformVec3(screenScrollAmount));
        lastUpdateTime = currentTime;
        await untilNextAnimationFrame_default();
      }
      this.updateLoopRunning = false;
    })();
  }
  stopUpdateLoop() {
    this.updateLoopId++;
  }
};

// node_modules/js-draw/dist/mjs/util/waitForTimeout.mjs
var waitForTimeout = (timeout) => {
  return new Promise((resolve) => {
    setTimeout(() => resolve(), timeout);
  });
};
var waitForTimeout_default = waitForTimeout;

// node_modules/js-draw/dist/mjs/tools/util/createMenuOverlay.mjs
var idCounter = 0;
var createMenuOverlay = async (editor, canvasAnchor, options) => {
  const overlay = document.createElement("div");
  const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);
  const menuModal = document.createElement("dialog");
  menuModal.classList.add("editor-popup-menu");
  const hideMenuTimeout = 240;
  menuModal.style.setProperty("--hide-menu-animation-timeout", `${hideMenuTimeout}ms`);
  const updateMenuLocation = () => {
    const overlayRect = editor.getOutputBBoxInDOM();
    const anchor = editor.viewport.canvasToScreen(canvasAnchor).plus(overlayRect.topLeft);
    menuModal.style.setProperty("--anchor-x", `${anchor.x}px`);
    menuModal.style.setProperty("--anchor-y", `${anchor.y}px`);
  };
  updateMenuLocation();
  const viewportChangeListener = editor.notifier.on(EditorEventType.ViewportChanged, updateMenuLocation);
  overlay.appendChild(menuModal);
  let dismissing = false;
  const dismissMenu = async () => {
    if (dismissing)
      return;
    dismissing = true;
    viewportChangeListener.remove();
    menuModal.classList.add("-hide");
    await waitForTimeout_default(hideMenuTimeout);
    menuModal.close();
  };
  return new Promise((resolve) => {
    let resolved = false;
    let result = null;
    const resolveWithSelectedResult = () => {
      if (!resolved) {
        resolve(result);
        resolved = true;
      }
    };
    menuModal.onclose = () => {
      removeOverlay();
      resolveWithSelectedResult();
    };
    const onOptionSelected = (key) => {
      result = key;
      void dismissMenu();
      resolveWithSelectedResult();
    };
    editor.handlePointerEventsExceptClicksFrom(menuModal, (eventName, event) => {
      if (event.target === menuModal && eventName === "pointerdown") {
        void dismissMenu();
        return true;
      } else if (dismissing) {
        return true;
      }
      return false;
    }, (_eventName, event) => {
      return event.target === menuModal;
    });
    const contentElement = document.createElement("div");
    contentElement.classList.add("content");
    contentElement.role = "menu";
    const optionElements = [];
    contentElement.addEventListener("keydown", (event) => {
      const focusedIndex = optionElements.findIndex((item) => item === document.activeElement);
      if (focusedIndex === -1)
        return;
      let newFocusedIndex = focusedIndex;
      if (event.key === "ArrowDown") {
        newFocusedIndex++;
      } else if (event.key === "ArrowUp") {
        newFocusedIndex--;
      } else if (event.key === "End") {
        newFocusedIndex = optionElements.length - 1;
      } else if (event.key === "Home") {
        newFocusedIndex = 0;
      }
      if (newFocusedIndex < 0) {
        newFocusedIndex += optionElements.length;
      }
      newFocusedIndex %= optionElements.length;
      if (newFocusedIndex !== focusedIndex) {
        event.preventDefault();
        optionElements[newFocusedIndex].focus();
      }
    });
    for (const option of options) {
      const optionElement = document.createElement("button");
      optionElement.id = `menu-overlay-option-${idCounter++}`;
      optionElement.role = "menuitem";
      optionElement.classList.add("option", "editor-popup-menu-option");
      optionElement.replaceChildren(option.icon(), document.createTextNode(option.text));
      optionElement.onclick = (event) => {
        if (event.defaultPrevented)
          return;
        onOptionSelected(option.key);
      };
      contentElement.appendChild(optionElement);
      if (optionElements.length === 0) {
        optionElement.autofocus = true;
      }
      optionElements.push(optionElement);
    }
    menuModal.appendChild(contentElement);
    menuModal.showModal();
    contentElement.scrollIntoView({ block: "nearest" });
  });
};
var createMenuOverlay_default = createMenuOverlay;

// node_modules/js-draw/dist/mjs/util/fileToBase64Url.mjs
var fileToBase64Url = async (file, options = {}) => {
  try {
    const reader = new FileReader();
    return await new Promise((resolve, reject) => {
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.onabort = reject;
      reader.onprogress = (evt) => {
        var _a6;
        (_a6 = options.onprogress) == null ? void 0 : _a6.call(options, evt);
      };
      reader.readAsDataURL(file);
    });
  } catch (error) {
    (options.onWarning ?? console.warn)("Unable to convert file to base64 with a FileReader: ", error);
    const arrayBuffer = await file.arrayBuffer();
    const array = new Uint8Array(arrayBuffer);
    const step = 30;
    const result = [];
    for (let i = 0; i < array.length; i += step) {
      const stringByteArray = String.fromCharCode(...array.slice(i, i + step));
      result.push(btoa(stringByteArray));
    }
    return `data:${file.type ?? "image/*"};base64,${result.join("")}`;
  }
};
var fileToBase64Url_default = fileToBase64Url;

// node_modules/js-draw/dist/mjs/util/ClipboardHandler.mjs
var __classPrivateFieldGet7 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet7 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _ClipboardHandler_preferClipboardEvents;
var isTextMimeType = (mime) => (
  // +xml: Handles image/svg+xml
  mime.endsWith("+xml") || mime.startsWith("text/")
);
var ClipboardHandler = class {
  constructor(editor, callbacks) {
    this.editor = editor;
    this.callbacks = callbacks;
    _ClipboardHandler_preferClipboardEvents.set(this, false);
  }
  /**
   * Pastes data from the clipboard into the editor associated with
   * this handler.
   *
   * @param event Optional -- a clipboard/drag event. If not provided,
   * 				`navigator.clipboard` will be used instead.
   * @returns true if the paste event was handled by the editor.
   */
  paste(event) {
    const onError = (error) => {
      var _a6;
      if ((_a6 = this.callbacks) == null ? void 0 : _a6.onPasteError) {
        this.callbacks.onPasteError(error);
        return Promise.resolve(false);
      } else {
        throw error;
      }
    };
    try {
      return this.pasteInternal(event).catch(onError);
    } catch (error) {
      return onError(error);
    }
  }
  async pasteInternal(event) {
    const editor = this.editor;
    const clipboardData = (event == null ? void 0 : event.dataTransfer) ?? (event == null ? void 0 : event.clipboardData) ?? null;
    const hasEvent = !!clipboardData;
    const sendPasteEvent = (mime, data) => {
      return data && editor.toolController.dispatchInputEvent({
        kind: InputEvtType.PasteEvent,
        mime,
        data
      });
    };
    const supportedMIMEs = ["image/svg+xml", "text/html", "image/png", "image/jpeg", "text/plain"];
    let files = [];
    const textData = /* @__PURE__ */ new Map();
    const editorSettings = editor.getCurrentSettings();
    if (hasEvent) {
      files = [...clipboardData.files];
      for (const mime of supportedMIMEs) {
        const data = clipboardData.getData(mime);
        if (data) {
          textData.set(mime, data);
        }
      }
    } else if (editorSettings.clipboardApi) {
      const clipboardData2 = await editorSettings.clipboardApi.read();
      for (const [type, data] of clipboardData2.entries()) {
        if (typeof data === "string") {
          textData.set(type, data);
        } else {
          let blob = data;
          if (blob.type !== type) {
            blob = new Blob([blob], { type });
          }
          files.push(blob);
        }
      }
    } else {
      const clipboardData2 = await navigator.clipboard.read();
      for (const item of clipboardData2) {
        for (const mime of item.types) {
          if (supportedMIMEs.includes(mime)) {
            files.push(await item.getType(mime));
          }
        }
      }
    }
    const handleMIME = async (mime) => {
      var _a6;
      const isTextFormat = isTextMimeType(mime);
      if (isTextFormat) {
        const data = textData.get(mime);
        if (sendPasteEvent(mime, data)) {
          event == null ? void 0 : event.preventDefault();
          return true;
        }
      }
      for (const file of files) {
        const fileType = (_a6 = file == null ? void 0 : file.type) == null ? void 0 : _a6.toLowerCase();
        if (fileType !== mime) {
          continue;
        }
        if (isTextFormat) {
          const text = await file.text();
          if (sendPasteEvent(mime, text)) {
            event == null ? void 0 : event.preventDefault();
            return true;
          }
        } else {
          editor.showLoadingWarning(0);
          const onprogress = (evt) => {
            editor.showLoadingWarning(evt.loaded / evt.total);
          };
          try {
            const data = await fileToBase64Url_default(file, { onprogress });
            if (sendPasteEvent(mime, data)) {
              event == null ? void 0 : event.preventDefault();
              editor.hideLoadingWarning();
              return true;
            }
          } catch (e) {
            console.error("Error reading image:", e);
          }
          editor.hideLoadingWarning();
        }
      }
      return false;
    };
    for (const mime of supportedMIMEs) {
      if (await handleMIME(mime)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Copies text from the editor associated with this.
   *
   * Even if `event` is provided, the `navigator.clipboard` API may be used if image data
   * is to be copied. This is done because `ClipboardEvent`s seem to not support attaching
   * images.
   */
  copy(event) {
    const onError = (error) => {
      var _a6;
      if ((_a6 = this.callbacks) == null ? void 0 : _a6.onCopyError) {
        this.callbacks.onCopyError(error);
        return Promise.resolve();
      } else {
        throw error;
      }
    };
    try {
      return this.copyInternal(event).catch(onError);
    } catch (error) {
      return onError(error);
    }
  }
  copyInternal(event) {
    var _a6;
    const mimeToData = /* @__PURE__ */ new Map();
    if (this.editor.toolController.dispatchInputEvent({
      kind: InputEvtType.CopyEvent,
      setData: (mime, data) => {
        mimeToData.set(mime, data);
      }
    })) {
      event == null ? void 0 : event.preventDefault();
    }
    const mimeTypes = [...mimeToData.keys()];
    const hasNonTextMimeTypes = mimeTypes.some((mime) => !isTextMimeType(mime));
    const copyToEvent = (reason) => {
      var _a7, _b2;
      if (!event) {
        throw new Error(`Unable to copy -- no event provided${reason ? `. Original error: ${reason}` : ""}`);
      }
      for (const [key, value] of mimeToData.entries()) {
        if (typeof value === "string") {
          if ("clipboardData" in event) {
            (_a7 = event.clipboardData) == null ? void 0 : _a7.setData(key, value);
          } else {
            (_b2 = event.dataTransfer) == null ? void 0 : _b2.setData(key, value);
          }
        }
      }
    };
    const copyToClipboardApi = () => {
      const mapInternalDataToBrowserData = (originalMimeToData) => {
        const mappedMimeToData = /* @__PURE__ */ Object.create(null);
        for (const [key, data] of originalMimeToData.entries()) {
          if (typeof data === "string") {
            const loadedData = new Blob([new TextEncoder().encode(data)], { type: key });
            mappedMimeToData[key] = loadedData;
          } else {
            mappedMimeToData[key] = data;
          }
          if (key === "image/svg+xml") {
            mappedMimeToData["text/html"] ?? (mappedMimeToData["text/html"] = mappedMimeToData[key]);
          }
        }
        return mappedMimeToData;
      };
      const removeUnsupportedMime = (originalMimeToData) => {
        const filteredMimeToData = /* @__PURE__ */ Object.create(null);
        for (const [key, data] of Object.entries(originalMimeToData)) {
          const unsupported = "supports" in ClipboardItem && typeof ClipboardItem.supports === "function" && !ClipboardItem.supports(key);
          if (!unsupported) {
            filteredMimeToData[key] = data;
          }
        }
        return filteredMimeToData;
      };
      const browserMimeToData = removeUnsupportedMime(mapInternalDataToBrowserData(mimeToData));
      return navigator.clipboard.write([new ClipboardItem(browserMimeToData)]);
    };
    const supportsClipboardApi = typeof ClipboardItem !== "undefined" && typeof ((_a6 = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _a6.write) !== "undefined";
    const prefersClipboardApi = !__classPrivateFieldGet7(this, _ClipboardHandler_preferClipboardEvents, "f") && supportsClipboardApi && (hasNonTextMimeTypes || !event);
    const editorSettings = this.editor.getCurrentSettings();
    if (prefersClipboardApi && editorSettings.clipboardApi) {
      const writeResult = editorSettings.clipboardApi.write(mimeToData);
      return writeResult ?? Promise.resolve();
    } else if (prefersClipboardApi) {
      let clipboardApiPromise = null;
      const fallBackToCopyEvent = (reason) => {
        console.warn("Unable to copy to the clipboard API. Future calls to .copy will use ClipboardEvents if possible.", reason);
        __classPrivateFieldSet7(this, _ClipboardHandler_preferClipboardEvents, true, "f");
        copyToEvent(reason);
      };
      try {
        clipboardApiPromise = copyToClipboardApi();
      } catch (error) {
        fallBackToCopyEvent(error);
      }
      if (clipboardApiPromise) {
        return clipboardApiPromise.catch(fallBackToCopyEvent);
      }
    } else {
      copyToEvent();
    }
    return Promise.resolve();
  }
};
_ClipboardHandler_preferClipboardEvents = /* @__PURE__ */ new WeakMap();
var ClipboardHandler_default = ClipboardHandler;

// node_modules/js-draw/dist/mjs/dialogs/makeMessageDialog.mjs
var makeAboutDialog = (editor, options) => {
  const overlay = document.createElement("div");
  const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);
  overlay.classList.add("dialog-container", "message-dialog-container", ...options.classNames ?? []);
  const dialog = document.createElement("dialog");
  const contentWrapper = document.createElement("div");
  contentWrapper.classList.add("message-dialog-content", ...options.contentClassNames ?? []);
  const heading = document.createElement("h1");
  heading.textContent = options.title;
  heading.setAttribute("autofocus", "true");
  const closeButton = document.createElement("button");
  closeButton.innerText = editor.localization.closeDialog;
  closeButton.classList.add("close");
  const scrollRegion = document.createElement("div");
  scrollRegion.classList.add("scroll");
  scrollRegion.onwheel = (evt) => evt.stopPropagation();
  contentWrapper.replaceChildren(heading, scrollRegion, closeButton);
  dialog.replaceChildren(contentWrapper);
  overlay.replaceChildren(dialog);
  const closeTimeout = 300;
  dialog.style.setProperty("--close-delay", `${closeTimeout}ms`);
  const closeDialog = async () => {
    dialog.classList.add("-closing");
    await waitForTimeout_default(closeTimeout);
    dialog.close();
  };
  const addCloseListeners = () => {
    dialog.addEventListener("pointerdown", (event) => {
      if (event.target === dialog) {
        void closeDialog();
      }
    });
    dialog.onclose = () => {
      removeOverlay();
    };
    closeButton.onclick = () => closeDialog();
  };
  addCloseListeners();
  dialog.showModal();
  return {
    close: () => {
      return closeDialog();
    },
    appendChild: (child) => {
      scrollRegion.appendChild(child);
    }
  };
};
var makeMessageDialog_default = makeAboutDialog;

// node_modules/js-draw/dist/mjs/tools/SelectionTool/util/makeClipboardErrorHandlers.mjs
var makeClipboardErrorHandlers = (editor) => {
  const makeErrorDialog = (error) => {
    const dialog = makeMessageDialog_default(editor, {
      title: editor.localization.copyPasteError__heading,
      classNames: ["clipboard-error-dialog"]
    });
    dialog.appendChild(document.createTextNode(editor.localization.copyPasteError__description));
    const errorDetailsElement = document.createElement("details");
    const errorDetailsSummary = document.createElement("summary");
    errorDetailsSummary.textContent = editor.localization.copyPasteError__errorDetails;
    errorDetailsElement.appendChild(errorDetailsSummary);
    errorDetailsElement.appendChild(document.createTextNode(`Error: ${error}`));
    dialog.appendChild(errorDetailsElement);
    return dialog;
  };
  return {
    onCopyError(error) {
      const dialog = makeErrorDialog(error);
      const textboxLabel = document.createElement("label");
      textboxLabel.textContent = editor.localization.copyPasteError__copyRetry;
      const copyTextbox = document.createElement("textarea");
      textboxLabel.appendChild(copyTextbox);
      const retryHandler = new ClipboardHandler_default(editor);
      const handleCopy = (event) => {
        event.preventDefault();
        return retryHandler.copy(event).then(() => {
          dialog.close();
        });
      };
      copyTextbox.oncopy = handleCopy;
      copyTextbox.ondragstart = handleCopy;
      copyTextbox.value = editor.localization.copyPasteError__copyMe;
      dialog.appendChild(textboxLabel);
      copyTextbox.select();
      document.execCommand("copy");
    },
    onPasteError(error) {
      const dialog = makeErrorDialog(error);
      const textboxLabel = document.createElement("label");
      textboxLabel.textContent = editor.localization.copyPasteError__pasteRetry;
      const pasteTextbox = document.createElement("textarea");
      textboxLabel.appendChild(pasteTextbox);
      const retryHandler = new ClipboardHandler_default(editor);
      const handlePaste = (event) => {
        event.preventDefault();
        return retryHandler.paste(event).then((pasted) => {
          if (pasted) {
            dialog.close();
          }
        });
      };
      pasteTextbox.onpaste = handlePaste;
      pasteTextbox.ondrop = handlePaste;
      dialog.appendChild(textboxLabel);
      pasteTextbox.focus();
      document.execCommand("paste");
    }
  };
};
var makeClipboardErrorHandlers_default = makeClipboardErrorHandlers;

// node_modules/js-draw/dist/mjs/tools/SelectionTool/util/showSelectionContextMenu.mjs
var showSelectionContextMenu = async (selectionBox, editor, canvasAnchor, preferSelectionMenu, clearSelection) => {
  const localization4 = editor.localization;
  const showSelectionMenu = (selectionBox == null ? void 0 : selectionBox.getSelectedItemCount()) && preferSelectionMenu;
  const noSelectionMenu = [
    {
      text: localization4.selectionMenu__paste,
      icon: () => editor.icons.makePasteIcon(),
      key: () => {
        const clipboardHandler = new ClipboardHandler_default(editor, makeClipboardErrorHandlers_default(editor));
        void clipboardHandler.paste();
      }
    }
  ];
  const onActivated = await createMenuOverlay_default(editor, canvasAnchor, showSelectionMenu ? [
    {
      text: localization4.selectionMenu__duplicate,
      icon: () => editor.icons.makeDuplicateSelectionIcon(),
      key: async () => {
        await editor.dispatch(await selectionBox.duplicateSelectedObjects());
      }
    },
    {
      text: localization4.selectionMenu__delete,
      icon: () => editor.icons.makeDeleteSelectionIcon(),
      key: async () => {
        await editor.dispatch(selectionBox.deleteSelectedObjects());
        clearSelection();
      }
    },
    {
      text: localization4.selectionMenu__copyToClipboard,
      icon: () => editor.icons.makeCopyIcon(),
      key: () => {
        const clipboardHandler = new ClipboardHandler_default(editor, makeClipboardErrorHandlers_default(editor));
        void clipboardHandler.copy();
      }
    },
    ...noSelectionMenu
  ] : noSelectionMenu);
  onActivated == null ? void 0 : onActivated();
};
var showSelectionContextMenu_default = showSelectionContextMenu;

// node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionBuilders/SelectionBuilder.mjs
var SelectionBuilder = class {
  /** Renders a preview of the selection bounds */
  render(renderer, color) {
    renderer.drawPath(pathToRenderable(this.previewPath(), { fill: color }));
  }
  /** Converts the selection preview into a set of selected elements */
  resolve(image, viewport) {
    const path = this.previewPath();
    const filterComponents = (components2) => {
      return components2.filter((component) => {
        return component.isSelectable();
      });
    };
    let components;
    const clickSize = viewport.getSizeOfPixelOnCanvas() * 3;
    const isClick = path.bbox.maxDimension <= clickSize;
    if (isClick) {
      const searchRegionSize = viewport.visibleRect.maxDimension / 200;
      const minSizeBox = path.bbox.grownBy(searchRegionSize);
      components = image.getComponentsIntersecting(minSizeBox).filter((component) => {
        return minSizeBox.containsRect(component.getBBox()) || component.intersectsRect(minSizeBox);
      });
      components = filterComponents(components);
      if (components.length > 1) {
        components = [components[0]];
      }
    } else {
      components = filterComponents(this.resolveInternal(image));
    }
    return components;
  }
};

// node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionBuilders/LassoSelectionBuilder.mjs
var LassoSelectionBuilder = class extends SelectionBuilder {
  constructor(startPoint, viewport) {
    super();
    this.viewport = viewport;
    this.boundaryPoints = [];
    this.boundaryPoints.push(startPoint);
    this.lastPoint = startPoint;
  }
  onPointerMove(canvasPoint) {
    const lastBoundaryPoint = this.boundaryPoints[this.boundaryPoints.length - 1];
    const minBoundaryDist = this.viewport.getSizeOfPixelOnCanvas() * 8;
    if (lastBoundaryPoint.distanceTo(canvasPoint) >= minBoundaryDist) {
      this.boundaryPoints.push(canvasPoint);
    }
    this.lastPoint = canvasPoint;
  }
  previewPath() {
    const pathCommands = this.boundaryPoints.map((point) => {
      return { kind: PathCommandType.LineTo, point };
    });
    pathCommands.push({
      kind: PathCommandType.LineTo,
      point: this.lastPoint
    });
    return new Path(this.boundaryPoints[0], pathCommands).asClosed();
  }
  resolveInternal(image) {
    const path = this.previewPath();
    const lines = path.polylineApproximation();
    const candidates = image.getComponentsIntersecting(path.bbox);
    const componentIsInSelection = (component) => {
      if (path.closedContainsRect(component.getExactBBox())) {
        return true;
      }
      let hasKeyPoint = false;
      for (const point of component.keyPoints()) {
        if (path.closedContainsPoint(point)) {
          hasKeyPoint = true;
          break;
        }
      }
      if (!hasKeyPoint) {
        return false;
      }
      for (const line of lines) {
        if (component.intersects(line)) {
          return false;
        }
      }
      return true;
    };
    return candidates.filter(componentIsInSelection);
  }
};

// node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionBuilders/RectSelectionBuilder.mjs
var RectSelectionBuilder = class extends SelectionBuilder {
  constructor(startPoint) {
    super();
    this.rect = Rect2.fromCorners(startPoint, startPoint);
  }
  onPointerMove(canvasPoint) {
    this.rect = this.rect.grownToPoint(canvasPoint);
  }
  previewPath() {
    return Path.fromRect(this.rect);
  }
  resolveInternal(image) {
    return image.getComponentsIntersecting(this.rect).filter((element) => {
      return element.intersectsRect(this.rect);
    });
  }
};

// node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectionTool.mjs
var cssPrefix = "selection-tool-";
var SelectionTool = class extends BaseTool_default {
  constructor(editor, description) {
    super(editor.notifier, description);
    this.editor = editor;
    this.removeSelectionScheduled = false;
    this.startPoint = null;
    this.expandingSelectionBox = false;
    this.shiftKeyPressed = false;
    this.snapToGrid = false;
    this.lastPointer = null;
    this.showContextMenu = async (canvasAnchor, preferSelectionMenu = true) => {
      await showSelectionContextMenu_default(this.selectionBox, this.editor, canvasAnchor, preferSelectionMenu, () => this.clearSelection());
    };
    this.selectionBoxHandlingEvt = false;
    this.lastSelectedObjects = [];
    this.hasUnfinalizedTransformFromKeyPress = false;
    this.modeValue = MutableReactiveValue.fromInitialValue(SelectionMode.Rectangle);
    this.modeValue.onUpdate(() => {
      this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
        kind: EditorEventType.ToolUpdated,
        tool: this
      });
    });
    this.autoscroller = new ToPointerAutoscroller(editor.viewport, (scrollBy) => {
      editor.dispatch(Viewport_default.transformBy(Mat33.translation(scrollBy)), false);
      if (this.lastPointer) {
        const updatedPointer = this.lastPointer.withScreenPosition(this.lastPointer.screenPos, editor.viewport);
        this.onMainPointerUpdated(updatedPointer);
      }
    });
    this.handleOverlay = document.createElement("div");
    editor.createHTMLOverlay(this.handleOverlay);
    this.handleOverlay.style.display = "none";
    this.handleOverlay.classList.add("handleOverlay");
    editor.notifier.on(EditorEventType.ViewportChanged, (_data) => {
      var _a6, _b2;
      this.editor.clearWetInk();
      if (!this.expandingSelectionBox) {
        (_a6 = this.selectionBox) == null ? void 0 : _a6.padRegion();
      }
      (_b2 = this.selectionBox) == null ? void 0 : _b2.updateUI();
    });
    this.editor.handleKeyEventsFrom(this.handleOverlay);
    this.editor.handlePointerEventsFrom(this.handleOverlay);
  }
  getSelectionColor() {
    const colorString = getComputedStyle(this.handleOverlay).getPropertyValue("--selection-background-color");
    return Color4.fromString(colorString).withAlpha(0.5);
  }
  makeSelectionBox(selectedObjects) {
    var _a6;
    this.prevSelectionBox = this.selectionBox;
    this.selectionBox = new Selection_default(selectedObjects, this.editor, this.showContextMenu);
    if (!this.expandingSelectionBox) {
      (_a6 = this.prevSelectionBox) == null ? void 0 : _a6.cancelSelection();
    }
    this.selectionBox.addTo(this.handleOverlay);
  }
  onContextMenu(event) {
    var _a6, _b2;
    const canShowSelectionMenu = (_b2 = (_a6 = this.selectionBox) == null ? void 0 : _a6.getScreenRegion()) == null ? void 0 : _b2.containsPoint(event.screenPos);
    void this.showContextMenu(event.canvasPos, canShowSelectionMenu);
    return true;
  }
  onPointerDown({ allPointers, current }) {
    const snapToGrid = this.snapToGrid;
    if (snapToGrid) {
      current = current.snappedToGrid(this.editor.viewport);
    }
    if (allPointers.length === 1) {
      this.startPoint = current.canvasPos;
      let transforming = false;
      if (this.selectionBox) {
        if (snapToGrid) {
          this.selectionBox.snapSelectedObjectsToGrid();
        }
        const dragStartResult = this.selectionBox.onDragStart(current);
        if (dragStartResult) {
          transforming = true;
          this.selectionBoxHandlingEvt = true;
          this.expandingSelectionBox = false;
        }
      }
      if (!transforming) {
        this.expandingSelectionBox = this.shiftKeyPressed;
        this.removeSelectionScheduled = !this.expandingSelectionBox;
        if (this.modeValue.get() === SelectionMode.Lasso) {
          this.selectionBuilder = new LassoSelectionBuilder(current.canvasPos, this.editor.viewport);
        } else {
          this.selectionBuilder = new RectSelectionBuilder(current.canvasPos);
        }
      } else {
        this.autoscroller.start();
      }
      return true;
    }
    return false;
  }
  onPointerMove(event) {
    this.onMainPointerUpdated(event.current);
  }
  onMainPointerUpdated(currentPointer) {
    var _a6, _b2, _c2;
    this.lastPointer = currentPointer;
    if (this.removeSelectionScheduled) {
      this.removeSelectionScheduled = false;
      this.handleOverlay.replaceChildren();
      this.prevSelectionBox = this.selectionBox;
      this.selectionBox = null;
    }
    this.autoscroller.onPointerMove(currentPointer.screenPos);
    if (!this.expandingSelectionBox && this.shiftKeyPressed && this.startPoint) {
      const screenPos = this.editor.viewport.canvasToScreen(this.startPoint);
      currentPointer = currentPointer.lockedToXYAxesScreen(screenPos, this.editor.viewport);
    }
    if (this.snapToGrid) {
      currentPointer = currentPointer.snappedToGrid(this.editor.viewport);
    }
    if (this.selectionBoxHandlingEvt) {
      (_a6 = this.selectionBox) == null ? void 0 : _a6.onDragUpdate(currentPointer);
    } else {
      (_b2 = this.selectionBuilder) == null ? void 0 : _b2.onPointerMove(currentPointer.canvasPos);
      this.editor.clearWetInk();
      (_c2 = this.selectionBuilder) == null ? void 0 : _c2.render(this.editor.display.getWetInkRenderer(), this.getSelectionColor());
    }
  }
  onPointerUp(event) {
    var _a6;
    this.onMainPointerUpdated(event.current);
    this.autoscroller.stop();
    if (this.selectionBoxHandlingEvt) {
      (_a6 = this.selectionBox) == null ? void 0 : _a6.onDragEnd();
    } else if (this.selectionBuilder) {
      const newSelection = this.selectionBuilder.resolve(this.editor.image, this.editor.viewport);
      this.selectionBuilder = null;
      this.editor.clearWetInk();
      if (this.expandingSelectionBox && this.selectionBox) {
        this.setSelection([...this.selectionBox.getSelectedObjects(), ...newSelection]);
      } else {
        this.setSelection(newSelection);
      }
    }
    this.expandingSelectionBox = false;
    this.removeSelectionScheduled = false;
    this.selectionBoxHandlingEvt = false;
    this.lastPointer = null;
  }
  onGestureCancel() {
    var _a6, _b2, _c2, _d;
    if (this.selectionBuilder) {
      this.selectionBuilder = null;
      this.editor.clearWetInk();
    }
    this.autoscroller.stop();
    if (this.selectionBoxHandlingEvt) {
      (_a6 = this.selectionBox) == null ? void 0 : _a6.onDragCancel();
    } else if (!this.removeSelectionScheduled) {
      (_b2 = this.selectionBox) == null ? void 0 : _b2.cancelSelection();
      this.selectionBox = this.prevSelectionBox;
      (_c2 = this.selectionBox) == null ? void 0 : _c2.addTo(this.handleOverlay);
      (_d = this.selectionBox) == null ? void 0 : _d.recomputeRegion();
      this.prevSelectionBox = null;
    }
    this.removeSelectionScheduled = false;
    this.expandingSelectionBox = false;
    this.lastPointer = null;
    this.selectionBoxHandlingEvt = false;
  }
  onSelectionUpdated() {
    var _a6, _b2;
    const selectedItemCount = ((_a6 = this.selectionBox) == null ? void 0 : _a6.getSelectedItemCount()) ?? 0;
    const selectedObjects = ((_b2 = this.selectionBox) == null ? void 0 : _b2.getSelectedObjects()) ?? [];
    const hasDifferentSelection = this.lastSelectedObjects.length !== selectedItemCount || selectedObjects.some((obj, i) => this.lastSelectedObjects[i] !== obj);
    if (hasDifferentSelection) {
      this.lastSelectedObjects = selectedObjects;
      this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
        kind: EditorEventType.ToolUpdated,
        tool: this
      });
      this.editor.notifier.dispatch(EditorEventType.SelectionUpdated, {
        kind: EditorEventType.SelectionUpdated,
        selectedComponents: selectedObjects,
        tool: this
      });
      if (selectedItemCount > 0) {
        this.editor.announceForAccessibility(this.editor.localization.selectedElements(selectedItemCount));
        this.zoomToSelection();
      }
    }
    if (selectedItemCount === 0 && this.selectionBox) {
      this.selectionBox.cancelSelection();
      this.prevSelectionBox = this.selectionBox;
      this.selectionBox = null;
    }
  }
  zoomToSelection() {
    if (this.selectionBox) {
      const selectionRect = this.selectionBox.region;
      this.editor.dispatchNoAnnounce(this.editor.viewport.zoomTo(selectionRect, false), false);
    }
  }
  onKeyPress(event) {
    const shortcucts = this.editor.shortcuts;
    if (shortcucts.matchesShortcut(snapToGridKeyboardShortcutId, event)) {
      this.snapToGrid = true;
      return true;
    }
    if (this.selectionBox && (shortcucts.matchesShortcut(duplicateSelectionShortcut, event) || shortcucts.matchesShortcut(sendToBackSelectionShortcut, event))) {
      return true;
    } else if (shortcucts.matchesShortcut(selectAllKeyboardShortcut, event)) {
      this.setSelection(this.editor.image.getAllComponents());
      return true;
    } else if (event.ctrlKey) {
      return false;
    } else if (event.shiftKey || event.key === "Shift") {
      this.shiftKeyPressed = true;
      if (event.key === "Shift") {
        return true;
      }
    }
    let rotationSteps = 0;
    let xTranslateSteps = 0;
    let yTranslateSteps = 0;
    let xScaleSteps = 0;
    let yScaleSteps = 0;
    if (shortcucts.matchesShortcut(translateLeftSelectionShortcutId, event)) {
      xTranslateSteps -= 1;
    } else if (shortcucts.matchesShortcut(translateRightSelectionShortcutId, event)) {
      xTranslateSteps += 1;
    } else if (shortcucts.matchesShortcut(translateUpSelectionShortcutId, event)) {
      yTranslateSteps -= 1;
    } else if (shortcucts.matchesShortcut(translateDownSelectionShortcutId, event)) {
      yTranslateSteps += 1;
    } else if (shortcucts.matchesShortcut(rotateClockwiseSelectionShortcutId, event)) {
      rotationSteps += 1;
    } else if (shortcucts.matchesShortcut(rotateCounterClockwiseSelectionShortcutId, event)) {
      rotationSteps -= 1;
    } else if (shortcucts.matchesShortcut(shrinkXSelectionShortcutId, event)) {
      xScaleSteps -= 1;
    } else if (shortcucts.matchesShortcut(stretchXSelectionShortcutId, event)) {
      xScaleSteps += 1;
    } else if (shortcucts.matchesShortcut(shrinkYSelectionShortcutId, event)) {
      yScaleSteps -= 1;
    } else if (shortcucts.matchesShortcut(stretchYSelectionShortcutId, event)) {
      yScaleSteps += 1;
    } else if (shortcucts.matchesShortcut(shrinkXYSelectionShortcutId, event)) {
      xScaleSteps -= 1;
      yScaleSteps -= 1;
    } else if (shortcucts.matchesShortcut(stretchXYSelectionShortcutId, event)) {
      xScaleSteps += 1;
      yScaleSteps += 1;
    }
    let handled = xTranslateSteps !== 0 || yTranslateSteps !== 0 || rotationSteps !== 0 || xScaleSteps !== 0 || yScaleSteps !== 0;
    if (!this.selectionBox) {
      handled = false;
    } else if (handled) {
      const translateStepSize = 10 * this.editor.viewport.getSizeOfPixelOnCanvas();
      const rotateStepSize = Math.PI / 8;
      const scaleStepSize = 5 / 4;
      const region = this.selectionBox.region;
      const scaleFactor = Vec2.of(scaleStepSize ** xScaleSteps, scaleStepSize ** yScaleSteps);
      const rotationMat = Mat33.zRotation(rotationSteps * rotateStepSize);
      const roundedRotationMatrix = rotationMat.mapEntries((component) => Viewport_default.roundScaleRatio(component));
      const regionCenter = this.editor.viewport.roundPoint(region.center);
      const transform = Mat33.scaling2D(scaleFactor, this.editor.viewport.roundPoint(region.topLeft)).rightMul(Mat33.translation(regionCenter).rightMul(roundedRotationMatrix).rightMul(Mat33.translation(regionCenter.times(-1)))).rightMul(Mat33.translation(this.editor.viewport.roundPoint(Vec2.of(xTranslateSteps, yTranslateSteps).times(translateStepSize))));
      const oldTransform = this.selectionBox.getTransform();
      this.selectionBox.setTransform(oldTransform.rightMul(transform));
      this.selectionBox.scrollTo();
      this.hasUnfinalizedTransformFromKeyPress = true;
    }
    if (this.selectionBox && !handled && (event.key === "Delete" || event.key === "Backspace")) {
      this.editor.dispatch(this.selectionBox.deleteSelectedObjects());
      this.clearSelection();
      handled = true;
    }
    return handled;
  }
  onKeyUp(evt) {
    const shortcucts = this.editor.shortcuts;
    if (shortcucts.matchesShortcut(snapToGridKeyboardShortcutId, evt)) {
      this.snapToGrid = false;
      return true;
    }
    if (shortcucts.matchesShortcut(selectAllKeyboardShortcut, evt)) {
      return true;
    }
    if (this.selectionBox && shortcucts.matchesShortcut(duplicateSelectionShortcut, evt)) {
      this.selectionBox.duplicateSelectedObjects().then((command) => {
        this.editor.dispatch(command);
      });
      return true;
    }
    if (this.selectionBox && shortcucts.matchesShortcut(sendToBackSelectionShortcut, evt)) {
      const sendToBackCommand = this.selectionBox.sendToBack();
      if (sendToBackCommand) {
        this.editor.dispatch(sendToBackCommand);
      }
      return true;
    }
    if (evt.shiftKey === false) {
      this.shiftKeyPressed = false;
    }
    if (evt.key === "Shift") {
      this.shiftKeyPressed = false;
      return true;
    }
    if (!this.hasUnfinalizedTransformFromKeyPress) {
      return true;
    }
    if (this.selectionBox) {
      this.selectionBox.finalizeTransform();
      this.hasUnfinalizedTransformFromKeyPress = false;
      return true;
    }
    return false;
  }
  onCopy(event) {
    if (!this.selectionBox) {
      return false;
    }
    const selectedElems = this.selectionBox.getSelectedObjects();
    const bbox = this.selectionBox.region;
    if (selectedElems.length === 0) {
      return false;
    }
    const exportViewport = new Viewport_default(() => {
    });
    const selectionScreenSize = this.selectionBox.getScreenRegion().size.times(this.editor.display.getDevicePixelRatio());
    let scaleFactor = selectionScreenSize.maximumEntryMagnitude() / (bbox.size.maximumEntryMagnitude() || 1);
    scaleFactor = Math.pow(2, Math.ceil(Math.log2(scaleFactor)));
    exportViewport.updateScreenSize(bbox.size.times(scaleFactor));
    exportViewport.resetTransform(Mat33.scaling2D(scaleFactor).rightMul(Mat33.translation(bbox.topLeft.times(-1))));
    const { element: svgExportElem, renderer: svgRenderer } = SVGRenderer.fromViewport(exportViewport, { sanitize: true, useViewBoxForPositioning: true });
    const { element: canvas, renderer: canvasRenderer } = CanvasRenderer.fromViewport(exportViewport, { maxCanvasDimen: 4096 });
    const text = [];
    for (const elem of selectedElems) {
      elem.render(svgRenderer);
      elem.render(canvasRenderer);
      if (elem instanceof TextComponent_default) {
        text.push(elem.getText());
      }
    }
    event.setData("image/svg+xml", svgExportElem.outerHTML);
    event.setData("text/html", svgExportElem.outerHTML);
    event.setData("image/png", new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error("Failed to convert canvas to blob."));
        }
      }, "image/png");
    }));
    if (text.length > 0) {
      event.setData("text/plain", text.join("\n"));
    }
    return true;
  }
  setEnabled(enabled) {
    var _a6;
    const wasEnabled = this.isEnabled();
    super.setEnabled(enabled);
    if (wasEnabled === enabled) {
      return;
    }
    (_a6 = this.selectionBox) == null ? void 0 : _a6.cancelSelection();
    this.onSelectionUpdated();
    this.handleOverlay.replaceChildren();
    this.selectionBox = null;
    this.shiftKeyPressed = false;
    this.snapToGrid = false;
    this.handleOverlay.style.display = enabled ? "block" : "none";
    if (enabled) {
      this.handleOverlay.tabIndex = 0;
      this.handleOverlay.role = "group";
      this.handleOverlay.ariaLabel = this.editor.localization.selectionToolKeyboardShortcuts;
    } else {
      this.handleOverlay.tabIndex = -1;
    }
  }
  // Get the object responsible for displaying this' selection.
  // @internal
  getSelection() {
    return this.selectionBox;
  }
  /** @returns true if the selection is currently being created by the user. */
  isSelecting() {
    return !!this.selectionBuilder;
  }
  getSelectedObjects() {
    var _a6;
    return ((_a6 = this.selectionBox) == null ? void 0 : _a6.getSelectedObjects()) ?? [];
  }
  // Select the given `objects`. Any non-selectable objects in `objects` are ignored.
  setSelection(objects) {
    objects = objects.filter((obj) => obj.isSelectable());
    objects.sort((a, b) => a.getZIndex() - b.getZIndex());
    objects = objects.filter((current, idx) => {
      if (idx > 0) {
        return current !== objects[idx - 1];
      }
      return true;
    });
    let bbox = null;
    for (const object of objects) {
      if (bbox) {
        bbox = bbox.union(object.getBBox());
      } else {
        bbox = object.getBBox();
      }
    }
    this.clearSelectionNoUpdateEvent();
    if (bbox) {
      this.makeSelectionBox(objects);
    }
    this.onSelectionUpdated();
  }
  // Equivalent to .clearSelection, but does not dispatch an update event
  clearSelectionNoUpdateEvent() {
    this.handleOverlay.replaceChildren();
    this.prevSelectionBox = this.selectionBox;
    this.selectionBox = null;
  }
  clearSelection() {
    this.clearSelectionNoUpdateEvent();
    this.onSelectionUpdated();
  }
};

// node_modules/js-draw/dist/mjs/tools/UndoRedoShortcut.mjs
var UndoRedoShortcut = class extends BaseTool_default {
  constructor(editor) {
    super(editor.notifier, editor.localization.undoRedoTool);
    this.editor = editor;
  }
  // @internal
  onKeyPress(event) {
    if (this.editor.shortcuts.matchesShortcut(undoKeyboardShortcutId, event)) {
      void this.editor.history.undo();
      return true;
    } else if (this.editor.shortcuts.matchesShortcut(redoKeyboardShortcutId, event)) {
      void this.editor.history.redo();
      return true;
    }
    return false;
  }
};

// node_modules/js-draw/dist/mjs/tools/TextTool.mjs
var overlayCSSClass = "textEditorOverlay";
var TextTool = class extends BaseTool_default {
  constructor(editor, description, localizationTable) {
    var _a6;
    super(editor.notifier, description);
    this.editor = editor;
    this.localizationTable = localizationTable;
    this.textInputElem = null;
    this.textMeasuringCtx = null;
    this.removeExistingCommand = null;
    const editorFonts = ((_a6 = editor.getCurrentSettings().text) == null ? void 0 : _a6.fonts) ?? [];
    this.textStyleValue = ReactiveValue.fromInitialValue({
      size: 32,
      fontFamily: editorFonts.length > 0 ? editorFonts[0] : "sans-serif",
      renderingStyle: {
        fill: Color4.purple
      }
    });
    this.textStyleValue.onUpdateAndNow(() => {
      this.textStyle = this.textStyleValue.get();
      this.updateTextInput();
      this.editor.notifier.dispatch(EditorEventType.ToolUpdated, {
        kind: EditorEventType.ToolUpdated,
        tool: this
      });
    });
    this.contentTransform = ReactiveValue.fromInitialValue(Mat33.identity);
    this.textEditOverlay = document.createElement("div");
    this.textEditOverlay.classList.add(overlayCSSClass);
    this.editor.addStyleSheet(`
			.${overlayCSSClass} textarea {
				background-color: rgba(0, 0, 0, 0);

				white-space: pre;
				overflow: hidden;

				padding: 0;
				margin: 0;
				border: none;
				padding: 0;

				min-width: 100px;
				min-height: 1.1em;
			}
		`);
    this.anchorControl = this.editor.anchorElementToCanvas(this.textEditOverlay, this.contentTransform);
  }
  initTextMeasuringCanvas() {
    this.textMeasuringCtx ?? (this.textMeasuringCtx = document.createElement("canvas").getContext("2d"));
  }
  getTextAscent(text, style) {
    this.initTextMeasuringCanvas();
    if (this.textMeasuringCtx) {
      this.textMeasuringCtx.textBaseline = "alphabetic";
      TextComponent_default.applyTextStyles(this.textMeasuringCtx, style);
      const measurement = this.textMeasuringCtx.measureText(text);
      return measurement.fontBoundingBoxAscent ?? measurement.actualBoundingBoxAscent;
    }
    return style.size * 2 / 3;
  }
  // Take input from this' textInputElem and add it to the EditorImage.
  // If [removeInput], the HTML input element is removed. Otherwise, its value
  // is cleared.
  flushInput(removeInput = true) {
    if (!this.textInputElem)
      return;
    const scrollingRegion = this.textEditOverlay.parentElement;
    const containerScroll = Vec2.of((scrollingRegion == null ? void 0 : scrollingRegion.scrollLeft) ?? 0, (scrollingRegion == null ? void 0 : scrollingRegion.scrollTop) ?? 0);
    const content = this.textInputElem.value.trimEnd();
    this.textInputElem.value = "";
    if (removeInput) {
      const input = this.textInputElem;
      this.textInputElem = null;
      input.remove();
    }
    if (content !== "") {
      const scrollCorrectionScreen = containerScroll.times(-1);
      const scrollCorrectionCanvas = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollCorrectionScreen);
      const scrollTransform = Mat33.translation(scrollCorrectionCanvas);
      const textComponent = TextComponent_default.fromLines(content.split("\n"), scrollTransform.rightMul(this.contentTransform.get()), this.textStyle);
      const action = EditorImage_default.addComponent(textComponent);
      if (this.removeExistingCommand) {
        this.removeExistingCommand.unapply(this.editor);
        this.editor.dispatch(uniteCommands_default([this.removeExistingCommand, action]));
        this.removeExistingCommand = null;
      } else {
        this.editor.dispatch(action);
      }
    }
  }
  updateTextInput() {
    if (!this.textInputElem) {
      return;
    }
    this.textInputElem.placeholder = this.localizationTable.enterTextToInsert;
    this.textInputElem.style.fontFamily = this.textStyle.fontFamily;
    this.textInputElem.style.fontStyle = this.textStyle.fontStyle ?? "";
    this.textInputElem.style.fontVariant = this.textStyle.fontVariant ?? "";
    this.textInputElem.style.fontWeight = this.textStyle.fontWeight ?? "";
    this.textInputElem.style.fontSize = `${this.textStyle.size}px`;
    this.textInputElem.style.color = this.textStyle.renderingStyle.fill.toHexString();
    this.textInputElem.style.margin = "0";
    this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;
    this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;
    const tallText = "Testing!";
    const ascent = this.getTextAscent(tallText, this.textStyle);
    const vertAdjust = ascent;
    this.textInputElem.style.transform = `translate(0, ${-vertAdjust}px)`;
    this.textInputElem.style.transformOrigin = "top left";
    const lineHeight = Math.floor(this.textStyle.size);
    this.textInputElem.style.lineHeight = `${lineHeight}px`;
  }
  startTextInput(textCanvasPos, initialText) {
    this.flushInput();
    this.textInputElem = document.createElement("textarea");
    this.textInputElem.value = initialText;
    this.textInputElem.style.display = "inline-block";
    const textTargetPosition = this.editor.viewport.roundPoint(textCanvasPos);
    const textRotation = -this.editor.viewport.getRotationAngle();
    const textScale = Vec2.of(1, 1).times(this.editor.viewport.getSizeOfPixelOnCanvas());
    this.contentTransform.set(
      // Scale, then rotate, then translate:
      Mat33.translation(textTargetPosition).rightMul(Mat33.zRotation(textRotation)).rightMul(Mat33.scaling2D(textScale))
    );
    this.updateTextInput();
    setTimeout(() => this.updateTextInput(), 0);
    this.textInputElem.oninput = () => {
      if (this.textInputElem) {
        this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;
        this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;
      }
    };
    this.textInputElem.onblur = () => {
      const input = this.textInputElem;
      const removeInput = false;
      this.flushInput(removeInput);
      this.textInputElem = null;
      if (input) {
        input.classList.add("-hiding");
      }
      setTimeout(() => {
        input == null ? void 0 : input.remove();
      }, 0);
    };
    this.textInputElem.onkeyup = (evt) => {
      var _a6, _b2;
      if (evt.isComposing)
        return;
      if (evt.key === "Enter" && !evt.shiftKey) {
        this.flushInput();
        this.editor.focus();
      } else if (evt.key === "Escape") {
        (_a6 = this.textInputElem) == null ? void 0 : _a6.remove();
        this.textInputElem = null;
        this.editor.focus();
        (_b2 = this.removeExistingCommand) == null ? void 0 : _b2.unapply(this.editor);
        this.removeExistingCommand = null;
      }
    };
    this.textEditOverlay.replaceChildren(this.textInputElem);
    setTimeout(() => {
      var _a6;
      return (_a6 = this.textInputElem) == null ? void 0 : _a6.focus();
    }, 0);
  }
  setEnabled(enabled) {
    super.setEnabled(enabled);
    if (!this.isEnabled()) {
      this.flushInput();
    }
    this.textEditOverlay.style.display = enabled ? "block" : "none";
  }
  onPointerDown({ current, allPointers }) {
    if (current.device === PointerDevice.Eraser) {
      return false;
    }
    if (allPointers.length === 1) {
      const canvasPos = current.canvasPos;
      const halfTestRegionSize = Vec2.of(4, 4).times(this.editor.viewport.getSizeOfPixelOnCanvas());
      const testRegion = Rect2.fromCorners(canvasPos.minus(halfTestRegionSize), canvasPos.plus(halfTestRegionSize));
      const targetNodes = this.editor.image.getComponentsIntersecting(testRegion);
      let targetTextNodes = targetNodes.filter((node) => node instanceof TextComponent_default);
      const visibleRect = this.editor.viewport.visibleRect;
      targetTextNodes = targetTextNodes.filter((node) => !node.getBBox().containsRect(visibleRect));
      this.flushInput();
      if (targetTextNodes.length > 0) {
        const targetNode = targetTextNodes[targetTextNodes.length - 1];
        this.setTextStyle(targetNode.getTextStyle());
        this.removeExistingCommand = new Erase_default([targetNode]);
        this.removeExistingCommand.apply(this.editor);
        this.startTextInput(targetNode.getBaselinePos(), targetNode.getText());
        this.contentTransform.set(targetNode.getTransform());
        this.updateTextInput();
      } else {
        this.removeExistingCommand = null;
        this.startTextInput(current.canvasPos, "");
      }
      return true;
    }
    return false;
  }
  onGestureCancel() {
    this.flushInput();
    this.editor.focus();
  }
  setFontFamily(fontFamily) {
    if (fontFamily !== this.textStyle.fontFamily) {
      this.textStyleValue.set({
        ...this.textStyle,
        fontFamily
      });
    }
  }
  setColor(color) {
    if (!color.eq(this.textStyle.renderingStyle.fill)) {
      this.textStyleValue.set({
        ...this.textStyle,
        renderingStyle: {
          ...this.textStyle.renderingStyle,
          fill: color
        }
      });
    }
  }
  setFontSize(size) {
    if (size !== this.textStyle.size) {
      this.textStyleValue.set({
        ...this.textStyle,
        size
      });
    }
  }
  getTextStyle() {
    return this.textStyle;
  }
  getStyleValue() {
    return this.textStyleValue;
  }
  setTextStyle(style) {
    this.textStyleValue.set(style);
  }
  // @internal
  onDestroy() {
    super.onDestroy();
    this.anchorControl.remove();
  }
};

// node_modules/js-draw/dist/mjs/tools/PipetteTool.mjs
var PipetteTool = class extends BaseTool_default {
  constructor(editor, description) {
    super(editor.notifier, description);
    this.editor = editor;
    this.colorPreviewListener = null;
    this.colorSelectListener = null;
    this.enabledValue().onUpdateAndNow(() => {
      this.updateSelectingStatus();
    });
  }
  canReceiveInputInReadOnlyEditor() {
    return true;
  }
  // Ensures that the root editor element correctly reflects whether color selection
  // is in progress.
  updateSelectingStatus() {
    const className = "pipette--color-selection-in-progress";
    if (this.isEnabled() && this.colorSelectListener && this.colorPreviewListener) {
      this.editor.getRootElement().classList.add(className);
    } else {
      this.editor.getRootElement().classList.remove(className);
    }
  }
  setColorListener(colorPreviewListener, colorSelectListener) {
    this.colorPreviewListener = colorPreviewListener;
    this.colorSelectListener = colorSelectListener;
    this.updateSelectingStatus();
  }
  clearColorListener() {
    this.colorPreviewListener = null;
    this.colorSelectListener = null;
    this.updateSelectingStatus();
  }
  onPointerDown({ current, allPointers }) {
    if (this.colorPreviewListener && allPointers.length === 1) {
      this.colorPreviewListener(this.editor.display.getColorAt(current.screenPos));
      return true;
    }
    return false;
  }
  onPointerMove({ current }) {
    var _a6;
    (_a6 = this.colorPreviewListener) == null ? void 0 : _a6.call(this, this.editor.display.getColorAt(current.screenPos));
  }
  onPointerUp({ current }) {
    var _a6;
    (_a6 = this.colorSelectListener) == null ? void 0 : _a6.call(this, this.editor.display.getColorAt(current.screenPos));
  }
  onGestureCancel() {
    var _a6;
    (_a6 = this.colorSelectListener) == null ? void 0 : _a6.call(this, null);
  }
};

// node_modules/js-draw/dist/mjs/tools/ToolSwitcherShortcut.mjs
var ToolSwitcherShortcut = class extends BaseTool_default {
  constructor(editor) {
    super(editor.notifier, editor.localization.changeTool);
    this.editor = editor;
  }
  canReceiveInputInReadOnlyEditor() {
    return true;
  }
  // @internal
  onKeyPress({ key }) {
    const toolController = this.editor.toolController;
    const primaryTools = toolController.getPrimaryTools();
    const keyMatch = /^[0-9]$/.exec(key);
    let targetTool;
    if (keyMatch) {
      const targetIdx = parseInt(keyMatch[0], 10) - 1;
      targetTool = primaryTools[targetIdx];
    }
    if (targetTool) {
      targetTool.setEnabled(true);
      return true;
    }
    return false;
  }
};

// node_modules/js-draw/dist/mjs/tools/PasteHandler.mjs
var PasteHandler = class extends BaseTool_default {
  constructor(editor) {
    super(editor.notifier, editor.localization.pasteHandler);
    this.editor = editor;
  }
  // @internal
  onPaste(event, onComplete) {
    const mime = event.mime.toLowerCase();
    const svgData = (() => {
      if (mime === "image/svg+xml") {
        return event.data;
      }
      if (mime === "text/plain") {
        const trimmedData = event.data.trim();
        if (trimmedData.startsWith("<svg") && trimmedData.endsWith("</svg>")) {
          return trimmedData;
        }
      }
      if (mime !== "text/html") {
        return false;
      }
      const match = event.data.match(/^[^]{0,200}<svg.*/i);
      if (!match) {
        return false;
      }
      let svgEnd = event.data.toLowerCase().lastIndexOf("</svg>");
      if (svgEnd === -1)
        svgEnd = event.data.length;
      return event.data.substring(event.data.search(/<svg/i), svgEnd);
    })();
    if (svgData) {
      void this.doSVGPaste(svgData).then(onComplete);
      return true;
    } else if (mime === "text/plain") {
      void this.doTextPaste(event.data).then(onComplete);
      return true;
    } else if (mime === "image/png" || mime === "image/jpeg") {
      void this.doImagePaste(event.data).then(onComplete);
      return true;
    }
    return false;
  }
  async addComponentsFromPaste(components) {
    await this.editor.addAndCenterComponents(components, true, this.editor.localization.pasted(components.length));
  }
  async doSVGPaste(data) {
    var _a6;
    this.editor.showLoadingWarning(0);
    try {
      const loader = SVGLoader.fromString(data, {
        sanitize: true,
        plugins: ((_a6 = this.editor.getCurrentSettings().svg) == null ? void 0 : _a6.loaderPlugins) ?? []
      });
      const components = [];
      await loader.start((component) => {
        components.push(component);
      }, (_countProcessed, _totalToProcess) => null);
      await this.addComponentsFromPaste(components);
    } finally {
      this.editor.hideLoadingWarning();
    }
  }
  async doTextPaste(text) {
    var _a6;
    const textTools = this.editor.toolController.getMatchingTools(TextTool);
    textTools.sort((a, b) => {
      if (!a.isEnabled() && b.isEnabled()) {
        return -1;
      }
      if (!b.isEnabled() && a.isEnabled()) {
        return 1;
      }
      return 0;
    });
    const defaultTextStyle3 = {
      size: 12,
      fontFamily: "sans",
      renderingStyle: { fill: Color4.red }
    };
    const pastedTextStyle = ((_a6 = textTools[0]) == null ? void 0 : _a6.getTextStyle()) ?? defaultTextStyle3;
    if (text.trim() === "") {
      return;
    }
    const lines = text.split("\n");
    await this.addComponentsFromPaste([
      TextComponent_default.fromLines(lines, Mat33.identity, pastedTextStyle)
    ]);
  }
  async doImagePaste(dataURL) {
    const image = new Image();
    image.src = dataURL;
    const component = await ImageComponent.fromImage(image, Mat33.identity);
    await this.addComponentsFromPaste([component]);
  }
};

// node_modules/js-draw/dist/mjs/tools/ToolbarShortcutHandler.mjs
var ToolbarShortcutHandler = class extends BaseTool_default {
  constructor(editor) {
    super(editor.notifier, editor.localization.changeTool);
    this.listeners = /* @__PURE__ */ new Set([]);
  }
  registerListener(listener) {
    this.listeners.add(listener);
  }
  removeListener(listener) {
    this.listeners.delete(listener);
  }
  onKeyPress(event) {
    const listeners = Array.from(this.listeners.values());
    for (const listener of listeners) {
      if (listener(event)) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/js-draw/dist/mjs/components/builders/PressureSensitiveFreehandLineBuilder.mjs
var makePressureSensitiveFreehandLineBuilder = makeShapeFitAutocorrect_default((initialPoint, viewport) => {
  const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;
  const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();
  return new PressureSensitiveFreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);
});
var PressureSensitiveFreehandLineBuilder = class {
  constructor(startPoint, minFitAllowed, maxFitAllowed, viewport) {
    this.startPoint = startPoint;
    this.minFitAllowed = minFitAllowed;
    this.viewport = viewport;
    this.isFirstSegment = true;
    this.pathStartConnector = null;
    this.mostRecentConnector = null;
    this.nextCurveStartConnector = null;
    this.lastUpperBezier = null;
    this.lastLowerBezier = null;
    this.parts = [];
    this.upperSegments = [];
    this.lowerSegments = [];
    this.curveFitter = new StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));
    this.curveStartWidth = startPoint.width;
    this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
  }
  getBBox() {
    return this.bbox;
  }
  getRenderingStyle() {
    return {
      fill: this.startPoint.color ?? null
    };
  }
  previewCurrentPath(extendWithLatest = true) {
    const upperPath = this.upperSegments.slice();
    const lowerPath = this.lowerSegments.slice();
    let lowerToUpperCap;
    let pathStartConnector;
    const currentCurve = this.curveFitter.preview();
    if (currentCurve && extendWithLatest) {
      const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand } = this.segmentToPath(currentCurve);
      upperPath.push(upperCurveCommand);
      lowerPath.push(lowerCurveCommand);
      lowerToUpperCap = lowerToUpperConnector;
      pathStartConnector = this.pathStartConnector ?? [upperToLowerConnector];
    } else {
      if (this.mostRecentConnector === null || this.pathStartConnector === null) {
        return null;
      }
      lowerToUpperCap = this.mostRecentConnector;
      pathStartConnector = this.pathStartConnector;
    }
    let startPoint;
    const lastLowerSegment = lowerPath[lowerPath.length - 1];
    if (lastLowerSegment.kind === PathCommandType.LineTo || lastLowerSegment.kind === PathCommandType.MoveTo) {
      startPoint = lastLowerSegment.point;
    } else {
      startPoint = lastLowerSegment.endPoint;
    }
    return {
      // Start at the end of the lower curve:
      //    Start point
      //     ↓
      //  __/  __/ ← Most recent points on this end
      // /___ /
      //  ↑
      //  Oldest points
      startPoint,
      commands: [
        // Move to the most recent point on the upperPath:
        //     ----→•
        //  __/  __/
        // /___ /
        lowerToUpperCap,
        // Move to the beginning of the upperPath:
        //  __/  __/
        // /___ /
        //     • ←-
        ...upperPath.reverse(),
        // Move to the beginning of the lowerPath:
        //  __/  __/
        // /___ /
        // •
        ...pathStartConnector,
        // Move back to the start point:
        //     •
        //  __/  __/
        // /___ /
        ...lowerPath
      ],
      style: this.getRenderingStyle()
    };
  }
  previewFullPath() {
    const preview = this.previewCurrentPath();
    if (preview) {
      return [...this.parts, preview];
    }
    return null;
  }
  preview(renderer) {
    const paths = this.previewFullPath();
    if (paths) {
      const approxBBox = this.viewport.visibleRect;
      renderer.startObject(approxBBox);
      for (const path of paths) {
        renderer.drawPath(path);
      }
      renderer.endObject();
    }
  }
  build() {
    this.curveFitter.finalizeCurrentCurve();
    if (this.isFirstSegment) {
      this.addCurve(null);
    }
    return new Stroke(this.previewFullPath());
  }
  roundPoint(point) {
    let minFit = Math.min(this.minFitAllowed, this.curveStartWidth / 3);
    if (minFit < 1e-10) {
      minFit = this.minFitAllowed;
    }
    return Viewport_default.roundPoint(point, minFit);
  }
  // Returns true if, due to overlap with previous segments, a new RenderablePathSpec should be created.
  shouldStartNewSegment(lowerCurve, upperCurve) {
    if (!this.lastLowerBezier || !this.lastUpperBezier) {
      return false;
    }
    const getIntersection = (curve1, curve2) => {
      const intersections = curve1.intersectsBezier(curve2);
      if (!intersections.length)
        return null;
      return intersections[0].point;
    };
    const getExitDirection = (curve) => {
      return curve.p2.minus(curve.p1).normalized();
    };
    const getEnterDirection = (curve) => {
      return curve.p1.minus(curve.p0).normalized();
    };
    if (getEnterDirection(upperCurve).dot(getExitDirection(this.lastUpperBezier)) < 0.35 || getEnterDirection(lowerCurve).dot(getExitDirection(this.lastLowerBezier)) < 0.35 || // Also handle if the curves exit/enter directions differ
    getEnterDirection(upperCurve).dot(getExitDirection(upperCurve)) < 0 || getEnterDirection(lowerCurve).dot(getExitDirection(lowerCurve)) < 0) {
      return true;
    }
    const lowerIntersection = getIntersection(lowerCurve, this.lastUpperBezier);
    const upperIntersection = getIntersection(upperCurve, this.lastLowerBezier);
    if (lowerIntersection || upperIntersection) {
      return true;
    }
    return false;
  }
  addCurve(curve) {
    if (!curve) {
      if (!this.isFirstSegment) {
        return;
      }
      const width = Viewport_default.roundPoint(this.startPoint.width / 2.2, Math.min(this.minFitAllowed, this.startPoint.width / 4));
      const center = this.roundPoint(this.startPoint.pos);
      const startPoint = this.startPoint.pos.plus(Vec2.of(width, 0));
      this.lowerSegments.push({
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint: center.plus(Vec2.of(width, width)),
        // Bottom of the circle
        //    |
        //  -----
        //    |
        //    ↑
        endPoint: center.plus(Vec2.of(0, width))
      }, {
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint: center.plus(Vec2.of(-width, width)),
        endPoint: center.plus(Vec2.of(-width, 0))
      }, {
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint: center.plus(Vec2.of(-width, -width)),
        endPoint: center.plus(Vec2.of(0, -width))
      }, {
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint: center.plus(Vec2.of(width, -width)),
        endPoint: center.plus(Vec2.of(width, 0))
      });
      const connector = {
        kind: PathCommandType.LineTo,
        point: startPoint
      };
      this.pathStartConnector = [connector];
      this.mostRecentConnector = connector;
      return;
    }
    const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand, lowerCurve, upperCurve, nextCurveStartConnector } = this.segmentToPath(curve);
    let shouldStartNew = this.shouldStartNewSegment(lowerCurve, upperCurve);
    if (shouldStartNew) {
      const part = this.previewCurrentPath(false);
      if (part) {
        this.parts.push(part);
        this.upperSegments = [];
        this.lowerSegments = [];
      } else {
        shouldStartNew = false;
      }
    }
    if (this.isFirstSegment || shouldStartNew) {
      this.pathStartConnector = this.nextCurveStartConnector ?? [upperToLowerConnector];
      this.isFirstSegment = false;
    }
    this.mostRecentConnector = lowerToUpperConnector;
    this.nextCurveStartConnector = nextCurveStartConnector;
    this.lowerSegments.push(lowerCurveCommand);
    this.upperSegments.push(upperCurveCommand);
    this.lastLowerBezier = lowerCurve;
    this.lastUpperBezier = upperCurve;
    this.curveStartWidth = curve.startWidth;
  }
  // Returns [upper curve, connector, lower curve]
  segmentToPath(curve) {
    const bezier = new QuadraticBezier(curve.startPoint, curve.controlPoint, curve.endPoint);
    let startVec = bezier.normal(0);
    let endVec = bezier.normal(1);
    startVec = startVec.times(curve.startWidth / 2);
    endVec = endVec.times(curve.endWidth / 2);
    if (!isFinite(startVec.magnitude())) {
      console.error("Warning: startVec is NaN or ∞", startVec, endVec, curve);
      startVec = endVec;
    }
    const startPt = curve.startPoint;
    const endPt = curve.endPoint;
    const controlPoint = curve.controlPoint;
    const projectionT = bezier.nearestPointTo(controlPoint).parameterValue;
    const halfVecT = projectionT;
    const halfVec = bezier.normal(halfVecT).times(curve.startWidth / 2 * halfVecT + curve.endWidth / 2 * (1 - halfVecT));
    const lowerCurveStartPoint = this.roundPoint(startPt.plus(startVec));
    const lowerCurveControlPoint = this.roundPoint(controlPoint.plus(halfVec));
    const lowerCurveEndPoint = this.roundPoint(endPt.plus(endVec));
    const upperCurveControlPoint = this.roundPoint(controlPoint.minus(halfVec));
    const upperCurveStartPoint = this.roundPoint(endPt.minus(endVec));
    const upperCurveEndPoint = this.roundPoint(startPt.minus(startVec));
    const lowerCurveCommand = {
      kind: PathCommandType.QuadraticBezierTo,
      controlPoint: lowerCurveControlPoint,
      endPoint: lowerCurveEndPoint
    };
    const upperToLowerConnector = {
      kind: PathCommandType.LineTo,
      point: lowerCurveStartPoint
    };
    const lowerToUpperConnector = {
      kind: PathCommandType.LineTo,
      point: upperCurveStartPoint
    };
    const nextCurveStartConnector = [
      {
        kind: PathCommandType.LineTo,
        point: upperCurveStartPoint
      },
      {
        kind: PathCommandType.LineTo,
        point: lowerCurveEndPoint
      }
    ];
    const upperCurveCommand = {
      kind: PathCommandType.QuadraticBezierTo,
      controlPoint: upperCurveControlPoint,
      endPoint: upperCurveEndPoint
    };
    const upperCurve = new QuadraticBezier(upperCurveStartPoint, upperCurveControlPoint, upperCurveEndPoint);
    const lowerCurve = new QuadraticBezier(lowerCurveStartPoint, lowerCurveControlPoint, lowerCurveEndPoint);
    return {
      upperCurveCommand,
      upperToLowerConnector,
      lowerToUpperConnector,
      lowerCurveCommand,
      upperCurve,
      lowerCurve,
      nextCurveStartConnector
    };
  }
  addPoint(newPoint) {
    this.curveFitter.addPoint(newPoint);
  }
};

// node_modules/js-draw/dist/mjs/tools/FindTool.mjs
var cssPrefix2 = "find-tool";
var FindTool = class extends BaseTool_default {
  constructor(editor) {
    super(editor.notifier, editor.localization.findLabel);
    this.editor = editor;
    this.currentMatchIdx = 0;
    this.overlay = document.createElement("div");
    this.fillOverlay();
    editor.createHTMLOverlay(this.overlay);
    this.overlay.style.display = "none";
    this.overlay.classList.add(`${cssPrefix2}-overlay`);
  }
  canReceiveInputInReadOnlyEditor() {
    return true;
  }
  getMatches(searchFor) {
    const lowerSearchFor = searchFor.toLocaleLowerCase();
    const matchingComponents = this.editor.image.getAllComponents().filter((component) => {
      let text = "";
      if (component instanceof TextComponent_default) {
        text = component.getText();
      } else if (component instanceof ImageComponent) {
        text = component.getAltText() ?? "";
      } else {
        return false;
      }
      const hasLowercaseMatch = text.toLocaleLowerCase().indexOf(lowerSearchFor) !== -1;
      const hasSameCaseMatch = text.indexOf(searchFor) !== -1;
      return hasLowercaseMatch || hasSameCaseMatch;
    });
    return matchingComponents.map((match) => match.getBBox());
  }
  focusCurrentMatch() {
    const matches = this.getMatches(this.searchInput.value);
    let matchIdx = this.currentMatchIdx % matches.length;
    if (matchIdx < 0) {
      matchIdx = matches.length + matchIdx;
    }
    if (matchIdx < matches.length) {
      const undoable = false;
      void this.editor.dispatch(this.editor.viewport.zoomTo(matches[matchIdx], true, true), undoable);
      this.editor.announceForAccessibility(this.editor.localization.focusedFoundText(matchIdx + 1, matches.length));
    }
  }
  toNextMatch() {
    this.currentMatchIdx++;
    this.focusCurrentMatch();
  }
  toPrevMatch() {
    this.currentMatchIdx--;
    this.focusCurrentMatch();
  }
  fillOverlay() {
    const label = document.createElement("label");
    this.searchInput = document.createElement("input");
    const nextBtn = document.createElement("button");
    const closeBtn = document.createElement("button");
    this.searchInput.setAttribute("id", `${cssPrefix2}-searchInput-${Math.random()}`);
    label.htmlFor = this.searchInput.getAttribute("id");
    label.innerText = this.editor.localization.findLabel;
    nextBtn.innerText = this.editor.localization.toNextMatch;
    closeBtn.innerText = this.editor.localization.closeDialog;
    this.searchInput.onkeydown = (ev) => {
      if (ev.key === "Enter") {
        if (ev.shiftKey) {
          this.toPrevMatch();
        } else {
          this.toNextMatch();
        }
      } else if (ev.key === "Escape") {
        this.setVisible(false);
      } else if (this.editor.shortcuts.matchesShortcut(toggleFindVisibleShortcutId, ev)) {
        ev.preventDefault();
        this.toggleVisible();
      }
    };
    nextBtn.onclick = () => {
      this.toNextMatch();
    };
    closeBtn.onclick = () => {
      this.setVisible(false);
    };
    this.overlay.replaceChildren(label, this.searchInput, nextBtn, closeBtn);
  }
  isVisible() {
    return this.overlay.style.display !== "none";
  }
  setVisible(visible) {
    if (visible !== this.isVisible()) {
      this.overlay.style.display = visible ? "block" : "none";
      if (visible) {
        this.searchInput.focus();
        this.editor.announceForAccessibility(this.editor.localization.findDialogShown);
      } else {
        this.editor.focus();
        this.editor.announceForAccessibility(this.editor.localization.findDialogHidden);
      }
    }
  }
  toggleVisible() {
    this.setVisible(!this.isVisible());
  }
  onKeyPress(event) {
    if (this.editor.shortcuts.matchesShortcut(toggleFindVisibleShortcutId, event)) {
      this.toggleVisible();
      return true;
    }
    return false;
  }
  setEnabled(enabled) {
    super.setEnabled(enabled);
    if (this.isEnabled()) {
      this.setVisible(false);
    }
  }
};

// node_modules/js-draw/dist/mjs/tools/SelectionTool/SelectAllShortcutHandler.mjs
var SelectAllShortcutHandler = class extends BaseTool_default {
  constructor(editor) {
    super(editor.notifier, editor.localization.selectAllTool);
    this.editor = editor;
  }
  canReceiveInputInReadOnlyEditor() {
    return true;
  }
  // @internal
  onKeyPress(event) {
    if (this.editor.shortcuts.matchesShortcut(selectAllKeyboardShortcut, event)) {
      const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool);
      if (selectionTools.length > 0) {
        const selectionTool = selectionTools[0];
        selectionTool.setEnabled(true);
        selectionTool.setSelection(this.editor.image.getAllComponents());
        return true;
      }
    }
    return false;
  }
};

// node_modules/js-draw/dist/mjs/tools/SoundUITool.mjs
var SoundFeedback = class {
  constructor() {
    this.closed = false;
    if (!window.AudioContext) {
      console.warn("Accessibility sound UI: Unable to open AudioContext.");
      this.closed = true;
      return;
    }
    this.ctx = new AudioContext();
    this.colorOscHue = this.ctx.createOscillator();
    this.colorOscValue = this.ctx.createOscillator();
    this.colorOscSaturation = this.ctx.createOscillator();
    this.colorOscHue.type = "triangle";
    this.colorOscSaturation.type = "sine";
    this.colorOscValue.type = "sawtooth";
    this.valueGain = this.ctx.createGain();
    this.colorOscValue.connect(this.valueGain);
    this.valueGain.gain.setValueAtTime(0.18, this.ctx.currentTime);
    this.colorGain = this.ctx.createGain();
    this.colorOscHue.connect(this.colorGain);
    this.valueGain.connect(this.colorGain);
    this.colorOscSaturation.connect(this.colorGain);
    this.colorGain.connect(this.ctx.destination);
    this.boundaryGain = this.ctx.createGain();
    this.boundaryOsc = this.ctx.createOscillator();
    this.boundaryOsc.type = "sawtooth";
    this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);
    this.boundaryOsc.connect(this.boundaryGain);
    this.boundaryGain.connect(this.ctx.destination);
    this.colorOscHue.start();
    this.colorOscSaturation.start();
    this.colorOscValue.start();
    this.boundaryOsc.start();
    this.pause();
  }
  pause() {
    if (this.closed)
      return;
    this.colorGain.gain.setValueAtTime(0, this.ctx.currentTime);
    void this.ctx.suspend();
  }
  play() {
    if (this.closed)
      return;
    void this.ctx.resume();
  }
  setColor(color) {
    const hsv = color.asHSV();
    const hueFrequency = -Math.cos(hsv.x / 2) * 220 + 440;
    const saturationFrequency = hsv.y * 440 + 220;
    const valueFrequency = (hsv.z + 0.1) * 440;
    const gain = 0.25 * Math.min(1, color.a) / (1 + Math.exp(-(hsv.z - 0.5) * 3));
    this.colorOscHue.frequency.setValueAtTime(hueFrequency, this.ctx.currentTime);
    this.colorOscSaturation.frequency.setValueAtTime(saturationFrequency, this.ctx.currentTime);
    this.colorOscValue.frequency.setValueAtTime(valueFrequency, this.ctx.currentTime);
    this.valueGain.gain.setValueAtTime((1 - hsv.z) * 0.4, this.ctx.currentTime);
    this.colorGain.gain.setValueAtTime(gain, this.ctx.currentTime);
  }
  announceBoundaryCross(boundaryCrossCount) {
    this.boundaryGain.gain.cancelScheduledValues(this.ctx.currentTime);
    this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);
    this.boundaryGain.gain.linearRampToValueAtTime(0.018, this.ctx.currentTime + 0.1);
    this.boundaryOsc.frequency.setValueAtTime(440 + Math.atan(boundaryCrossCount / 2) * 100, this.ctx.currentTime);
    this.boundaryGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.25);
  }
  close() {
    void this.ctx.close();
    this.closed = true;
  }
};
var SoundUITool = class extends BaseTool_default {
  constructor(editor, description) {
    super(editor.notifier, description);
    this.editor = editor;
    this.soundFeedback = null;
    this.toggleButtonContainer = document.createElement("div");
    this.toggleButtonContainer.classList.add("js-draw-sound-ui-toggle");
    this.toggleButton = document.createElement("button");
    this.toggleButton.onclick = () => {
      this.setEnabled(!this.isEnabled());
    };
    this.toggleButtonContainer.appendChild(this.toggleButton);
    this.updateToggleButtonText();
    editor.createHTMLOverlay(this.toggleButtonContainer);
  }
  canReceiveInputInReadOnlyEditor() {
    return true;
  }
  updateToggleButtonText() {
    const containerEnabledClass = "sound-ui-tool-enabled";
    if (this.isEnabled()) {
      this.toggleButton.innerText = this.editor.localization.disableAccessibilityExploreTool;
      this.toggleButtonContainer.classList.add(containerEnabledClass);
    } else {
      this.toggleButton.innerText = this.editor.localization.enableAccessibilityExploreTool;
      this.toggleButtonContainer.classList.remove(containerEnabledClass);
    }
  }
  setEnabled(enabled) {
    var _a6;
    super.setEnabled(enabled);
    if (!this.isEnabled()) {
      (_a6 = this.soundFeedback) == null ? void 0 : _a6.close();
      this.soundFeedback = null;
    } else {
      this.editor.announceForAccessibility(this.editor.localization.soundExplorerUsageAnnouncement);
    }
    this.updateToggleButtonText();
  }
  onKeyPress(event) {
    if (event.code === "Escape") {
      this.setEnabled(false);
      return true;
    }
    return false;
  }
  onPointerDown({ current, allPointers }) {
    var _a6, _b2;
    if (!this.soundFeedback) {
      this.soundFeedback = new SoundFeedback();
    }
    if (allPointers.length >= 2) {
      return false;
    }
    (_a6 = this.soundFeedback) == null ? void 0 : _a6.play();
    (_b2 = this.soundFeedback) == null ? void 0 : _b2.setColor(this.editor.display.getColorAt(current.screenPos) ?? Color4.black);
    this.lastPointerPos = current.canvasPos;
    return true;
  }
  onPointerMove({ current }) {
    var _a6, _b2;
    (_a6 = this.soundFeedback) == null ? void 0 : _a6.setColor(this.editor.display.getColorAt(current.screenPos) ?? Color4.black);
    const pointerMotionLine = new LineSegment2(this.lastPointerPos, current.canvasPos);
    const collisions = this.editor.image.getComponentsIntersecting(pointerMotionLine.bbox).filter((component) => component.intersects(pointerMotionLine));
    this.lastPointerPos = current.canvasPos;
    if (collisions.length > 0) {
      (_b2 = this.soundFeedback) == null ? void 0 : _b2.announceBoundaryCross(collisions.length);
    }
  }
  onPointerUp(_event) {
    var _a6;
    (_a6 = this.soundFeedback) == null ? void 0 : _a6.pause();
  }
  onGestureCancel() {
    var _a6;
    (_a6 = this.soundFeedback) == null ? void 0 : _a6.pause();
  }
};

// node_modules/js-draw/dist/mjs/tools/InputFilter/InputPipeline.mjs
var __classPrivateFieldGet8 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet8 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _InputPipeline_head;
var _InputPipeline_tail;
var InputPipeline = class extends InputMapper_default {
  constructor() {
    super(...arguments);
    _InputPipeline_head.set(this, null);
    _InputPipeline_tail.set(this, null);
  }
  onEvent(event) {
    if (__classPrivateFieldGet8(this, _InputPipeline_head, "f") === null) {
      return this.emit(event);
    } else {
      return __classPrivateFieldGet8(this, _InputPipeline_head, "f").onEvent(event);
    }
  }
  /**
   * Adds a new `InputMapper` to the *tail* of this pipeline.
   * Note that an instance of an `InputMapper` can only be used in a single
   * pipeline.
   */
  addToTail(mapper) {
    if (!__classPrivateFieldGet8(this, _InputPipeline_tail, "f")) {
      __classPrivateFieldSet8(this, _InputPipeline_head, mapper, "f");
      __classPrivateFieldSet8(this, _InputPipeline_tail, __classPrivateFieldGet8(this, _InputPipeline_head, "f"), "f");
    } else {
      __classPrivateFieldGet8(this, _InputPipeline_tail, "f").setEmitListener(mapper);
      __classPrivateFieldSet8(this, _InputPipeline_tail, mapper, "f");
    }
    __classPrivateFieldGet8(this, _InputPipeline_tail, "f").setEmitListener((event) => this.emit(event));
  }
};
_InputPipeline_head = /* @__PURE__ */ new WeakMap(), _InputPipeline_tail = /* @__PURE__ */ new WeakMap();
var InputPipeline_default = InputPipeline;

// node_modules/js-draw/dist/mjs/tools/ScrollbarTool.mjs
var ScrollbarTool = class extends BaseTool_default {
  constructor(editor) {
    super(editor.notifier, "scrollbar");
    this.editor = editor;
    this.fadeOutTimeout = null;
    this.scrollbarOverlay = document.createElement("div");
    this.scrollbarOverlay.classList.add("ScrollbarTool-overlay");
    this.verticalScrollbar = document.createElement("div");
    this.verticalScrollbar.classList.add("vertical-scrollbar");
    this.horizontalScrollbar = document.createElement("div");
    this.horizontalScrollbar.classList.add("horizontal-scrollbar");
    this.scrollbarOverlay.replaceChildren(this.verticalScrollbar, this.horizontalScrollbar);
    let overlay = null;
    let viewportListener = null;
    this.enabledValue().onUpdateAndNow((enabled) => {
      overlay == null ? void 0 : overlay.remove();
      viewportListener == null ? void 0 : viewportListener.remove();
      viewportListener = null;
      overlay = null;
      if (enabled) {
        viewportListener = editor.notifier.on(EditorEventType.ViewportChanged, (_event) => {
          this.updateScrollbars();
        });
        this.updateScrollbars();
        overlay = editor.createHTMLOverlay(this.scrollbarOverlay);
      }
    });
  }
  updateScrollbars() {
    const viewport = this.editor.viewport;
    const screenSize = viewport.getScreenRectSize();
    const screenRect = new Rect2(0, 0, screenSize.x, screenSize.y);
    const imageRect = this.editor.getImportExportRect().transformedBoundingBox(viewport.canvasToScreenTransform).union(screenRect);
    const scrollbarWidth = screenRect.width / imageRect.width * screenSize.x;
    const scrollbarHeight = screenRect.height / imageRect.height * screenSize.y;
    const scrollbarX = (screenRect.x - imageRect.x) / imageRect.width * screenSize.x;
    const scrollbarY = (screenRect.y - imageRect.y) / imageRect.height * screenSize.y;
    this.horizontalScrollbar.style.width = `${scrollbarWidth}px`;
    this.verticalScrollbar.style.height = `${scrollbarHeight}px`;
    this.horizontalScrollbar.style.marginLeft = `${scrollbarX}px`;
    this.verticalScrollbar.style.marginTop = `${scrollbarY}px`;
    const handleNoScrollStyling = (scrollbar, size, fillSize) => {
      const fillsWindowClass = "represents-no-scroll";
      if (Math.abs(size - fillSize) < 1e-8) {
        scrollbar.classList.add(fillsWindowClass);
      } else {
        scrollbar.classList.remove(fillsWindowClass);
      }
    };
    handleNoScrollStyling(this.horizontalScrollbar, scrollbarWidth, screenSize.x);
    handleNoScrollStyling(this.verticalScrollbar, scrollbarHeight, screenSize.y);
    if (this.fadeOutTimeout !== null) {
      clearTimeout(this.fadeOutTimeout);
    }
    const fadeOutDelay = 3e3;
    this.fadeOutTimeout = setTimeout(() => {
      this.scrollbarOverlay.classList.remove("just-updated");
    }, fadeOutDelay);
    this.scrollbarOverlay.classList.add("just-updated");
  }
};

// node_modules/js-draw/dist/mjs/tools/ToolController.mjs
var ToolController = class {
  /** @internal */
  constructor(editor, localization4) {
    this.activeTool = null;
    this.isEditorReadOnly = editor.isReadOnlyReactiveValue();
    this.inputPipeline = new InputPipeline_default();
    this.inputPipeline.setEmitListener((event) => this.onEventInternal(event));
    const primaryToolGroup = new ToolEnabledGroup();
    this.primaryToolGroup = primaryToolGroup;
    const panZoomTool = new PanZoom(editor, PanZoomMode.TwoFingerTouchGestures | PanZoomMode.RightClickDrags, localization4.touchPanTool);
    const keyboardPanZoomTool = new PanZoom(editor, PanZoomMode.Keyboard, localization4.keyboardPanZoom);
    const primaryPenTool = new Pen(editor, localization4.penTool(1), {
      color: Color4.purple,
      thickness: 8
    });
    const secondaryPenTool = new Pen(editor, localization4.penTool(2), {
      color: Color4.clay,
      thickness: 4
    });
    secondaryPenTool.setInputMapper(new InputStabilizer(editor.viewport));
    const eraser = new Eraser(editor, localization4.eraserTool);
    const primaryTools = [
      // Three pens
      primaryPenTool,
      secondaryPenTool,
      // Highlighter-like pen with width=40
      new Pen(editor, localization4.penTool(3), {
        color: Color4.ofRGBA(1, 1, 0, 0.5),
        thickness: 40,
        factory: makePressureSensitiveFreehandLineBuilder
      }),
      eraser,
      new SelectionTool(editor, localization4.selectionTool),
      new TextTool(editor, localization4.textTool, localization4),
      new PanZoom(editor, PanZoomMode.SinglePointerGestures, localization4.anyDevicePanning)
    ];
    const soundExplorer = new SoundUITool(editor, localization4.soundExplorer);
    soundExplorer.setEnabled(false);
    this.tools = [
      new ScrollbarTool(editor),
      new PipetteTool(editor, localization4.pipetteTool),
      soundExplorer,
      panZoomTool,
      ...primaryTools,
      keyboardPanZoomTool,
      new UndoRedoShortcut(editor),
      new ToolbarShortcutHandler(editor),
      new ToolSwitcherShortcut(editor),
      eraser.makeEraserSwitcherTool(),
      new FindTool(editor),
      new PasteHandler(editor),
      new SelectAllShortcutHandler(editor)
    ];
    primaryTools.forEach((tool) => tool.setToolGroup(primaryToolGroup));
    panZoomTool.setEnabled(true);
    primaryPenTool.setEnabled(true);
    editor.notifier.on(EditorEventType.ToolEnabled, (event) => {
      if (event.kind === EditorEventType.ToolEnabled) {
        editor.announceForAccessibility(localization4.toolEnabledAnnouncement(event.tool.description));
      }
    });
    editor.notifier.on(EditorEventType.ToolDisabled, (event) => {
      if (event.kind === EditorEventType.ToolDisabled) {
        editor.announceForAccessibility(localization4.toolDisabledAnnouncement(event.tool.description));
      }
    });
    this.activeTool = null;
  }
  /**
   * Replaces the current set of tools with `tools`. This should only be done before
   * the creation of the app's toolbar (if using `AbstractToolbar`).
   *
   * If no `primaryToolGroup` is given, an empty one will be created.
   */
  setTools(tools, primaryToolGroup) {
    this.tools = tools;
    this.primaryToolGroup = primaryToolGroup ?? new ToolEnabledGroup();
  }
  /**
   * Add a tool that acts like one of the primary tools (only one primary tool can be enabled at a time).
   *
   * If the tool is already added to this, the tool is converted to a primary tool.
   *
   * This should be called before creating the app's toolbar.
   */
  addPrimaryTool(tool) {
    tool.setToolGroup(this.primaryToolGroup);
    if (tool.isEnabled()) {
      this.primaryToolGroup.notifyEnabled(tool);
    }
    if (!this.tools.includes(tool)) {
      this.addTool(tool);
    }
  }
  getPrimaryTools() {
    return this.tools.filter((tool) => {
      return tool.getToolGroup() === this.primaryToolGroup;
    });
  }
  /**
   * Add a tool to the end of this' tool list (the added tool receives events after tools already added to this).
   * This should be called before creating the app's toolbar.
   *
   * If `options.addToFront`, the tool is added to the beginning of this' tool list.
   *
   * Does nothing if the tool is already present.
   */
  addTool(tool, options) {
    if (!this.tools.includes(tool)) {
      if (options == null ? void 0 : options.addToFront) {
        this.tools.splice(0, 0, tool);
      } else {
        this.tools.push(tool);
      }
    }
  }
  /**
   * Removes **and destroys** all tools in `tools` from this.
   */
  removeAndDestroyTools(tools) {
    const newTools = [];
    for (const tool of this.tools) {
      if (tools.includes(tool)) {
        if (this.activeTool === tool) {
          this.activeTool = null;
        }
        tool.onDestroy();
      } else {
        newTools.push(tool);
      }
    }
    this.tools = newTools;
  }
  insertTools(insertNear, toolsToInsert, mode) {
    this.tools = this.tools.filter((tool) => !toolsToInsert.includes(tool));
    const newTools = [];
    for (const tool of this.tools) {
      if (mode === "after") {
        newTools.push(tool);
      }
      if (tool === insertNear) {
        newTools.push(...toolsToInsert);
      }
      if (mode === "before") {
        newTools.push(tool);
      }
    }
    this.tools = newTools;
  }
  /**
   * Removes a tool from this' tool list and replaces it with `replaceWith`.
   *
   * If any of `toolsToInsert` have already been added to this, the tools are
   * moved.
   *
   * This should be called before creating the editor's toolbar.
   */
  insertToolsAfter(insertAfter, toolsToInsert) {
    this.insertTools(insertAfter, toolsToInsert, "after");
  }
  /** @see {@link insertToolsAfter} */
  insertToolsBefore(insertBefore, toolsToInsert) {
    this.insertTools(insertBefore, toolsToInsert, "before");
  }
  // @internal use `dispatchEvent` rather than calling `onEvent` directly.
  onEventInternal(event) {
    var _a6, _b2;
    const isEditorReadOnly = this.isEditorReadOnly.get();
    const canToolReceiveInput = (tool) => {
      return tool.isEnabled() && (!isEditorReadOnly || tool.canReceiveInputInReadOnlyEditor());
    };
    let handled = false;
    if (event.kind === InputEvtType.PointerDownEvt) {
      let canOnlySendToActiveTool = false;
      if (this.activeTool && !this.activeTool.eventCanBeDeliveredToNonActiveTool(event)) {
        canOnlySendToActiveTool = true;
      }
      for (const tool of this.tools) {
        if (canOnlySendToActiveTool && tool !== this.activeTool) {
          continue;
        }
        if (canToolReceiveInput(tool) && tool.onEvent(event)) {
          if (this.activeTool !== tool) {
            (_a6 = this.activeTool) == null ? void 0 : _a6.onEvent({ kind: InputEvtType.GestureCancelEvt });
          }
          this.activeTool = tool;
          handled = true;
          break;
        }
      }
    } else if (event.kind === InputEvtType.PointerUpEvt) {
      const upResult = (_b2 = this.activeTool) == null ? void 0 : _b2.onEvent(event);
      const continueHandlingEvents = upResult && event.allPointers.length > 1;
      if (!continueHandlingEvents) {
        this.activeTool = null;
      }
      handled = true;
    } else if (event.kind === InputEvtType.PointerMoveEvt) {
      if (this.activeTool !== null) {
        this.activeTool.onEvent(event);
        handled = true;
      }
    } else if (event.kind === InputEvtType.GestureCancelEvt) {
      if (this.activeTool !== null) {
        this.activeTool.onEvent(event);
        this.activeTool = null;
      }
    } else {
      for (const tool of this.tools) {
        if (!canToolReceiveInput(tool)) {
          continue;
        }
        handled = tool.onEvent(event);
        if (handled) {
          break;
        }
      }
    }
    return handled;
  }
  /** Alias for {@link dispatchInputEvent}. */
  onEvent(event) {
    return this.dispatchInputEvent(event);
  }
  // Returns true if the event was handled.
  dispatchInputEvent(event) {
    return this.inputPipeline.onEvent(event);
  }
  /**
   * Adds a new `InputMapper` to this' input pipeline.
   *
   * A `mapper` is really a relation that maps each event to no, one,
   * or many other events.
   *
   * @see {@link InputMapper}.
   */
  addInputMapper(mapper) {
    this.inputPipeline.addToTail(mapper);
  }
  getMatchingTools(type) {
    return this.tools.filter((tool) => tool instanceof type);
  }
  // @internal
  onEditorDestroyed() {
    for (const tool of this.tools) {
      tool.onDestroy();
    }
  }
};

// node_modules/js-draw/dist/mjs/UndoRedoHistory.mjs
var __classPrivateFieldSet9 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet9 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UndoRedoHistory_undoStack;
var _UndoRedoHistory_redoStack;
var UndoRedoHistory = class {
  // @internal
  constructor(editor, announceRedoCallback, announceUndoCallback) {
    this.editor = editor;
    this.announceRedoCallback = announceRedoCallback;
    this.announceUndoCallback = announceUndoCallback;
    _UndoRedoHistory_undoStack.set(this, void 0);
    _UndoRedoHistory_redoStack.set(this, void 0);
    this.maxUndoRedoStackSize = 700;
    __classPrivateFieldSet9(this, _UndoRedoHistory_undoStack, [], "f");
    __classPrivateFieldSet9(this, _UndoRedoHistory_redoStack, [], "f");
  }
  fireUpdateEvent(stackUpdateType, triggeringCommand) {
    this.editor.notifier.dispatch(EditorEventType.UndoRedoStackUpdated, {
      kind: EditorEventType.UndoRedoStackUpdated,
      undoStackSize: __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").length,
      redoStackSize: __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").length,
      command: triggeringCommand,
      stackUpdateType
    });
  }
  // Adds the given command to this and applies it to the editor.
  push(command, apply = true) {
    if (apply) {
      command.apply(this.editor);
    }
    __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").push(command);
    for (const elem of __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f")) {
      elem.onDrop(this.editor);
    }
    __classPrivateFieldSet9(this, _UndoRedoHistory_redoStack, [], "f");
    if (__classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").length > this.maxUndoRedoStackSize) {
      const removeAtOnceCount = Math.ceil(this.maxUndoRedoStackSize / 100);
      const removedElements = __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").splice(0, removeAtOnceCount);
      removedElements.forEach((elem) => elem.onDrop(this.editor));
    }
    this.fireUpdateEvent(UndoEventType.CommandDone, command);
    this.editor.notifier.dispatch(EditorEventType.CommandDone, {
      kind: EditorEventType.CommandDone,
      command
    });
  }
  // Remove the last command from this' undo stack and apply it.
  undo() {
    const command = __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").pop();
    if (command) {
      __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").push(command);
      const result = command.unapply(this.editor);
      this.announceUndoCallback(command);
      this.fireUpdateEvent(UndoEventType.CommandUndone, command);
      this.editor.notifier.dispatch(EditorEventType.CommandUndone, {
        kind: EditorEventType.CommandUndone,
        command
      });
      return result;
    }
  }
  redo() {
    const command = __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").pop();
    if (command) {
      __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").push(command);
      const result = command.apply(this.editor);
      this.announceRedoCallback(command);
      this.fireUpdateEvent(UndoEventType.CommandRedone, command);
      this.editor.notifier.dispatch(EditorEventType.CommandDone, {
        kind: EditorEventType.CommandDone,
        command
      });
      return result;
    }
  }
  get undoStackSize() {
    return __classPrivateFieldGet9(this, _UndoRedoHistory_undoStack, "f").length;
  }
  get redoStackSize() {
    return __classPrivateFieldGet9(this, _UndoRedoHistory_redoStack, "f").length;
  }
};
_UndoRedoHistory_undoStack = /* @__PURE__ */ new WeakMap(), _UndoRedoHistory_redoStack = /* @__PURE__ */ new WeakMap();
var UndoRedoHistory_default = UndoRedoHistory;

// node_modules/js-draw/dist/mjs/rendering/renderers/DummyRenderer.mjs
var DummyRenderer = class _DummyRenderer extends AbstractRenderer {
  constructor(viewport) {
    super(viewport);
    this.clearedCount = 0;
    this.renderedPathCount = 0;
    this.lastFillStyle = null;
    this.lastPoint = null;
    this.objectNestingLevel = 0;
    this.lastText = null;
    this.lastImage = null;
    this.pointBuffer = [];
  }
  displaySize() {
    const viewportSize = this.getViewport().getScreenRectSize();
    if (viewportSize.x === 0 || viewportSize.y === 0) {
      return Vec2.of(640, 480);
    }
    return viewportSize;
  }
  clear() {
    this.clearedCount++;
    this.renderedPathCount = 0;
    this.pointBuffer = [];
    this.lastText = null;
    this.lastImage = null;
    if (this.objectNestingLevel > 0) {
      throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`);
    }
  }
  beginPath(startPoint) {
    this.lastPoint = startPoint;
    this.pointBuffer.push(startPoint);
  }
  endPath(style) {
    this.renderedPathCount++;
    this.lastFillStyle = style;
  }
  lineTo(point) {
    point = this.canvasToScreen(point);
    this.lastPoint = point;
    this.pointBuffer.push(point);
  }
  moveTo(point) {
    point = this.canvasToScreen(point);
    this.lastPoint = point;
    this.pointBuffer.push(point);
  }
  traceCubicBezierCurve(p1, p2, p3) {
    p1 = this.canvasToScreen(p1);
    p2 = this.canvasToScreen(p2);
    p3 = this.canvasToScreen(p3);
    this.lastPoint = p3;
    this.pointBuffer.push(p1, p2, p3);
  }
  traceQuadraticBezierCurve(controlPoint, endPoint) {
    controlPoint = this.canvasToScreen(controlPoint);
    endPoint = this.canvasToScreen(endPoint);
    this.lastPoint = endPoint;
    this.pointBuffer.push(controlPoint, endPoint);
  }
  drawPoints(..._points) {
  }
  drawText(text, _transform, _style) {
    this.lastText = text;
  }
  drawImage(image) {
    this.lastImage = image;
  }
  startObject(boundingBox, _clip) {
    super.startObject(boundingBox);
    this.objectNestingLevel += 1;
  }
  endObject() {
    super.endObject();
    this.objectNestingLevel -= 1;
  }
  isTooSmallToRender(_rect) {
    return false;
  }
  canRenderFromWithoutDataLoss(other) {
    return other instanceof _DummyRenderer;
  }
  renderFromOtherOfSameType(transform, other) {
    if (!(other instanceof _DummyRenderer)) {
      throw new Error(`${other} cannot be rendered onto ${this}`);
    }
    this.renderedPathCount += other.renderedPathCount;
    this.lastFillStyle = other.lastFillStyle;
    this.lastPoint = other.lastPoint;
    this.pointBuffer.push(...other.pointBuffer.map((point) => {
      return transform.transformVec2(point);
    }));
  }
  toString() {
    return "[DummyRenderer]";
  }
};

// node_modules/js-draw/dist/mjs/rendering/caching/RenderingCacheNode.mjs
var cacheDivisionSize = 3;
var RenderingCacheNode = class _RenderingCacheNode {
  constructor(region, cacheState) {
    this.region = region;
    this.cacheState = cacheState;
    this.instantiatedChildren = [];
    this.parent = null;
    this.cachedRenderer = null;
    this.renderedIds = [];
    this.renderedMaxZIndex = null;
  }
  // Creates a previous layer of the cache tree and adds this as a child near the
  // center of the previous layer's children.
  // Returns this' parent if it already exists.
  generateParent() {
    if (this.parent) {
      return this.parent;
    }
    const parentRegion = Rect2.fromCorners(this.region.topLeft.minus(this.region.size), this.region.bottomRight.plus(this.region.size));
    const parent = new _RenderingCacheNode(parentRegion, this.cacheState);
    parent.generateChildren();
    const checkTolerance = this.region.maxDimension / 100;
    const middleChildIdx = (parent.instantiatedChildren.length - 1) / 2;
    if (!parent.instantiatedChildren[middleChildIdx].region.eq(this.region, checkTolerance)) {
      console.error(parent.instantiatedChildren[middleChildIdx].region, "≠", this.region);
      throw new Error("Logic error: [this] is not contained within its parent's center child");
    }
    parent.instantiatedChildren[middleChildIdx] = this;
    this.parent = parent;
    return parent;
  }
  // Generates children, if missing.
  generateChildren() {
    if (this.instantiatedChildren.length === 0) {
      if (this.region.size.x / cacheDivisionSize === 0 || this.region.size.y / cacheDivisionSize === 0) {
        console.warn("Cache element has zero size! Not generating children.");
        return;
      }
      const childRects = this.region.divideIntoGrid(cacheDivisionSize, cacheDivisionSize);
      console.assert(childRects.length === cacheDivisionSize * cacheDivisionSize, "Warning: divideIntoGrid created the wrong number of subrectangles!");
      for (const rect of childRects) {
        const child = new _RenderingCacheNode(rect, this.cacheState);
        child.parent = this;
        this.instantiatedChildren.push(child);
      }
    }
    this.checkRep();
  }
  // Returns CacheNodes directly contained within this.
  getChildren() {
    this.checkRep();
    this.generateChildren();
    return this.instantiatedChildren;
  }
  smallestChildContaining(rect) {
    const largerThanChildren = rect.maxDimension > this.region.maxDimension / cacheDivisionSize;
    if (!this.region.containsRect(rect) || largerThanChildren) {
      return null;
    }
    for (const child of this.getChildren()) {
      if (child.region.containsRect(rect)) {
        return child.smallestChildContaining(rect) ?? child;
      }
    }
    return null;
  }
  // => [true] iff [this] can be rendered without too much scaling
  renderingWouldBeHighEnoughResolution(viewport) {
    const sizeOfThisPixelOnCanvas = this.region.w / this.cacheState.props.blockResolution.x;
    const sizeOfThisPixelOnScreen = viewport.getScaleFactor() * sizeOfThisPixelOnCanvas;
    if (sizeOfThisPixelOnScreen > this.cacheState.props.maxScale) {
      return false;
    }
    return true;
  }
  // => [true] if all children of this can be rendered from their caches.
  allChildrenCanRender(viewport, leavesSortedById) {
    if (this.instantiatedChildren.length === 0) {
      return false;
    }
    for (const child of this.instantiatedChildren) {
      if (!child.region.intersects(viewport.visibleRect)) {
        continue;
      }
      if (!child.renderingIsUpToDate(this.idsOfIntersecting(leavesSortedById))) {
        return false;
      }
    }
    return true;
  }
  computeSortedByLeafIds(leaves) {
    const ids = leaves.slice();
    ids.sort((a, b) => a.getId() - b.getId());
    return ids;
  }
  // Returns a list of the ids of the nodes intersecting this
  idsOfIntersecting(nodes) {
    const result = [];
    for (const node of nodes) {
      if (node.getBBox().intersects(this.region)) {
        result.push(node.getId());
      }
    }
    return result;
  }
  // Returns true iff all elems of this.renderedIds are in sortedIds.
  // sortedIds should be sorted by z-index (or some other order, so long as they are
  // sorted by the same thing as this.renderedIds.)
  allRenderedIdsIn(sortedIds) {
    if (this.renderedIds.length > sortedIds.length) {
      return false;
    }
    for (let i = 0; i < this.renderedIds.length; i++) {
      if (sortedIds[i] !== this.renderedIds[i]) {
        return false;
      }
    }
    return true;
  }
  renderingIsUpToDate(sortedIds) {
    if (this.cachedRenderer === null || sortedIds.length !== this.renderedIds.length) {
      return false;
    }
    return this.allRenderedIdsIn(sortedIds);
  }
  // Render all [items] within [viewport]
  renderItems(screenRenderer, items, viewport) {
    var _a6;
    if (!viewport.visibleRect.intersects(this.region) || items.length === 0) {
      return;
    }
    const divideUntilSmallerThanThis = (itemsToDivide) => {
      const newItems = [];
      for (const item of itemsToDivide) {
        const bbox = item.getBBox();
        if (!bbox.intersects(this.region)) {
          continue;
        }
        if (bbox.maxDimension >= this.region.maxDimension) {
          newItems.push(...item.getChildrenOrSelfIntersectingRegion(this.region));
        } else {
          newItems.push(item);
        }
      }
      return newItems;
    };
    items = divideUntilSmallerThanThis(items);
    if (!this.cacheState.props.isOfCorrectType(screenRenderer)) {
      for (const item of items) {
        item.render(screenRenderer, viewport.visibleRect);
      }
      return;
    }
    if (this.cacheState.debugMode) {
      screenRenderer.drawRect(this.region, viewport.getSizeOfPixelOnCanvas(), {
        fill: Color4.yellow
      });
    }
    const couldRender = this.renderingWouldBeHighEnoughResolution(viewport);
    if (!couldRender) {
      for (const child of this.getChildren()) {
        child.renderItems(screenRenderer, items.filter((item) => {
          return item.getBBox().intersects(child.region);
        }), viewport);
      }
    } else {
      const tooSmallToRender = (rect) => rect.w / this.region.w < 1 / this.cacheState.props.blockResolution.x;
      const leaves = [];
      for (const item of items) {
        leaves.push(...item.getLeavesIntersectingRegion(this.region, tooSmallToRender));
      }
      sortLeavesByZIndex(leaves);
      const leavesByIds = this.computeSortedByLeafIds(leaves);
      if (leavesByIds.length === 0) {
        return;
      }
      const leafIds = leavesByIds.map((leaf) => leaf.getId());
      let thisRenderer;
      if (!this.renderingIsUpToDate(leafIds)) {
        if (this.allChildrenCanRender(viewport, leavesByIds)) {
          for (const child of this.getChildren()) {
            child.renderItems(screenRenderer, items, viewport);
          }
          return;
        }
        let leafApproxRenderTime = 0;
        for (const leaf of leavesByIds) {
          if (!tooSmallToRender(leaf.getBBox())) {
            leafApproxRenderTime += leaf.getContent().getProportionalRenderingTime();
          }
        }
        if (leafApproxRenderTime > this.cacheState.props.minProportionalRenderTimePerCache) {
          let fullRerenderNeeded = true;
          if (!this.cachedRenderer) {
            this.cachedRenderer = this.cacheState.recordManager.allocCanvas(this.region, () => this.onRegionDealloc());
          } else if (leavesByIds.length > this.renderedIds.length && this.allRenderedIdsIn(leafIds) && this.renderedMaxZIndex !== null) {
            const newLeaves = [];
            let minNewZIndex = null;
            for (let i = 0; i < leavesByIds.length; i++) {
              const leaf = leavesByIds[i];
              const content = leaf.getContent();
              const zIndex = content.getZIndex();
              if (i >= this.renderedIds.length || leaf.getId() !== this.renderedIds[i]) {
                newLeaves.push(leaf);
                if (minNewZIndex === null || zIndex < minNewZIndex) {
                  minNewZIndex = zIndex;
                }
              }
            }
            if (minNewZIndex !== null && minNewZIndex > this.renderedMaxZIndex) {
              fullRerenderNeeded = false;
              thisRenderer = this.cachedRenderer.startRender();
              for (let i = 0; i < leaves.length; i++) {
                const leaf = leaves[i];
                const zIndex = leaf.getContent().getZIndex();
                if (zIndex > this.renderedMaxZIndex) {
                  leaf.render(thisRenderer, this.region);
                  this.renderedMaxZIndex = zIndex;
                }
              }
              if (this.cacheState.debugMode) {
                screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {
                  fill: Color4.clay
                });
              }
            }
          } else if (this.cacheState.debugMode) {
            console.log("Decided on a full re-render. Reason: At least one of the following is false:", "\n leafIds.length > this.renderedIds.length: ", leafIds.length > this.renderedIds.length, "\n this.allRenderedIdsIn(leafIds): ", this.allRenderedIdsIn(leafIds), "\n this.renderedMaxZIndex !== null: ", this.renderedMaxZIndex !== null, "\n\nthis.rerenderedIds: ", this.renderedIds, ", leafIds: ", leafIds);
          }
          if (fullRerenderNeeded) {
            thisRenderer = this.cachedRenderer.startRender();
            thisRenderer.clear();
            this.renderedMaxZIndex = null;
            const startIndex = computeFirstIndexToRender(leaves, this.region);
            for (let i = startIndex; i < leaves.length; i++) {
              const leaf = leaves[i];
              const content = leaf.getContent();
              this.renderedMaxZIndex ?? (this.renderedMaxZIndex = content.getZIndex());
              this.renderedMaxZIndex = Math.max(this.renderedMaxZIndex, content.getZIndex());
              leaf.render(thisRenderer, this.region);
            }
            if (this.cacheState.debugMode) {
              screenRenderer.drawRect(this.region, 3 * viewport.getSizeOfPixelOnCanvas(), {
                fill: Color4.red
              });
            }
          }
          this.renderedIds = leafIds;
        } else {
          (_a6 = this.cachedRenderer) == null ? void 0 : _a6.dealloc();
          const pixelSize = viewport.getSizeOfPixelOnCanvas();
          const expandedRegion = new Rect2(this.region.x, this.region.y, this.region.w + pixelSize, this.region.h + pixelSize);
          const clip = true;
          screenRenderer.startObject(expandedRegion, clip);
          for (const leaf of leaves) {
            leaf.render(screenRenderer, this.region.intersection(viewport.visibleRect));
          }
          screenRenderer.endObject();
          if (this.cacheState.debugMode) {
            screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {
              fill: Color4.green
            });
          }
        }
      } else {
        thisRenderer = this.cachedRenderer.startRender();
      }
      if (thisRenderer) {
        const transformMat = this.cachedRenderer.getTransform(this.region).inverse();
        screenRenderer.renderFromOtherOfSameType(transformMat, thisRenderer);
      }
      if (this.instantiatedChildren.every((child) => child.isEmpty())) {
        this.instantiatedChildren = [];
      }
    }
    this.checkRep();
  }
  // Returns true iff this/its children have no cached state.
  isEmpty() {
    if (this.cachedRenderer !== null) {
      return false;
    }
    return this.instantiatedChildren.every((child) => child.isEmpty());
  }
  onRegionDealloc() {
    this.cachedRenderer = null;
    if (this.isEmpty()) {
      this.instantiatedChildren = [];
    }
  }
  checkRep() {
    if (this.instantiatedChildren.length !== cacheDivisionSize * cacheDivisionSize && this.instantiatedChildren.length !== 0) {
      throw new Error(`Repcheck: Wrong number of children. Got ${this.instantiatedChildren.length}`);
    }
    if (this.renderedIds[1] !== void 0 && this.renderedIds[0] >= this.renderedIds[1]) {
      console.error(this.renderedIds);
      throw new Error("Repcheck: First two ids are not in ascending order!");
    }
    for (const child of this.instantiatedChildren) {
      if (child.parent !== this) {
        throw new Error("Children should be linked to their parents!");
      }
    }
    if (this.cachedRenderer && !this.cachedRenderer.isAllocd()) {
      throw new Error("this' cachedRenderer != null, but is dealloc'd");
    }
  }
};

// node_modules/js-draw/dist/mjs/rendering/caching/CacheRecord.mjs
var CacheRecord = class {
  constructor(onBeforeDeallocCallback, cacheState) {
    this.onBeforeDeallocCallback = onBeforeDeallocCallback;
    this.cacheState = cacheState;
    this.allocd = false;
    this.allocCount = 0;
    this.renderer = cacheState.props.createRenderer();
    this.lastUsedCycle = -1;
    this.allocd = true;
  }
  startRender() {
    this.lastUsedCycle = this.cacheState.currentRenderingCycle;
    if (!this.allocd) {
      throw new Error("Only alloc'd canvases can be rendered to");
    }
    return this.renderer;
  }
  dealloc() {
    var _a6;
    (_a6 = this.onBeforeDeallocCallback) == null ? void 0 : _a6.call(this);
    this.allocd = false;
    this.onBeforeDeallocCallback = null;
    this.lastUsedCycle = 0;
  }
  isAllocd() {
    return this.allocd;
  }
  realloc(newDeallocCallback) {
    if (this.allocd) {
      this.dealloc();
    }
    this.allocd = true;
    this.onBeforeDeallocCallback = newDeallocCallback;
    this.lastUsedCycle = this.cacheState.currentRenderingCycle;
    this.allocCount++;
  }
  getLastUsedCycle() {
    return this.lastUsedCycle;
  }
  // Returns the transformation that maps [drawTo] to this' renderable region
  // (i.e. a [cacheProps.blockResolution]-sized rectangle with top left at (0, 0))
  getTransform(drawTo) {
    const transform = Mat33.scaling2D(this.cacheState.props.blockResolution.x / drawTo.size.x).rightMul(Mat33.translation(drawTo.topLeft.times(-1)));
    return transform;
  }
  setRenderingRegion(drawTo) {
    const transform = this.getTransform(drawTo);
    this.renderer.setTransform(transform);
    this.renderer.overrideVisibleRect(drawTo.grownBy(1 / transform.getScaleFactor()));
  }
};

// node_modules/js-draw/dist/mjs/rendering/caching/CacheRecordManager.mjs
var CacheRecordManager = class {
  constructor(cacheProps) {
    this.cacheRecords = [];
    this.maxCanvases = Math.ceil(
      // Assuming four components per pixel:
      cacheProps.cacheSize / 4 / cacheProps.blockResolution.x / cacheProps.blockResolution.y
    );
  }
  setSharedState(state) {
    this.cacheState = state;
  }
  allocCanvas(drawTo, onDealloc) {
    if (this.cacheRecords.length < this.maxCanvases) {
      const record = new CacheRecord(onDealloc, this.cacheState);
      record.setRenderingRegion(drawTo);
      this.cacheRecords.push(record);
      if (this.cacheState.debugMode) {
        console.log("[Cache] Cache spaces used: ", this.cacheRecords.length, " of ", this.maxCanvases);
      }
      return record;
    } else {
      const lru = this.getLeastRecentlyUsedRecord();
      if (this.cacheState.debugMode) {
        console.log("[Cache] Re-alloc. Times allocated: ", lru.allocCount, "\nLast used cycle: ", lru.getLastUsedCycle(), "\nCurrent cycle: ", this.cacheState.currentRenderingCycle);
      }
      lru.realloc(onDealloc);
      lru.setRenderingRegion(drawTo);
      if (this.cacheState.debugMode) {
        console.log("[Cache] Now re-alloc'd. Last used cycle: ", lru.getLastUsedCycle());
        console.assert(lru["cacheState"] === this.cacheState, "[Cache] Unequal cache states! cacheState should be a shared object!");
      }
      return lru;
    }
  }
  // Returns null if there are no cache records. Returns an unalloc'd record if one exists.
  getLeastRecentlyUsedRecord() {
    this.cacheRecords.sort((a, b) => a.getLastUsedCycle() - b.getLastUsedCycle());
    return this.cacheRecords[0];
  }
  // Returns information to (hopefully) help debug performance issues
  getDebugInfo() {
    let numberAllocd = 0;
    let averageReassignedCount = 0;
    for (const cacheRecord of this.cacheRecords) {
      averageReassignedCount += cacheRecord.allocCount;
      if (cacheRecord.isAllocd()) {
        numberAllocd++;
      }
    }
    averageReassignedCount /= Math.max(this.cacheRecords.length, 1);
    const debugInfo = [
      `${this.cacheRecords.length} cache records (max ${this.maxCanvases})`,
      `${numberAllocd} assigned to screen regions`,
      `Average number of times reassigned: ${Math.round(averageReassignedCount * 100) / 100}`
    ];
    return debugInfo.join("\n");
  }
};

// node_modules/js-draw/dist/mjs/rendering/caching/RenderingCache.mjs
var RenderingCache = class {
  constructor(cacheProps) {
    this.recordManager = new CacheRecordManager(cacheProps);
    this.sharedState = {
      props: cacheProps,
      currentRenderingCycle: 0,
      recordManager: this.recordManager,
      debugMode: false
    };
    this.recordManager.setSharedState(this.sharedState);
  }
  render(screenRenderer, image, viewport) {
    const visibleRect = viewport.visibleRect;
    this.sharedState.currentRenderingCycle++;
    if (!this.sharedState.props.isOfCorrectType(screenRenderer)) {
      image.render(screenRenderer, visibleRect);
      return;
    }
    if (!this.rootNode) {
      const res = this.sharedState.props.blockResolution;
      const topLeft = visibleRect.topLeft;
      this.rootNode = new RenderingCacheNode(new Rect2(topLeft.x, topLeft.y, res.x, res.y), this.sharedState);
    }
    while (!this.rootNode.region.containsRect(visibleRect)) {
      this.rootNode = this.rootNode.generateParent();
    }
    this.rootNode = this.rootNode.smallestChildContaining(visibleRect) ?? this.rootNode;
    const visibleLeaves = image.getLeavesIntersectingRegion(viewport.visibleRect, (rect) => screenRenderer.isTooSmallToRender(rect));
    let approxVisibleRenderTime = 0;
    for (const leaf of visibleLeaves) {
      approxVisibleRenderTime += leaf.getContent().getProportionalRenderingTime();
    }
    if (approxVisibleRenderTime > this.sharedState.props.minProportionalRenderTimeToUseCache) {
      this.rootNode.renderItems(screenRenderer, [image], viewport);
    } else {
      image.render(screenRenderer, visibleRect);
    }
  }
  getDebugInfo() {
    return this.recordManager.getDebugInfo();
  }
  setIsDebugMode(debugMode2) {
    this.sharedState.debugMode = debugMode2;
  }
};

// node_modules/js-draw/dist/mjs/rendering/renderers/TextOnlyRenderer.mjs
var TextOnlyRenderer = class extends AbstractRenderer {
  constructor(viewport, localizationTable) {
    super(viewport);
    this.localizationTable = localizationTable;
    this.descriptionBuilder = [];
    this.pathCount = 0;
    this.textNodeCount = 0;
    this.imageNodeCount = 0;
  }
  displaySize() {
    return Vec2.of(500, 500);
  }
  clear() {
    this.descriptionBuilder = [];
    this.pathCount = 0;
    this.textNodeCount = 0;
    this.imageNodeCount = 0;
  }
  getDescription() {
    return [
      this.localizationTable.pathNodeCount(this.pathCount),
      ...this.textNodeCount > 0 ? [this.localizationTable.textNodeCount(this.textNodeCount)] : [],
      ...this.imageNodeCount > 0 ? [this.localizationTable.imageNodeCount(this.imageNodeCount)] : [],
      ...this.descriptionBuilder
    ].join("\n");
  }
  beginPath(_startPoint) {
  }
  endPath(_style) {
    this.pathCount++;
  }
  lineTo(_point) {
  }
  moveTo(_point) {
  }
  traceCubicBezierCurve(_p1, _p2, _p3) {
  }
  traceQuadraticBezierCurve(_controlPoint, _endPoint) {
  }
  drawText(text, _transform, _style) {
    this.descriptionBuilder.push(this.localizationTable.textNode(text));
    this.textNodeCount++;
  }
  drawImage(image) {
    const label = image.label ? this.localizationTable.imageNode(image.label) : this.localizationTable.unlabeledImageNode;
    this.descriptionBuilder.push(label);
    this.imageNodeCount++;
  }
  isTooSmallToRender(rect) {
    return rect.maxDimension < 15 / this.getSizeOfCanvasPixelOnScreen();
  }
  drawPoints(..._points) {
  }
};

// node_modules/js-draw/dist/mjs/rendering/Display.mjs
var RenderingMode;
(function(RenderingMode2) {
  RenderingMode2[RenderingMode2["DummyRenderer"] = 0] = "DummyRenderer";
  RenderingMode2[RenderingMode2["CanvasRenderer"] = 1] = "CanvasRenderer";
})(RenderingMode || (RenderingMode = {}));
var Display = class {
  /** @internal */
  constructor(editor, mode, parent) {
    this.editor = editor;
    this.parent = parent;
    this.textRerenderOutput = null;
    this.devicePixelRatio = window.devicePixelRatio ?? 1;
    this.getColorAt = (_screenPos) => {
      return null;
    };
    if (mode === RenderingMode.CanvasRenderer) {
      this.initializeCanvasRendering();
    } else if (mode === RenderingMode.DummyRenderer) {
      this.dryInkRenderer = new DummyRenderer(editor.viewport);
      this.wetInkRenderer = new DummyRenderer(editor.viewport);
    } else {
      throw new Error(`Unknown rendering mode, ${mode}!`);
    }
    this.textRenderer = new TextOnlyRenderer(editor.viewport, editor.localization);
    this.initializeTextRendering();
    const cacheBlockResolution = Vec2.of(600, 600);
    this.cache = new RenderingCache({
      createRenderer: () => {
        if (mode === RenderingMode.DummyRenderer) {
          return new DummyRenderer(editor.viewport);
        } else if (mode !== RenderingMode.CanvasRenderer) {
          throw new Error("Unspported rendering mode");
        }
        const canvas = document.createElement("canvas");
        canvas.width = cacheBlockResolution.x + 1;
        canvas.height = cacheBlockResolution.y + 1;
        const ctx = canvas.getContext("2d");
        return new CanvasRenderer(ctx, editor.viewport);
      },
      isOfCorrectType: (renderer) => {
        return this.dryInkRenderer.canRenderFromWithoutDataLoss(renderer);
      },
      blockResolution: cacheBlockResolution,
      cacheSize: 600 * 600 * 4 * 90,
      // On higher resolution displays, don't scale cache blocks as much to decrease blurriness.
      // TODO: Decrease the minimum cache scale as well.
      maxScale: Math.max(1, 1.3 / window.devicePixelRatio),
      // Require about 20 strokes with 4 parts each to cache an image in one of the
      // parts of the cache grid.
      minProportionalRenderTimePerCache: 20 * 4,
      // Require about 105 strokes with 4 parts each to use the cache at all.
      minProportionalRenderTimeToUseCache: 105 * 4
    });
    this.editor.notifier.on(EditorEventType.DisplayResized, (event) => {
      var _a6;
      if (event.kind !== EditorEventType.DisplayResized) {
        throw new Error("Mismatched event.kinds!");
      }
      (_a6 = this.resizeSurfacesCallback) == null ? void 0 : _a6.call(this);
    });
  }
  /**
   * @returns the visible width of the display (e.g. how much
   * space the display's element takes up in the x direction
   * in the DOM).
   */
  get width() {
    return this.dryInkRenderer.displaySize().x;
  }
  /** @returns the visible height of the display. See {@link width}. */
  get height() {
    return this.dryInkRenderer.displaySize().y;
  }
  /** @internal */
  getCache() {
    return this.cache;
  }
  initializeCanvasRendering() {
    const dryInkCanvas = document.createElement("canvas");
    const wetInkCanvas = document.createElement("canvas");
    const dryInkCtx = dryInkCanvas.getContext("2d");
    const wetInkCtx = wetInkCanvas.getContext("2d");
    this.dryInkRenderer = new CanvasRenderer(dryInkCtx, this.editor.viewport);
    this.wetInkRenderer = new CanvasRenderer(wetInkCtx, this.editor.viewport);
    dryInkCanvas.className = "dryInkCanvas";
    wetInkCanvas.className = "wetInkCanvas";
    if (this.parent) {
      this.parent.appendChild(dryInkCanvas);
      this.parent.appendChild(wetInkCanvas);
    }
    this.resizeSurfacesCallback = () => {
      const expectedWidth = (canvas) => {
        const widthInPixels = Math.ceil(canvas.clientWidth * this.devicePixelRatio);
        return widthInPixels || canvas.width;
      };
      const expectedHeight = (canvas) => {
        const heightInPixels = Math.ceil(canvas.clientHeight * this.devicePixelRatio);
        return heightInPixels || canvas.height;
      };
      const hasSizeMismatch = (canvas) => {
        return expectedHeight(canvas) !== canvas.height || expectedWidth(canvas) !== canvas.width;
      };
      if (hasSizeMismatch(dryInkCanvas) || hasSizeMismatch(wetInkCanvas)) {
        dryInkCanvas.width = expectedWidth(dryInkCanvas);
        dryInkCanvas.height = expectedHeight(dryInkCanvas);
        wetInkCanvas.width = expectedWidth(wetInkCanvas);
        wetInkCanvas.height = expectedHeight(wetInkCanvas);
        wetInkCtx.resetTransform();
        dryInkCtx.resetTransform();
        dryInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);
        wetInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);
        this.editor.notifier.dispatch(EditorEventType.DisplayResized, {
          kind: EditorEventType.DisplayResized,
          newSize: Vec2.of(this.width, this.height)
        });
      }
    };
    this.resizeSurfacesCallback();
    this.flattenCallback = () => {
      dryInkCtx.save();
      dryInkCtx.resetTransform();
      dryInkCtx.drawImage(wetInkCanvas, 0, 0);
      dryInkCtx.restore();
    };
    this.getColorAt = (screenPos) => {
      const adjustedScreenPos = screenPos.times(this.devicePixelRatio);
      const pixel = dryInkCtx.getImageData(adjustedScreenPos.x, adjustedScreenPos.y, 1, 1);
      const data = pixel == null ? void 0 : pixel.data;
      if (data) {
        const color = Color4.ofRGBA(data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255);
        return color;
      }
      return null;
    };
  }
  initializeTextRendering() {
    const textRendererOutputContainer = document.createElement("div");
    textRendererOutputContainer.classList.add("textRendererOutputContainer");
    const rerenderButton = document.createElement("button");
    rerenderButton.classList.add("rerenderButton");
    rerenderButton.innerText = this.editor.localization.rerenderAsText;
    this.textRerenderOutput = document.createElement("div");
    this.textRerenderOutput.setAttribute("aria-live", "polite");
    rerenderButton.onclick = () => {
      this.rerenderAsText();
    };
    textRendererOutputContainer.replaceChildren(rerenderButton, this.textRerenderOutput);
    this.editor.createHTMLOverlay(textRendererOutputContainer);
  }
  /**
   * Sets the device-pixel-ratio.
   *
   * Intended for debugging. Users do not need to call this manually.
   *
   * @internal
   */
  setDevicePixelRatio(dpr) {
    var _a6;
    const minDpr = 1e-3;
    const maxDpr = 10;
    if (isFinite(dpr) && dpr >= minDpr && dpr <= maxDpr && dpr !== this.devicePixelRatio) {
      this.devicePixelRatio = dpr;
      (_a6 = this.resizeSurfacesCallback) == null ? void 0 : _a6.call(this);
      return this.editor.queueRerender();
    }
    return void 0;
  }
  /** @internal */
  getDevicePixelRatio() {
    return this.devicePixelRatio;
  }
  /**
   * Rerenders the text-based display.
   * The text-based display is intended for screen readers and can be navigated to by pressing `tab`.
   */
  rerenderAsText() {
    this.textRenderer.clear();
    this.editor.image.render(this.textRenderer, this.editor.viewport);
    if (this.textRerenderOutput) {
      this.textRerenderOutput.innerText = this.textRenderer.getDescription();
    }
  }
  /**
   * Clears the main drawing surface and otherwise prepares for a rerender.
   *
   * @returns the dry ink renderer.
   */
  startRerender() {
    var _a6;
    (_a6 = this.resizeSurfacesCallback) == null ? void 0 : _a6.call(this);
    this.dryInkRenderer.clear();
    return this.dryInkRenderer;
  }
  /**
   * If `draftMode`, the dry ink renderer is configured to render
   * low-quality output.
   */
  setDraftMode(draftMode) {
    this.dryInkRenderer.setDraftMode(draftMode);
  }
  /** @internal */
  getDryInkRenderer() {
    return this.dryInkRenderer;
  }
  /**
   * @returns The renderer used for showing action previews (e.g. an unfinished stroke).
   * The `wetInkRenderer`'s surface is stacked above the `dryInkRenderer`'s.
   */
  getWetInkRenderer() {
    return this.wetInkRenderer;
  }
  /** Re-renders the contents of the wetInkRenderer onto the dryInkRenderer. */
  flatten() {
    var _a6;
    (_a6 = this.flattenCallback) == null ? void 0 : _a6.call(this);
  }
};

// node_modules/js-draw/dist/mjs/components/builders/PolylineBuilder.mjs
var makePolylineBuilder = makeShapeFitAutocorrect_default((initialPoint, viewport) => {
  const minFit = viewport.getSizeOfPixelOnCanvas() * 0.65;
  return new PolylineBuilder(initialPoint, minFit, viewport);
});
var PolylineBuilder = class {
  constructor(startPoint, minFitAllowed, viewport) {
    this.minFitAllowed = minFitAllowed;
    this.viewport = viewport;
    this.parts = [];
    this.widthAverageNumSamples = 1;
    this.lastLineSegment = null;
    this.averageWidth = startPoint.width;
    this.startPoint = {
      ...startPoint,
      pos: this.roundPoint(startPoint.pos)
    };
    this.lastPoint = this.startPoint.pos;
    this.bbox = new Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);
    this.parts = [
      {
        kind: PathCommandType.MoveTo,
        point: this.startPoint.pos
      }
    ];
  }
  getBBox() {
    return this.bbox.grownBy(this.averageWidth);
  }
  getRenderingStyle() {
    return {
      fill: Color4.transparent,
      stroke: {
        color: this.startPoint.color,
        width: this.roundDistance(this.averageWidth)
      }
    };
  }
  previewCurrentPath() {
    const startPoint = this.startPoint.pos;
    const commands = [...this.parts];
    if (commands.length <= 1) {
      commands.push({
        kind: PathCommandType.LineTo,
        point: startPoint.plus(Vec2.of(this.averageWidth / 4, 0))
      });
    }
    return {
      startPoint,
      commands,
      style: this.getRenderingStyle()
    };
  }
  previewFullPath() {
    return [this.previewCurrentPath()];
  }
  preview(renderer) {
    const paths = this.previewFullPath();
    if (paths) {
      const approxBBox = this.viewport.visibleRect;
      renderer.startObject(approxBBox);
      for (const path of paths) {
        renderer.drawPath(path);
      }
      renderer.endObject();
    }
  }
  build() {
    return new Stroke(this.previewFullPath());
  }
  getMinFit() {
    let minFit = Math.min(this.minFitAllowed, this.averageWidth / 4);
    if (minFit < 1e-10) {
      minFit = this.minFitAllowed;
    }
    return minFit;
  }
  roundPoint(point) {
    const minFit = this.getMinFit();
    return Viewport_default.roundPoint(point, minFit);
  }
  roundDistance(dist) {
    const minFit = this.getMinFit();
    return Viewport_default.roundPoint(dist, minFit);
  }
  addPoint(newPoint) {
    this.widthAverageNumSamples++;
    this.averageWidth = this.averageWidth * (this.widthAverageNumSamples - 1) / this.widthAverageNumSamples + newPoint.width / this.widthAverageNumSamples;
    const roundedPoint = this.roundPoint(newPoint.pos);
    if (!roundedPoint.eq(this.lastPoint)) {
      if (this.lastLineSegment && this.lastLineSegment.direction.dot(roundedPoint.minus(this.lastPoint).normalized()) > 0.997) {
        this.parts.pop();
        this.lastPoint = this.lastLineSegment.p1;
      }
      this.parts.push({
        kind: PathCommandType.LineTo,
        point: this.roundPoint(newPoint.pos)
      });
      this.bbox = this.bbox.grownToPoint(roundedPoint);
      this.lastLineSegment = new LineSegment2(this.lastPoint, roundedPoint);
      this.lastPoint = roundedPoint;
    }
  }
};

// node_modules/js-draw/dist/mjs/util/createElement.mjs
var ElementNamespace;
(function(ElementNamespace2) {
  ElementNamespace2["Html"] = "html";
  ElementNamespace2["Svg"] = "svg";
})(ElementNamespace || (ElementNamespace = {}));
var createElement = (tag, props, elementType = ElementNamespace.Html) => {
  let elem;
  if (elementType === ElementNamespace.Html) {
    elem = document.createElement(tag);
  } else if (elementType === ElementNamespace.Svg) {
    elem = document.createElementNS("http://www.w3.org/2000/svg", tag);
  } else {
    throw new Error(`Unknown element type ${elementType}`);
  }
  for (const [key, value] of Object.entries(props)) {
    if (key === "children")
      continue;
    if (typeof value !== "string" && typeof value !== "number") {
      throw new Error(`Unsupported value type ${typeof value}`);
    }
    elem.setAttribute(key, value.toString());
  }
  if (props.children) {
    for (const item of props.children) {
      elem.appendChild(item);
    }
  }
  return elem;
};
var createSvgElement = (tag, props) => {
  return createElement(tag, props, ElementNamespace.Svg);
};
var createSvgElements = (tag, elements) => {
  return elements.map((props) => createSvgElement(tag, props));
};
var createSvgPaths = (...paths) => {
  return createSvgElements("path", paths);
};

// node_modules/js-draw/dist/mjs/toolbar/IconProvider.mjs
var __classPrivateFieldGet10 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _IconProvider_instances;
var _IconProvider_makeXIcon;
var svgNamespace = "http://www.w3.org/2000/svg";
var checkerboardIdCounter = 0;
var makeCheckerboardPattern = () => {
  const id = `checkerboard-${checkerboardIdCounter++}`;
  const patternElement = createSvgElement("pattern", {
    id,
    viewBox: "0,0,10,10",
    width: "20%",
    height: "20%",
    patternUnits: "userSpaceOnUse",
    children: createSvgElements("rect", [
      { x: 0, y: 0, width: 10, height: 10, fill: "white" },
      { x: 0, y: 0, width: 5, height: 5, fill: "gray" },
      { x: 5, y: 5, width: 5, height: 5, fill: "gray" }
    ])
  });
  const patternRef = `url(#${id})`;
  return {
    patternDefElement: patternElement,
    // @deprecated use patternDefElement
    get patternDef() {
      return patternElement.innerHTML;
    },
    patternRef
  };
};
var makeRedoIcon = (mirror) => {
  const icon = document.createElementNS(svgNamespace, "svg");
  icon.innerHTML = `
		<style>
			.toolbar-svg-undo-redo-icon {
				stroke: var(--icon-color);
				stroke-width: 12;
				stroke-linejoin: round;
				stroke-linecap: round;
				fill: none;

				transform-origin: center;
			}
		</style>
	`;
  const path = document.createElementNS(svgNamespace, "path");
  path.setAttribute("d", "M20,20 A15,15 0 0 1 70,80 L80,90 L60,70 L65,90 L87,90 L65,80");
  path.classList.add("toolbar-svg-undo-redo-icon");
  if (mirror) {
    path.style.transform = "scale(-1, 1)";
  }
  icon.appendChild(path);
  icon.setAttribute("viewBox", "0 0 100 100");
  return icon;
};
var IconProvider = class {
  constructor() {
    _IconProvider_instances.add(this);
  }
  makeUndoIcon() {
    return makeRedoIcon(true);
  }
  // @returns a redo icon.
  makeRedoIcon() {
    return makeRedoIcon(false);
  }
  makeDropdownIcon() {
    const icon = this.makeIconFromPath("M5,10 L50,90 L95,10 Z");
    icon.setAttribute("viewBox", "-10 -10 110 110");
    return icon;
  }
  makeEraserIcon(eraserSize, mode) {
    eraserSize ?? (eraserSize = 10);
    const scaledSize = eraserSize / 4;
    const eraserColor = "#ff70af";
    const icon = createSvgElement("svg", {
      viewBox: "0 0 120 120",
      children: [
        createSvgElement("defs", {
          children: [
            createSvgElement("linearGradient", {
              id: "dash-pattern",
              children: createSvgElements("stop", [
                { offset: "80%", "stop-color": eraserColor },
                { offset: "85%", "stop-color": "white" },
                { offset: "90%", "stop-color": eraserColor }
              ])
            })
          ]
        }),
        createSvgElement("path", {
          fill: mode === EraserMode.PartialStroke ? "url(#dash-pattern)" : eraserColor,
          stroke: "black",
          transform: "rotate(41.35)",
          d: `
						M 52.5 27
						C 50 28.9 48.9 31.7 48.9 34.8
						L 48.9 39.8
						C 48.9 45.3 53.4 49.8 58.9 49.8
						L 103.9 49.8
						C 105.8 49.8 107.6 49.2 109.1 48.3
						L 110.2 ${scaledSize + 49.5} L 159.7 ${scaledSize + 5}
						L 157.7 ${-scaledSize + 5.2} L 112.4 ${49.5 - scaledSize}
						C 113.4 43.5 113.9 41.7 113.9 39.8
						L 113.9 34.8
						C 113.9 29.3 109.4 24.8 103.9 24.8
						L 58.9 24.8
						C 56.5 24.8 54.3 25.7 52.5 27
						z
					`
        }),
        createSvgElement("rect", {
          stroke: "#cc8077",
          fill: "var(--icon-color)",
          width: 65,
          height: 75,
          x: 48.9,
          y: -38.7,
          transform: "rotate(41.35)"
        })
      ]
    });
    return icon;
  }
  makeSelectionIcon(mode = SelectionMode.Rectangle) {
    const icon = document.createElementNS(svgNamespace, "svg");
    if (mode === SelectionMode.Rectangle) {
      icon.innerHTML = `
			<g>
				<rect x="10" y="10" width="70" height="70" fill="pink" stroke="black" stroke-dasharray="32 9"/>
				<rect x="75" y="75" width="10" height="10" fill="white" stroke="black"/>
			</g>
			`;
    } else {
      icon.innerHTML = `
			<g>
				<rect x="10" y="10" width="76" height="76" rx="50" stroke-dasharray="32 9" fill="pink" stroke="black"/>
				<rect x="71" y="71" width="10" height="10" fill="white" stroke="black"/>
			</g>
			`;
    }
    icon.setAttribute("viewBox", "0 0 100 100");
    return icon;
  }
  makeRotateIcon() {
    const icon = document.createElementNS(svgNamespace, "svg");
    icon.innerHTML = `
			<defs>
				<marker
					id="arrow-marker"
					viewBox="0 0 10 10"
					refX="3" refY="5"
					markerWidth="3" markerHeight="3"
					orient="auto-start-reverse"
				>
					<path
						d="M0,0 L8,5 L0,10z"
						fill="var(--icon-color)"
					/>
				</marker>
			</defs>

			<path
				marker-start="url(#arrow-marker)"
				d="
					M20,20
					A30,30 0 1 1 80 80
				"
				fill="none"
				stroke="var(--icon-color)"
				stroke-width="12"
			/>
			<path
				d="
					M80,80
					A30,30 0 1 1 20 20
				"
				fill="none"
				stroke="var(--icon-color)"
				stroke-width="12"
				stroke-dasharray="30 10 20 10 20 10 10"
				style="stroke-linecap: butt;"
			/>
		`;
    icon.setAttribute("viewBox", "-5 -5 110 110");
    return icon;
  }
  makeHandToolIcon() {
    const fill = "none";
    const strokeColor = "var(--icon-color)";
    const strokeWidth = "3";
    return this.makeIconFromPath(`
			m 10,60
				5,30
			H 90
			V 30
			C 90,20 75,20 75,30
			V 60
				20
			C 75,10 60,10 60,20
			V 60
				15
			C 60,5 45,5 45,15
			V 60
				25
			C 45,15 30,15 30,25
			V 60
				75
			L 25,60
			C 20,45 10,50 10,60
			Z
		`, fill, strokeColor, strokeWidth);
  }
  makeTouchPanningIcon() {
    const fill = "none";
    const strokeColor = "var(--icon-color)";
    const strokeWidth = "3";
    return this.makeIconFromPath(`
			M 5,5.5
			V 17.2
			L 16.25,5.46
			Z
	
			m 33.75,0
			L 50,17
			V 5.5
			Z
	
			M 5,40.7
			v 11.7
			h 11.25
			z
	
			M 26,19
			C 19.8,19.4 17.65,30.4 21.9,34.8
			L 50,70
			H 27.5
			c -11.25,0 -11.25,17.6 0,17.6
			H 61.25
			C 94.9,87.8 95,87.6 95,40.7 78.125,23 67,29 55.6,46.5
			L 33.1,23
			C 30.3125,20.128192 27.9,19 25.830078,19.119756
			Z
		`, fill, strokeColor, strokeWidth);
  }
  /** Unused by js-draw. @deprecated */
  makeAllDevicePanningIcon() {
    const fill = "none";
    const strokeColor = "var(--icon-color)";
    const strokeWidth = "3";
    return this.makeIconFromPath(`
			M 5 5
			L 5 17.5
				17.5 5
				5 5
			z
	
			M 42.5 5
			L 55 17.5
				55 5
				42.5 5
			z
	
			M 70 10
			L 70 21
				61 15
				55.5 23
				66 30
				56 37
				61 45
				70 39
				70 50
				80 50
				80 39
				89 45
				95 36
				84 30
				95 23
				89 15
				80 21
				80 10
				70 10
			z
	
			M 27.5 26.25
			L 27.5 91.25
			L 43.75 83.125
			L 52 99
			L 68 91
			L 60 75
			L 76.25 66.875
			L 27.5 26.25
			z
	
			M 5 42.5
			L 5 55
			L 17.5 55
			L 5 42.5
			z
		`, fill, strokeColor, strokeWidth);
  }
  makeZoomIcon() {
    const icon = document.createElementNS(svgNamespace, "svg");
    icon.setAttribute("viewBox", "0 0 100 100");
    const addTextNode = (text, x, y) => {
      const textNode = document.createElementNS(svgNamespace, "text");
      textNode.appendChild(document.createTextNode(text));
      textNode.setAttribute("x", x.toString());
      textNode.setAttribute("y", y.toString());
      textNode.style.textAlign = "center";
      textNode.style.textAnchor = "middle";
      textNode.style.fontSize = "55px";
      textNode.style.fill = "var(--icon-color)";
      textNode.style.fontFamily = "monospace";
      icon.appendChild(textNode);
    };
    addTextNode("+", 40, 45);
    addTextNode("-", 70, 75);
    return icon;
  }
  makeRotationLockIcon() {
    const icon = this.makeIconFromPath(`
			M 40.1 25.1 
			C 32.5 25 27.9 34.1 27.9 34.1 
			L 25.7 30 
			L 28 44.7 
			L 36.6 40.3 
			L 32.3 38.3 
			C 33.6 28 38.1 25.2 45.1 31.8 
			L 49.4 29.6 
			C 45.9 26.3 42.8 25.1 40.1 25.1 
			z

			M 51.7 34.2 
			L 43.5 39.1 
			L 48 40.8 
			C 47.4 51.1 43.1 54.3 35.7 48.2 
			L 31.6 50.7 
			C 45.5 62.1 52.6 44.6 52.6 44.6 
			L 55.1 48.6 
			L 51.7 34.2 
			z

			M 56.9 49.9 
			C 49.8 49.9 49.2 57.3 49.3 60.9 
			L 47.6 60.9 
			L 47.6 73.7 
			L 66.1 73.7 
			L 66.1 60.9 
			L 64.4 60.9 
			C 64.5 57.3 63.9 49.9 56.9 49.9 
			z

			M 56.9 53.5 
			C 60.8 53.5 61 58.2 60.8 60.9 
			L 52.9 60.9 
			C 52.7 58.2 52.9 53.5 56.9 53.5 
			z
		`);
    icon.setAttribute("viewBox", "10 10 70 70");
    return icon;
  }
  makeInsertImageIcon() {
    return this.makeIconFromPath(`
			M 5 10 L 5 90 L 95 90 L 95 10 L 5 10 z
			M 10 15 L 90 15 L 90 50 L 70 75 L 40 50 L 10 75 L 10 15 z
			M 22.5 25 A 7.5 7.5 0 0 0 15 32.5 A 7.5 7.5 0 0 0 22.5 40 A 7.5 7.5 0 0 0 30 32.5 A 7.5 7.5 0 0 0 22.5 25 z 
		`);
  }
  makeUploadFileIcon() {
    return this.makeIconFromPath(`
			M 48,10 32,34 43,33 42,68
			H 54
			L 53,33 64,34 Z
	
			M 8,66 V 86 H 88 V 66 H 78 V 76 H 18 V 66 Z
		`);
  }
  makeTextIcon(textStyle) {
    const icon = document.createElementNS(svgNamespace, "svg");
    icon.setAttribute("viewBox", "0 0 100 100");
    const textNode = document.createElementNS(svgNamespace, "text");
    textNode.appendChild(document.createTextNode("T"));
    textNode.style.fontFamily = textStyle.fontFamily;
    textNode.style.fontWeight = textStyle.fontWeight ?? "";
    textNode.style.fontVariant = textStyle.fontVariant ?? "";
    textNode.style.fill = textStyle.renderingStyle.fill.toHexString();
    textNode.style.textAnchor = "middle";
    textNode.setAttribute("x", "50");
    textNode.setAttribute("y", "75");
    textNode.style.fontSize = "65px";
    textNode.style.filter = "drop-shadow(0px 0px 10px var(--shadow-color))";
    icon.appendChild(textNode);
    return icon;
  }
  makePenIcon(penStyle) {
    const strokeSize = Math.round(Math.sqrt(penStyle.thickness) * 4);
    const color = penStyle.color;
    const rounded = this.isRoundedTipPen(penStyle);
    const tipThickness = strokeSize / 2;
    const inkTipPath = `
			M ${15 - tipThickness},${80 - tipThickness}
			  ${15 - tipThickness},${80 + tipThickness}
			  30,83
			  15,65
			Z
		`;
    const trailStartEndY = 80 + tipThickness;
    const inkTrailPath = `
			m ${15 - tipThickness * 1.1},${trailStartEndY}
			c 35,10 55,15 60,30
			l ${35 + tipThickness * 1.2},${-10 - tipThickness}
			C 80.47,98.32 50.5,${90 + tipThickness} 20,${trailStartEndY} Z
		`;
    const colorBubblePath = `
			M 72.45,35.67
			A 10,15 41.8 0 1 55,40.2 10,15 41.8 0 1 57.55,22.3 10,15 41.8 0 1 75,17.8 10,15 41.8 0 1 72.5,35.67
			Z
		`;
    let gripMainPath = "M 85,-25 25,35 h 10 v 10 h 10 v 10 h 10 v 10 h 10 l -5,10 60,-60 z";
    let gripShadow1Path = "M 25,35 H 35 L 90,-15 85,-25 Z";
    let gripShadow2Path = "M 60,75 65,65 H 55 l 55,-55 10,5 z";
    if (rounded) {
      gripMainPath = "M 85,-25 25,35 c 15,0 40,30 35,40 l 60,-60 z";
      gripShadow1Path = "m 25,35 c 3.92361,0.384473 7.644275,0.980572 10,3 l 55,-53 -5,-10 z";
      gripShadow2Path = "M 60,75 C 61,66 59,65 56,59 l 54,-54 10,10 z";
    }
    const penTipPath = `M 25,35 ${10 - tipThickness / 4},${70 - tipThickness / 2} 20,75 25,85 60,75 70,55 45,25 Z`;
    const pencilTipColor = Color4.fromHex("#f4d7d7");
    const tipColor = pencilTipColor.mix(color, tipThickness / 40 - 0.1).toHexString();
    const checkerboardPattern = makeCheckerboardPattern();
    const colorString = color.toHexString();
    const ink = createSvgPaths({
      fill: checkerboardPattern.patternRef,
      d: inkTipPath
    }, {
      fill: checkerboardPattern.patternRef,
      d: inkTrailPath
    }, {
      fill: colorString,
      d: inkTipPath
    }, {
      fill: colorString,
      d: inkTrailPath
    });
    const penTip = createSvgPaths({ fill: checkerboardPattern.patternRef, d: penTipPath }, { fill: tipColor, stroke: colorString, d: penTipPath });
    const grip = createSvgPaths(
      { fill: "var(--icon-color)", stroke: "var(--icon-color)", d: gripMainPath },
      // Shadows
      { fill: "rgba(150, 150, 150, 0.3)", d: gripShadow1Path },
      { fill: "rgba(100, 100, 100, 0.2)", d: gripShadow2Path },
      // Color bubble
      { fill: checkerboardPattern.patternRef, d: colorBubblePath },
      { fill: colorString, d: colorBubblePath }
    );
    const icon = document.createElementNS(svgNamespace, "svg");
    icon.setAttribute("viewBox", "0 0 100 100");
    const iconMainContent = createSvgElement("g", {
      children: [ink, penTip, grip].flat()
    });
    const defs = createSvgElement("defs", {
      children: [checkerboardPattern.patternDefElement]
    });
    icon.replaceChildren(defs, iconMainContent);
    return icon;
  }
  makeIconFromFactory(penStyle) {
    const thickness = Math.sqrt(penStyle.thickness) * 3;
    const nowTime = performance.now();
    const startPoint = {
      pos: Vec2.of(10, 10),
      width: thickness,
      color: penStyle.color,
      time: nowTime - 100
    };
    const endPoint = {
      pos: Vec2.of(90, 90),
      width: thickness,
      color: penStyle.color,
      time: nowTime
    };
    const viewport = new Viewport_default(() => {
    });
    const builder = penStyle.factory(startPoint, viewport);
    builder.addPoint(endPoint);
    const icon = document.createElementNS(svgNamespace, "svg");
    icon.setAttribute("viewBox", "0 0 100 100");
    viewport.updateScreenSize(Vec2.of(100, 100));
    let renderer;
    const includeTransparencyGrid = penStyle.color.a < 1;
    if (includeTransparencyGrid) {
      const checkerboardPattern = makeCheckerboardPattern();
      const defs = document.createElementNS(svgNamespace, "defs");
      defs.appendChild(checkerboardPattern.patternDefElement);
      icon.appendChild(defs);
      const background = document.createElementNS(svgNamespace, "g");
      icon.appendChild(background);
      renderer = new class extends SVGRenderer {
        constructor() {
          super(icon, viewport);
        }
        addPathToSVG() {
          const addedPath = super.addPathToSVG();
          if (addedPath) {
            const copy = addedPath.cloneNode(true);
            copy.style.zIndex = "-1";
            if (copy.hasAttribute("stroke")) {
              copy.setAttribute("stroke", checkerboardPattern.patternRef);
            } else if (copy.hasAttribute("fill")) {
              copy.setAttribute("fill", checkerboardPattern.patternRef);
            }
            background.appendChild(copy);
          }
          return addedPath;
        }
      }();
    } else {
      renderer = new SVGRenderer(icon, viewport);
    }
    builder.preview(renderer);
    const bbox = builder.getBBox();
    icon.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}`);
    return icon;
  }
  makePipetteIcon(color) {
    const icon = document.createElementNS(svgNamespace, "svg");
    const mainGroup = document.createElementNS(svgNamespace, "g");
    mainGroup.style.rotate = "45deg";
    mainGroup.style.transformOrigin = "center";
    const pipette = document.createElementNS(svgNamespace, "g");
    pipette.innerHTML = `
		<path
			style="fill: var(--icon-color); stroke-linecap:round; stroke-linejoin:round;"
			d="
				m 32,12 v 68
				c 0,1 0.5,2 1.33,2.5 1.67,1.15 3.67,2.1 5.17,3.2 1.4,1.1 2.3,2.1 2.5,3.1 0.6,2.1 1,4.6 1,6.2 0,3.7 5.45,4.1 6,0.4 l 0.9,-6.8
				c 0.3,-0.9 1.1,-1.9 2.6,-2.9 1.5,-1.1 3.4,-2 5.1,-3.2
				C 57.5,82 58,81 58,80
				V 12 Z m 20,25 v 41.3
				c 0,1.7 -2.5,1.6 -4,2.7 -1,0.76 -2.1,1.5 -3,2.6
				C 44,82.5 43.02,81.75 42,81 40.51,79.92 38,80 38,78.34
				V 51 Z
			"
		/>
		<rect
			style="fill: var(--icon-color);"
			width="32"
			height="9"
			x="29"
			y="2"
			ry="4.5"
		/>
		<path
			style="fill: var(--icon-color);"
			d="m 45,-25 c -5.54,0 -11,4.26 -11,9 V 0 h 22 v -16 c 0,-4.74 -5.46,-9 -11,-9 z"
		/>
		`;
    if (color) {
      const checkerboardPattern = makeCheckerboardPattern();
      const defs = document.createElementNS(svgNamespace, "defs");
      defs.appendChild(checkerboardPattern.patternDefElement);
      icon.appendChild(defs);
      const fluidBackground = document.createElementNS(svgNamespace, "path");
      const fluid = document.createElementNS(svgNamespace, "path");
      const fluidPathData = `
				M 35,36 H 55 V 78.678012 83 L 45,87 35,83 Z
			`;
      fluid.setAttribute("d", fluidPathData);
      fluidBackground.setAttribute("d", fluidPathData);
      fluid.style.fill = color.toHexString();
      fluidBackground.style.fill = checkerboardPattern.patternRef;
      mainGroup.appendChild(fluidBackground);
      mainGroup.appendChild(fluid);
    }
    mainGroup.appendChild(pipette);
    icon.appendChild(mainGroup);
    icon.setAttribute("viewBox", "5 -40 140 140");
    return icon;
  }
  makeShapeAutocorrectIcon() {
    const fill = "none";
    const strokeColor = "var(--icon-color)";
    return this.makeIconFromPath(`
			m 79.129476,33.847107 9.967823,-0.03218 v 55 h -55 l 0.03218,-9.96782
			M 71.1,40.8 a 30,30 0 0 1 -30,30 30,30 0 0 1 -30,-30 30,30 0 0 1 30,-30 30,30 0 0 1 30,30 L 71.1,40.8
			M 34.1,58.8 v -25 h 25 v 0
		`, fill, strokeColor, "7px");
  }
  makeStrokeSmoothingIcon() {
    const fill = "none";
    const strokeColor = "var(--icon-color)";
    return this.makeIconFromPath(`
			m 31,83.2 c -50,0 30,-65 -20,-65
			M 75,17.3 40,59.7 38.2,77.6 55.5,72.4 90.5,30 Z
		`, fill, strokeColor, "7px");
  }
  makePressureSensitivityIcon() {
    const icon = document.createElementNS(svgNamespace, "svg");
    icon.setAttribute("viewBox", "4 -10 100 100");
    icon.replaceChildren(...createSvgPaths({
      d: `
					M 39.7,77.7
					C 39.7,77.7 3.4,78.1 4.2,60 4.7,45.2 33.2,30.5 40,25 55.9,12.1 7.4,4.8 7.4,4.8
					c 0,0 40.2,5.5 40.2,15.4
					C 47.6,29.1 21.2,35.1 23.9,60 25,70 39.7,77.7 39.7,77.7
					Z`,
      fill: "var(--icon-color)",
      stroke: "var(--icon-color)",
      "stroke-width": "2px"
    }, {
      d: "M 86.4,15.6 101.4,28.8 65,70 47.5,74.6 50,56.7Z",
      fill: "transparent",
      stroke: "var(--icon-color)",
      "stroke-width": "6px"
    }));
    return icon;
  }
  /** Unused. @deprecated */
  makeFormatSelectionIcon() {
    return this.makeIconFromPath(`
			M 5 10
			L 5 20 L 10 20 L 10 15 L 20 15 L 20 40 L 15 40 L 15 45 L 35 45 L 35 40 L 30 40 L 30 15 L 40 15 L 40 20 L 45 20 L 45 15 L 45 10 L 5 10 z
			M 90 10 C 90 10 86.5 13.8 86 14 C 86 14 76.2 24.8 76 25 L 60 25 L 60 65 C 75 70 85 70 90 65 L 90 25 L 80 25 L 76.7 25 L 90 10 z
			M 60 25 L 55 25 L 50 30 L 60 25 z
			M 10 55 L 10 90 L 41 90 L 41 86 L 45 86 L 45 55 L 10 55 z
			M 42 87 L 42 93 L 48 93 L 48 87 L 42 87 z 
		`);
  }
  makeResizeImageToSelectionIcon() {
    return this.makeIconFromPath(`
			M 75 5 75 10 90 10 90 25 95 25 95 5 75 5 z
			M 15 15 15 30 20 30 20 20 30 20 30 15 15 15 z
			M 84 15 82 17 81 16 81 20 85 20 84 19 86 17 84 15 z
			M 26 24 24 26 26 28 25 29 29 29 29 25 28 26 26 24 z
			M 25 71 26 72 24 74 26 76 28 74 29 75 29 71 25 71 z
			M 15 75 15 85 25 85 25 80 20 80 20 75 15 75 z
			M 90 75 90 90 75 90 75 95 95 95 95 75 90 75 z
			M 81 81 81 85 82 84 84 86 86 84 84 82 85 81 81 81 z
		`);
  }
  /** Renamed to {@link makeResizeImageToSelectionIcon} @deprecated */
  makeResizeViewportIcon() {
    return this.makeResizeImageToSelectionIcon();
  }
  makeDuplicateSelectionIcon() {
    return this.makeIconFromPath(`
			M 45,10 45,55 90,55 90,10 45,10 z
			M 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z 
		`);
  }
  makeCopyIcon() {
    return this.makeIconFromPath(`
			M 45,10 45,55 90,55 90,10 45,10 z
			M 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z 
		`);
  }
  makePasteIcon() {
    const icon = this.makeIconFromPath(`
			M 50 0 L 50 5 L 35 5 L 40 24.75 L 20 25 L 20 100 L 85 100 L 100 90 L 100 24 L 75.1 24.3 L 80 5 L 65 5 L 65 0 L 50 0 z
			M 10 15 L 10 115 L 110 115 L 110 15 L 85 15 L 83 20 L 105 20 L 105 110 L 15 110 L 15 20 L 32 20 L 30 15 L 10 15 z
			M 25 35 L 90 35 L 90 40 L 25 40 L 25 35 z
			M 25 45 L 90 45 L 90 50 L 25 50 L 25 45 z
			M 25 55 L 85 55 L 85 60 L 25 60 L 25 55 z
			M 25 65 L 90 65 L 90 70 L 25 70 L 25 65 z 
		`);
    icon.setAttribute("viewBox", "0 0 120 120");
    return icon;
  }
  makeDeleteSelectionIcon() {
    return __classPrivateFieldGet10(this, _IconProvider_instances, "m", _IconProvider_makeXIcon).call(this);
  }
  makeCloseIcon() {
    return __classPrivateFieldGet10(this, _IconProvider_instances, "m", _IconProvider_makeXIcon).call(this);
  }
  makeSaveIcon() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.innerHTML = `
			<style>
				.toolbar-save-icon {
					stroke: var(--icon-color);
					stroke-width: 6;
					stroke-linejoin: round;
					stroke-linecap: round;
					fill: none;
				}
			</style>
			<path
				d='
					M 15,55 30,70 85,20
				'
				class='toolbar-save-icon'
			/>
		`;
    svg.setAttribute("viewBox", "0 0 100 100");
    return svg;
  }
  makeConfigureDocumentIcon() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.innerHTML = `
			<path
				d='
					M 5,5 V 95 H 95 V 5 Z m 5,5 H 90 V 90 H 10 Z
					m 5,10 V 30 H 50 V 25 H 20 v -5 z
					m 40,0 V 50 H 85 V 20 Z
					m 2,2 H 83 V 39 L 77,28 70,42 64,35 57,45 Z
					m 8.5,5 C 64.67,27 64,27.67 64,28.5 64,29.33 64.67,30 65.5,30 66.33,30 67,29.33 67,28.5 67,27.67 66.33,27 65.5,27 Z
					M 15,40 v 5 h 35 v -5 z
					m 0,15 v 5 h 70 v -5 z
					m 0,15 v 5 h 70 v -5 z
				'
				style='fill: var(--icon-color);'
			/>
		`;
    svg.setAttribute("viewBox", "0 0 100 100");
    return svg;
  }
  makeOverflowIcon() {
    return this.makeIconFromPath(`
			M 15 40
			A 12.5 12.5 0 0 0 2.5 52.5
			A 12.5 12.5 0 0 0 15 65
			A 12.5 12.5 0 0 0 27.5 52.5
			A 12.5 12.5 0 0 0 15 40
			z
	
			M 50 40
			A 12.5 12.5 0 0 0 37.5 52.5
			A 12.5 12.5 0 0 0 50 65
			A 12.5 12.5 0 0 0 62.5 52.5
			A 12.5 12.5 0 0 0 50 40
			z
			
			M 85 40
			A 12.5 12.5 0 0 0 72.5 52.5
			A 12.5 12.5 0 0 0 85 65
			A 12.5 12.5 0 0 0 97.5 52.5
			A 12.5 12.5 0 0 0 85 40
			z
		`);
  }
  makeHelpIcon() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.innerHTML = `
			<circle
				style="stroke-width:1.587; stroke: var(--icon-color);"
				fill="none"
				cx="13.23"
				cy="13.23"
				r="11.9"
			/>
			<path
				style="stroke-width: 3; stroke-linecap: butt; stroke: var(--icon-color);"
				fill="none"
				d="M 9.26,6.61 C 18.7,3.25 19.95,10.4 14.3,13.4 c -1.15,0.61 -1.32,1.32 -1.32,2.65 v 2.12"
			/>
			<circle
				style="fill: var(--icon-color);"
				cx="13"
				cy="21.32"
				r="1.9"
			/>
		`;
    svg.setAttribute("viewBox", "0 0 26.46 26.46");
    svg.setAttribute("width", "100");
    svg.setAttribute("height", "100");
    return svg;
  }
  /**
   * @param pathData - SVG path data (e.g. `m10,10l30,30z`)
   * @param fill - A valid CSS color (e.g. `var(--icon-color)` or `#f0f`). This can be `none`.
   */
  makeIconFromPath(pathData, fill = "var(--icon-color)", strokeColor = "none", strokeWidth = "0px") {
    const icon = document.createElementNS(svgNamespace, "svg");
    const path = document.createElementNS(svgNamespace, "path");
    path.setAttribute("d", pathData);
    path.style.fill = fill;
    path.style.stroke = strokeColor;
    path.style.strokeWidth = strokeWidth;
    icon.appendChild(path);
    icon.setAttribute("viewBox", "0 0 100 100");
    return icon;
  }
  /**
   * @returns An object with both the definition of a checkerboard pattern and the syntax to
   * reference that pattern. The defs provided by this function should be wrapped within a
   * `<defs></defs>` element.
   *
   * **Note**: This function's return value includes both `patternDefElement` (which returns
   * an Element) and a (deprecated) `patternDef` string. Avoid using the `patternDef` result.
   */
  makeCheckerboardPattern() {
    return makeCheckerboardPattern();
  }
  /**
   * @returns true if the given `penStyle` is known to match a rounded tip type of pen.
   */
  isRoundedTipPen(penStyle) {
    return penStyle.factory === makeFreehandLineBuilder || penStyle.factory === makePolylineBuilder;
  }
  isPolylinePen(penStyle) {
    return penStyle.factory === makePolylineBuilder;
  }
  /** Must be overridden by icon packs that need attribution. */
  licenseInfo() {
    return null;
  }
};
_IconProvider_instances = /* @__PURE__ */ new WeakSet(), _IconProvider_makeXIcon = function _IconProvider_makeXIcon2() {
  const strokeWidth = "6px";
  const strokeColor = "var(--icon-color)";
  const fillColor = "none";
  return this.makeIconFromPath(`
			M 15,15 85,85
			M 15,85 85,15
		`, fillColor, strokeColor, strokeWidth);
};
var IconProvider_default = IconProvider;

// node_modules/js-draw/dist/mjs/testing/getUniquePointerId.mjs
var getUniquePointerId = (pointers) => {
  let ptrId = 0;
  const pointerIds = pointers.map((ptr) => ptr.id);
  pointerIds.sort();
  for (const pointerId of pointerIds) {
    if (ptrId === pointerId) {
      ptrId = pointerId + 1;
    }
  }
  return ptrId;
};
var getUniquePointerId_default = getUniquePointerId;

// node_modules/js-draw/dist/mjs/testing/sendPenEvent.mjs
var sendPenEvent = (editor, eventType, point, allPointers, deviceType = PointerDevice.Pen) => {
  const id = getUniquePointerId_default(allPointers ?? []);
  const mainPointer = Pointer.ofCanvasPoint(point, eventType !== InputEvtType.PointerUpEvt, editor.viewport, id, deviceType);
  editor.toolController.dispatchInputEvent({
    kind: eventType,
    allPointers: allPointers ?? [mainPointer],
    current: mainPointer
  });
  return mainPointer;
};
var sendPenEvent_default = sendPenEvent;

// node_modules/js-draw/dist/mjs/toolbar/constants.mjs
var toolbarCSSPrefix = "toolbar-";

// node_modules/js-draw/dist/mjs/toolbar/widgets/layout/DropdownLayoutManager.mjs
var DropdownEventType;
(function(DropdownEventType2) {
  DropdownEventType2[DropdownEventType2["DropdownShown"] = 0] = "DropdownShown";
  DropdownEventType2[DropdownEventType2["DropdownHidden"] = 1] = "DropdownHidden";
})(DropdownEventType || (DropdownEventType = {}));
var Dropdown = class {
  constructor(parent, notifier, onDestroy) {
    this.parent = parent;
    this.notifier = notifier;
    this.onDestroy = onDestroy;
    this.dropdownToggleListener = null;
    this.hideDropdownTimeout = null;
    this.visible = ReactiveValue.fromInitialValue(false);
    this.dropdownContainer = document.createElement("div");
    this.dropdownContainer.classList.add(`${toolbarCSSPrefix}dropdown`);
    this.dropdownContainer.classList.add("hidden");
    parent.target.insertAdjacentElement("afterend", this.dropdownContainer);
    this.dropdownToggleListener = this.notifier.on(DropdownEventType.DropdownShown, (evt) => {
      if (evt.dropdown !== this && // Don't hide if a submenu was shown (it might be a submenu of
      // the current menu).
      evt.fromToplevelDropdown) {
        this.setVisible(false);
      }
    });
  }
  onActivated() {
  }
  repositionDropdown() {
    var _a6, _b2;
    const dropdownBBox = this.dropdownContainer.getBoundingClientRect();
    const screenWidth = ((_a6 = document.scrollingElement) == null ? void 0 : _a6.clientWidth) ?? document.body.clientHeight;
    const screenHeight = ((_b2 = document.scrollingElement) == null ? void 0 : _b2.clientHeight) ?? document.body.clientHeight;
    let translateX = void 0;
    let translateY = void 0;
    if (dropdownBBox.left > screenWidth / 2) {
      const targetElem = this.parent.target;
      translateX = `calc(${targetElem.clientWidth + "px"} - 100%)`;
    }
    if (dropdownBBox.bottom > screenHeight && dropdownBBox.top - dropdownBBox.height > 0) {
      const targetElem = this.parent.target;
      translateY = `calc(-${targetElem.clientHeight}px - 100%)`;
    }
    if (translateX || translateY) {
      this.dropdownContainer.style.translate = `${translateX ?? "0"} ${translateY ?? "0"}`;
    } else {
      this.dropdownContainer.style.translate = "";
    }
  }
  setVisible(visible) {
    const currentlyVisible = this.visible.get();
    if (currentlyVisible === visible) {
      return;
    }
    if (this.hideDropdownTimeout) {
      clearTimeout(this.hideDropdownTimeout);
      this.hideDropdownTimeout = null;
      this.dropdownContainer.classList.remove("hiding");
      this.repositionDropdown();
    }
    const animationDuration = 150;
    this.visible.set(visible);
    if (visible) {
      this.dropdownContainer.classList.remove("hidden");
      this.notifier.dispatch(DropdownEventType.DropdownShown, {
        dropdown: this,
        fromToplevelDropdown: this.parent.isToplevel()
      });
      this.repositionDropdown();
    } else {
      this.notifier.dispatch(DropdownEventType.DropdownHidden, {
        dropdown: this,
        fromToplevelDropdown: this.parent.isToplevel()
      });
      this.dropdownContainer.classList.add("hiding");
      const hideDelay = animationDuration * 0.95;
      this.hideDropdownTimeout = setTimeout(() => {
        this.dropdownContainer.classList.add("hidden");
        this.dropdownContainer.classList.remove("hiding");
        this.repositionDropdown();
      }, hideDelay);
    }
    const animationName = `var(--dropdown-${visible ? "show" : "hide"}-animation)`;
    this.dropdownContainer.style.animation = `${animationDuration}ms ease ${animationName}`;
  }
  requestShow() {
    this.setVisible(true);
  }
  requestHide() {
    this.setVisible(false);
  }
  appendChild(item) {
    this.dropdownContainer.appendChild(item);
  }
  clearChildren() {
    this.dropdownContainer.replaceChildren();
  }
  destroy() {
    var _a6;
    this.setVisible(false);
    this.dropdownContainer.remove();
    (_a6 = this.dropdownToggleListener) == null ? void 0 : _a6.remove();
    this.clearChildren();
    this.onDestroy();
  }
};
var DropdownLayoutManager = class {
  constructor(announceForAccessibility, localization4) {
    this.localization = localization4;
    this.dropdowns = /* @__PURE__ */ new Set();
    this.listeners = [];
    this.connectedNotifiers = [];
    this.notifier = new EventDispatcher();
    this.notifier.on(DropdownEventType.DropdownShown, ({ dropdown, fromToplevelDropdown }) => {
      if (!dropdown)
        return;
      announceForAccessibility(this.localization.dropdownShown(dropdown.parent.getTitle()));
      this.connectedNotifiers.forEach((notifier) => {
        notifier.dispatch(EditorEventType.ToolbarDropdownShown, {
          kind: EditorEventType.ToolbarDropdownShown,
          fromToplevelDropdown,
          layoutManager: this
        });
      });
    });
    this.notifier.on(DropdownEventType.DropdownHidden, ({ dropdown }) => {
      if (!dropdown)
        return;
      announceForAccessibility(this.localization.dropdownHidden(dropdown.parent.getTitle()));
    });
  }
  connectToEditorNotifier(notifier) {
    this.connectedNotifiers.push(notifier);
    this.refreshListeners();
  }
  /** Creates a dropdown within `parent`. */
  createToolMenu(parent) {
    const dropdown = new Dropdown(parent, this.notifier, () => {
      this.dropdowns.delete(dropdown);
      this.refreshListeners();
    });
    this.dropdowns.add(dropdown);
    this.refreshListeners();
    return dropdown;
  }
  /**
   * Adds/removes listeners based on whether we have any managed dropdowns.
   *
   * We attempt to clean up all resources when `dropdowns.size == 0`, at which
   * point, an instance of this could be safely garbage collected.
   */
  refreshListeners() {
    const clearListeners = () => {
      this.listeners.forEach((l) => l.remove());
      this.listeners = [];
    };
    if (this.dropdowns.size === 0) {
      clearListeners();
    } else if (this.listeners.length !== this.connectedNotifiers.length) {
      clearListeners();
      this.listeners = this.connectedNotifiers.map((notifier) => {
        return notifier.on(EditorEventType.ToolbarDropdownShown, (evt) => {
          if (evt.kind !== EditorEventType.ToolbarDropdownShown || // Don't forward to ourselves events that we originally triggered.
          evt.layoutManager === this) {
            return;
          }
          this.notifier.dispatch(DropdownEventType.DropdownShown, {
            fromToplevelDropdown: evt.fromToplevelDropdown
          });
        });
      });
    }
  }
};

// node_modules/js-draw/dist/mjs/util/listenForLongPressOrHover.mjs
var listenForLongPressOrHover = (target, options) => {
  const pointersInside = /* @__PURE__ */ new Map();
  let timeoutId = null;
  let isLongPressInProgress = false;
  const updateTimeout = () => {
    if (pointersInside.size === 0) {
      if (isLongPressInProgress) {
        isLongPressInProgress = false;
        options.onEnd();
      } else if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    } else {
      const nowTime = Date.now();
      let timeSinceFirstPointer = 0;
      for (const record of pointersInside.values()) {
        const timeSince = nowTime - record.timeEnter;
        timeSinceFirstPointer = Math.max(timeSince, timeSinceFirstPointer);
      }
      const longPressTimeout = options.longPressTimeout ?? 700;
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      const timeLeft = longPressTimeout - timeSinceFirstPointer;
      if (timeLeft <= 0) {
        options.onStart();
        isLongPressInProgress = true;
      } else {
        timeoutId = setTimeout(() => {
          timeoutId = null;
          updateTimeout();
        }, timeLeft);
      }
    }
  };
  const pointerEventListener = (event) => {
    const eventRecord = {
      timeEnter: Date.now()
    };
    if (event.type === "pointerenter") {
      pointersInside.set(event.pointerId, eventRecord);
    } else if (event.type === "pointerleave" || event.type === "pointercancel") {
      pointersInside.clear();
    }
    updateTimeout();
  };
  target.addEventListener("pointerenter", pointerEventListener);
  target.addEventListener("pointerleave", pointerEventListener);
  target.addEventListener("pointercancel", pointerEventListener);
  return {
    removeListeners: () => {
      target.removeEventListener("pointerenter", pointerEventListener);
      target.removeEventListener("pointerleave", pointerEventListener);
      target.removeEventListener("pointercancel", pointerEventListener);
    }
  };
};
var listenForLongPressOrHover_default = listenForLongPressOrHover;

// node_modules/js-draw/dist/mjs/util/addLongPressOrHoverCssClasses.mjs
var addLongPressOrHoverCssClasses = (element, options) => {
  const hasLongPressClass = "has-long-press-or-hover";
  const noLongPressClass = "no-long-press-or-hover";
  element.classList.add("no-long-press-or-hover");
  const { removeListeners } = listenForLongPressOrHover_default(element, {
    onStart() {
      element.classList.remove(noLongPressClass);
      element.classList.add(hasLongPressClass);
    },
    onEnd() {
      element.classList.add(noLongPressClass);
      element.classList.remove(hasLongPressClass);
    },
    longPressTimeout: options == null ? void 0 : options.timeout
  });
  return {
    removeEventListeners: () => {
      element.classList.remove(noLongPressClass);
      removeListeners();
    }
  };
};
var addLongPressOrHoverCssClasses_default = addLongPressOrHoverCssClasses;

// node_modules/js-draw/dist/mjs/toolbar/utils/makeDraggable.mjs
var makeDraggable = (dragElement, options) => {
  const dragElements = [...options.draggableChildElements, dragElement];
  let lastX = 0;
  let lastY = 0;
  let startX = 0;
  let startY = 0;
  let pointerDown = false;
  let capturedPointerId = null;
  const isDraggableElement = (element) => {
    if (!element) {
      return false;
    }
    if (dragElements.includes(element)) {
      return true;
    }
    const undraggableElementTypes = ["INPUT", "SELECT", "IMG"];
    let hasSuitableAncestors = false;
    let ancestor = element.parentElement;
    while (ancestor) {
      if (undraggableElementTypes.includes(ancestor.tagName)) {
        break;
      }
      if (dragElements.includes(ancestor)) {
        hasSuitableAncestors = true;
        break;
      }
      ancestor = ancestor.parentElement;
    }
    return !undraggableElementTypes.includes(element.tagName) && hasSuitableAncestors;
  };
  const removeEventListenerCallbacks = [];
  const addEventListener2 = (listenerType, listener, options2) => {
    dragElement.addEventListener(listenerType, listener, options2);
    removeEventListenerCallbacks.push(() => {
      dragElement.removeEventListener(listenerType, listener);
    });
  };
  const clickThreshold = 5;
  const isRoughlyClick = () => {
    return Math.hypot(lastX - startX, lastY - startY) < clickThreshold;
  };
  let startedDragging = false;
  addEventListener2("pointerdown", (event) => {
    if (event.defaultPrevented || !isDraggableElement(event.target)) {
      return;
    }
    if (event.isPrimary) {
      startedDragging = false;
      lastX = event.clientX;
      lastY = event.clientY;
      startX = event.clientX;
      startY = event.clientY;
      capturedPointerId = null;
      pointerDown = true;
    }
  }, { passive: true });
  const onGestureEnd = (_event) => {
    if (!pointerDown) {
      return;
    }
    if (capturedPointerId !== null) {
      dragElement.releasePointerCapture(capturedPointerId);
      capturedPointerId = null;
    }
    options.onDragEnd({
      roughlyClick: isRoughlyClick(),
      endTimestamp: performance.now(),
      displacement: Vec2.of(lastX - startX, lastY - startY)
    });
    pointerDown = false;
    startedDragging = false;
  };
  addEventListener2("pointermove", (event) => {
    if (!event.isPrimary || !pointerDown) {
      return void 0;
    }
    if (event.pointerType === "mouse" && event.buttons === 0) {
      onGestureEnd(event);
      return void 0;
    }
    if (capturedPointerId === null && !isRoughlyClick()) {
      dragElement.setPointerCapture(event.pointerId);
      capturedPointerId = event.pointerId;
    }
    const x = event.clientX;
    const y = event.clientY;
    const dx = x - lastX;
    const dy = y - lastY;
    const isClick = Math.abs(x - startX) <= clickThreshold && Math.abs(y - startY) <= clickThreshold;
    if (!isClick || startedDragging) {
      options.onDrag(dx, dy, Vec2.of(x - startX, y - startY));
      lastX = x;
      lastY = y;
      startedDragging = true;
    }
  });
  addEventListener2("pointerleave", (event) => {
    if (capturedPointerId === null && pointerDown && event.isPrimary) {
      dragElement.setPointerCapture(event.pointerId);
      capturedPointerId = event.pointerId;
    }
  });
  addEventListener2("pointerup", onGestureEnd);
  addEventListener2("pointercancel", onGestureEnd);
  return {
    removeListeners: () => {
      for (const removeListenerCallback of removeEventListenerCallbacks) {
        removeListenerCallback();
      }
    }
  };
};
var makeDraggable_default = makeDraggable;

// node_modules/js-draw/dist/mjs/util/cloneElementWithStyles.mjs
var cloneElementWithStyles = (element) => {
  const restyle = (originalElement, clonedElement) => {
    var _a6;
    const originalComputedStyle = getComputedStyle(originalElement);
    for (let index = 0; index < originalComputedStyle.length; index++) {
      const propertyName = originalComputedStyle.item(index);
      const propertyValue = originalComputedStyle.getPropertyValue(propertyName);
      (_a6 = clonedElement.style) == null ? void 0 : _a6.setProperty(propertyName, propertyValue);
    }
    for (let i = 0; i < originalElement.children.length; i++) {
      const originalChild = originalElement.children.item(i);
      const clonedChild = clonedElement.children.item(i);
      if (originalChild && clonedChild) {
        restyle(originalChild, clonedChild);
      } else {
        console.warn("CloneElement: Missing child");
      }
    }
  };
  const elementClone = element.cloneNode(true);
  restyle(element, elementClone);
  return elementClone;
};
var cloneElementWithStyles_default = cloneElementWithStyles;

// node_modules/js-draw/dist/mjs/toolbar/utils/HelpDisplay.mjs
var __classPrivateFieldGet11 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HelpDisplay_helpData;
var createHelpPage = (helpItems, onItemClick, onBackgroundClick, context) => {
  const container = document.createElement("div");
  container.classList.add("help-page-container");
  const textLabel = document.createElement("div");
  textLabel.classList.add("label", "-space-above");
  textLabel.setAttribute("aria-live", "polite");
  let currentItemIndex = 0;
  let currentItem = helpItems[0] ?? null;
  let clonedElementContainers = [];
  container.addEventListener("click", (event) => {
    if (event.target === container) {
      onBackgroundClick();
    }
  });
  const getCombinedBBox = () => {
    if (!currentItem) {
      return Rect2.empty;
    }
    const itemBoundingBoxes = currentItem.targetElements.map((element) => Rect2.of(element.getBoundingClientRect()));
    return Rect2.union(...itemBoundingBoxes);
  };
  const updateClonedElementStates = () => {
    const currentItemBBox = getCombinedBBox();
    for (let index = 0; index < clonedElementContainers.length; index++) {
      for (const { container: container2, bbox: containerBBox } of clonedElementContainers[index]) {
        if (index === currentItemIndex) {
          container2.classList.add("-active");
          container2.classList.remove("-clickable", "-background");
          container2.onclick = () => {
          };
        } else {
          if (!containerBBox.containsRect(currentItemBBox)) {
            container2.classList.add("-clickable");
            container2.classList.remove("-active", "-background");
          } else {
            container2.classList.add("-background");
            container2.classList.remove("-active", "-clickable");
          }
          const containerIndex = index;
          container2.onclick = () => {
            onItemClick(containerIndex);
          };
        }
      }
    }
  };
  const updateLabelPosition = () => {
    const labelBBox = Rect2.of(textLabel.getBoundingClientRect());
    const combinedBBox = getCombinedBBox();
    if (labelBBox.intersects(combinedBBox)) {
      const containerBBox = Rect2.of(container.getBoundingClientRect());
      const spaceAboveCombined = combinedBBox.topLeft.y;
      const spaceBelowCombined = containerBBox.bottomLeft.y - combinedBBox.bottomLeft.y;
      if (spaceAboveCombined > spaceBelowCombined && spaceAboveCombined > labelBBox.height / 3) {
        textLabel.classList.remove("-small-space-above", "-large-space-above");
        textLabel.classList.add("-large-space-below");
      }
      if (spaceAboveCombined < spaceBelowCombined && spaceBelowCombined > labelBBox.height) {
        textLabel.classList.add("-large-space-above");
        textLabel.classList.remove("-large-space-below");
      }
    }
  };
  const refreshContent = () => {
    container.replaceChildren();
    textLabel.classList.remove("-large-space-above");
    textLabel.classList.add("-small-space-above", "-large-space-below");
    container.appendChild(textLabel);
    const screenBBox = new Rect2(0, 0, window.innerWidth, window.innerHeight);
    clonedElementContainers = [];
    for (let itemIndex = 0; itemIndex < helpItems.length; itemIndex++) {
      const item = helpItems[itemIndex];
      const itemCloneContainers = [];
      for (const targetElement of item.targetElements) {
        let targetBBox = Rect2.of(targetElement.getBoundingClientRect());
        if (!screenBBox.intersects(targetBBox)) {
          const screenBottomCenter = screenBBox.bottomLeft.lerp(screenBBox.bottomRight, 0.5);
          const targetBottomCenter = targetBBox.bottomLeft.lerp(targetBBox.bottomRight, 0.5);
          const delta = screenBottomCenter.minus(targetBottomCenter);
          targetBBox = targetBBox.translatedBy(delta);
        }
        const clonedElement = cloneElementWithStyles_default(targetElement);
        for (const input of clonedElement.querySelectorAll("input")) {
          input.disabled = true;
        }
        clonedElement.style.margin = "0";
        const clonedElementContainer = document.createElement("div");
        clonedElementContainer.classList.add("cloned-element-container");
        clonedElementContainer.role = "group";
        clonedElementContainer.ariaLabel = context.localization.helpControlsAccessibilityLabel;
        clonedElementContainer.style.position = "absolute";
        clonedElementContainer.style.left = `${targetBBox.topLeft.x}px`;
        clonedElementContainer.style.top = `${targetBBox.topLeft.y}px`;
        clonedElementContainer.replaceChildren(clonedElement);
        addLongPressOrHoverCssClasses_default(clonedElementContainer, { timeout: 0 });
        itemCloneContainers.push({ container: clonedElementContainer, bbox: targetBBox });
        container.appendChild(clonedElementContainer);
      }
      clonedElementContainers.push(itemCloneContainers);
    }
    updateClonedElementStates();
  };
  const refresh = () => {
    refreshContent();
    updateLabelPosition();
  };
  const onItemChange = () => {
    const helpTextElement = document.createElement("div");
    helpTextElement.textContent = (currentItem == null ? void 0 : currentItem.helpText) ?? "";
    helpTextElement.classList.add("current-item-help");
    const navigationHelpElement = document.createElement("div");
    navigationHelpElement.textContent = context.localization.helpScreenNavigationHelp;
    navigationHelpElement.classList.add("navigation-help");
    textLabel.replaceChildren(helpTextElement, ...currentItemIndex === 0 ? [navigationHelpElement] : []);
    updateClonedElementStates();
  };
  onItemChange();
  return {
    addToParent: (parent) => {
      refreshContent();
      parent.appendChild(container);
      updateLabelPosition();
    },
    refresh,
    setPageIndex: (pageIndex) => {
      currentItemIndex = pageIndex;
      currentItem = helpItems[pageIndex];
      onItemChange();
    }
  };
};
var HelpDisplay = class {
  /** Constructed internally by BaseWidget. @internal */
  constructor(createOverlay, context) {
    this.createOverlay = createOverlay;
    this.context = context;
    _HelpDisplay_helpData.set(this, []);
  }
  /** @internal */
  showHelpOverlay() {
    var _a6;
    const overlay = document.createElement("dialog");
    overlay.setAttribute("autofocus", "true");
    overlay.classList.add("toolbar-help-overlay");
    const closing = false;
    const closeOverlay = () => {
      if (closing)
        return;
      const animationDelay = 250;
      overlay.classList.add("-hiding");
      setTimeout(() => overlay.close(), animationDelay);
    };
    let lastDragTimestamp = 0;
    const onBackgroundClick = () => {
      const wasJustDragging = performance.now() - lastDragTimestamp < 100;
      if (!wasJustDragging) {
        closeOverlay();
      }
    };
    const makeCloseButton = () => {
      const closeButton = document.createElement("button");
      closeButton.classList.add("close-button");
      closeButton.appendChild(this.context.icons.makeCloseIcon());
      const label = this.context.localization.close;
      closeButton.setAttribute("aria-label", label);
      closeButton.setAttribute("title", label);
      closeButton.onclick = () => {
        closeOverlay();
      };
      return closeButton;
    };
    const makeNavigationContent = () => {
      const currentPage = MutableReactiveValue.fromInitialValue(0);
      const content = document.createElement("div");
      content.classList.add("navigation-content");
      const helpPage = createHelpPage(__classPrivateFieldGet11(this, _HelpDisplay_helpData, "f"), (newPageIndex) => currentPage.set(newPageIndex), onBackgroundClick, this.context);
      helpPage.addToParent(content);
      const showPage = (pageIndex) => {
        if (pageIndex >= __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").length || pageIndex < 0) {
          console.warn("Help screen: Navigated to out-of-bounds page", pageIndex);
          content.style.display = "none";
        } else {
          content.style.display = "";
          helpPage.setPageIndex(pageIndex);
        }
      };
      currentPage.onUpdateAndNow(showPage);
      const navigationControl = {
        content,
        currentPage,
        toNext: () => {
          if (navigationControl.hasNext()) {
            currentPage.set(currentPage.get() + 1);
          }
        },
        toPrevious: () => {
          if (navigationControl.hasPrevious()) {
            currentPage.set(currentPage.get() - 1);
          }
        },
        hasNext: () => {
          return currentPage.get() + 1 < __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").length;
        },
        hasPrevious: () => {
          return currentPage.get() > 0;
        },
        refreshCurrent: () => {
          helpPage.refresh();
        }
      };
      return navigationControl;
    };
    const makeNavigationButtons = (navigation2) => {
      const navigationButtonContainer = document.createElement("div");
      navigationButtonContainer.classList.add("navigation-buttons");
      const nextButton = document.createElement("button");
      const previousButton = document.createElement("button");
      nextButton.textContent = this.context.localization.next;
      previousButton.textContent = this.context.localization.previous;
      nextButton.classList.add("next");
      previousButton.classList.add("previous");
      const updateButtonVisibility = () => {
        navigationButtonContainer.classList.remove("-has-next", "-has-previous");
        if (navigation2.hasNext()) {
          navigationButtonContainer.classList.add("-has-next");
          nextButton.disabled = false;
        } else {
          navigationButtonContainer.classList.remove("-has-next");
          nextButton.disabled = true;
        }
        if (navigation2.hasPrevious()) {
          navigationButtonContainer.classList.add("-has-previous");
          previousButton.disabled = false;
        } else {
          navigationButtonContainer.classList.remove("-has-previous");
          previousButton.disabled = true;
        }
      };
      navigation2.currentPage.onUpdateAndNow(updateButtonVisibility);
      nextButton.onclick = () => {
        navigation2.toNext();
      };
      previousButton.onclick = () => {
        navigation2.toPrevious();
      };
      navigationButtonContainer.replaceChildren(previousButton, nextButton);
      return navigationButtonContainer;
    };
    const navigation = makeNavigationContent();
    const navigationButtons = makeNavigationButtons(navigation);
    overlay.replaceChildren(makeCloseButton(), navigationButtons, navigation.content);
    this.createOverlay(overlay);
    overlay.showModal();
    const minDragOffsetToTransition = 30;
    const setDragOffset = (offset) => {
      if (offset > 0 && !navigation.hasPrevious()) {
        offset = 0;
      }
      if (offset < 0 && !navigation.hasNext()) {
        offset = 0;
      }
      if (offset > minDragOffsetToTransition || offset < -minDragOffsetToTransition) {
        offset = minDragOffsetToTransition * Math.sign(offset);
      }
      overlay.style.transform = `translate(${offset}px, 0px)`;
      if (offset >= minDragOffsetToTransition) {
        navigationButtons.classList.add("-highlight-previous");
      } else {
        navigationButtons.classList.remove("-highlight-previous");
      }
      if (offset <= -minDragOffsetToTransition) {
        navigationButtons.classList.add("-highlight-next");
      } else {
        navigationButtons.classList.remove("-highlight-next");
      }
    };
    const dragListener = makeDraggable_default(overlay, {
      draggableChildElements: [navigation.content],
      onDrag: (_deltaX, _deltaY, totalDisplacement) => {
        overlay.classList.add("-dragging");
        setDragOffset(totalDisplacement.x);
      },
      onDragEnd: (dragStatistics) => {
        overlay.classList.remove("-dragging");
        setDragOffset(0);
        if (!dragStatistics.roughlyClick) {
          const xDisplacement = dragStatistics.displacement.x;
          if (xDisplacement > minDragOffsetToTransition) {
            navigation.toPrevious();
          } else if (xDisplacement < -minDragOffsetToTransition) {
            navigation.toNext();
          }
          lastDragTimestamp = dragStatistics.endTimestamp;
        }
      }
    });
    let resizeObserver;
    if (window.ResizeObserver) {
      resizeObserver = new ResizeObserver(() => {
        navigation.refreshCurrent();
      });
      resizeObserver.observe(overlay);
    }
    const onMediaChangeListener = () => {
      requestAnimationFrame(() => navigation.refreshCurrent());
    };
    const mediaQueryList = (_a6 = window.matchMedia) == null ? void 0 : _a6.call(window, "(prefers-color-scheme: dark)");
    mediaQueryList == null ? void 0 : mediaQueryList.addEventListener("change", onMediaChangeListener);
    const closeOverlayTriggers = [navigation.content, navigationButtons, overlay];
    overlay.onclick = (event) => {
      if (closeOverlayTriggers.includes(event.target)) {
        onBackgroundClick();
      }
    };
    overlay.onkeyup = (event) => {
      if (event.code === "Escape") {
        closeOverlay();
        event.preventDefault();
      } else if (event.code === "ArrowRight") {
        navigation.toNext();
        event.preventDefault();
      } else if (event.code === "ArrowLeft") {
        navigation.toPrevious();
        event.preventDefault();
      }
    };
    overlay.addEventListener("close", () => {
      this.context.announceForAccessibility(this.context.localization.helpHidden);
      mediaQueryList == null ? void 0 : mediaQueryList.removeEventListener("change", onMediaChangeListener);
      dragListener.removeListeners();
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      overlay.remove();
    });
  }
  /** Marks `helpText` as associated with a single `targetElement`. */
  registerTextHelpForElement(targetElement, helpText) {
    this.registerTextHelpForElements([targetElement], helpText);
  }
  /** Marks `helpText` as associated with all elements in `targetElements`. */
  registerTextHelpForElements(targetElements, helpText) {
    __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").push({ targetElements: [...targetElements], helpText });
  }
  /** Returns true if any help text has been registered. */
  hasHelpText() {
    return __classPrivateFieldGet11(this, _HelpDisplay_helpData, "f").length > 0;
  }
  /**
   * Creates and returns a button that toggles the help display.
   */
  createToggleButton() {
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("toolbar-help-overlay-button");
    const helpButton = document.createElement("button");
    helpButton.classList.add("button");
    const icon = this.context.icons.makeHelpIcon();
    icon.classList.add("icon");
    helpButton.appendChild(icon);
    helpButton.setAttribute("aria-label", this.context.localization.help);
    helpButton.onclick = () => {
      this.showHelpOverlay();
    };
    buttonContainer.appendChild(helpButton);
    return buttonContainer;
  }
};
_HelpDisplay_helpData = /* @__PURE__ */ new WeakMap();
var HelpDisplay_default = HelpDisplay;

// node_modules/js-draw/dist/mjs/toolbar/widgets/BaseWidget.mjs
var __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet12 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseWidget_instances;
var _a5;
var _BaseWidget_hasDropdown;
var _BaseWidget_disabledDueToReadOnlyEditor;
var _BaseWidget_tags;
var _BaseWidget_removeEditorListeners;
var _BaseWidget_addEditorListeners;
var ToolbarWidgetTag;
(function(ToolbarWidgetTag2) {
  ToolbarWidgetTag2["Save"] = "save";
  ToolbarWidgetTag2["Exit"] = "exit";
  ToolbarWidgetTag2["Undo"] = "undo";
  ToolbarWidgetTag2["Redo"] = "redo";
})(ToolbarWidgetTag || (ToolbarWidgetTag = {}));
var BaseWidget = class {
  constructor(editor, id, localizationTable) {
    _BaseWidget_instances.add(this);
    this.editor = editor;
    this.id = id;
    this.dropdown = null;
    _BaseWidget_hasDropdown.set(this, void 0);
    this.disabled = false;
    _BaseWidget_disabledDueToReadOnlyEditor.set(this, false);
    _BaseWidget_tags.set(this, []);
    this.subWidgets = {};
    this.toplevel = true;
    _BaseWidget_removeEditorListeners.set(this, null);
    this.localizationTable = localizationTable ?? editor.localization;
    const defaultLayoutManager = new DropdownLayoutManager((text) => this.editor.announceForAccessibility(text), this.localizationTable);
    defaultLayoutManager.connectToEditorNotifier(editor.notifier);
    this.layoutManager = defaultLayoutManager;
    this.icon = null;
    this.container = document.createElement("div");
    this.container.classList.add(`${toolbarCSSPrefix}toolContainer`, `${toolbarCSSPrefix}toolButtonContainer`, `${toolbarCSSPrefix}internalWidgetId--${id.replace(/[^a-zA-Z0-9_]/g, "-")}`);
    this.dropdownContent = document.createElement("div");
    __classPrivateFieldSet10(this, _BaseWidget_hasDropdown, false, "f");
    this.button = document.createElement("div");
    this.button.classList.add(`${toolbarCSSPrefix}button`);
    this.label = document.createElement("label");
    this.button.setAttribute("role", "button");
    this.button.tabIndex = 0;
    this.button.oncontextmenu = (event) => {
      event.preventDefault();
    };
    addLongPressOrHoverCssClasses_default(this.button);
  }
  /**
   * Should return a constant true or false value. If true (the default),
   * this widget must be automatically disabled when its editor is read-only.
   */
  shouldAutoDisableInReadOnlyEditor() {
    return true;
  }
  getId() {
    return this.id;
  }
  /**
   * Note: Tags should be set *before* a tool widget is added to a toolbar.
   *
   *
   * Associates tags with this widget that can be used by toolbar themes
   * to customize the layout/appearance of this button. Prefer tags in
   * the `ToolbarWidgetTag` enum, where possible.
   *
   * In addition to being readable from the {@link getTags} method, tags are
   * added to a button's main container as CSS classes with the `toolwidget-tag--` prefix.
   *
   * For example, the `undo` tag would result in `toolwidget-tag--undo`
   * being added to the button's container's class list.
   *
   */
  setTags(tags) {
    const toClassName = (tag) => {
      return `toolwidget-tag--${tag}`;
    };
    for (const tag of __classPrivateFieldGet12(this, _BaseWidget_tags, "f")) {
      this.container.classList.remove(toClassName(tag));
    }
    __classPrivateFieldSet10(this, _BaseWidget_tags, [...tags], "f");
    for (const tag of __classPrivateFieldGet12(this, _BaseWidget_tags, "f")) {
      this.container.classList.add(toClassName(tag));
    }
  }
  getTags() {
    return [...__classPrivateFieldGet12(this, _BaseWidget_tags, "f")];
  }
  /**
   * Returns the ID of this widget in `container`. Adds a suffix to this' ID
   * if an item in `container` already has this' ID.
   *
   * For example, if `this` has ID `foo` and if
   * `container = { 'foo': somethingNotThis, 'foo-1': somethingElseNotThis }`, this method
   * returns `foo-2` because elements with IDs `foo` and `foo-1` are already present in
   * `container`.
   *
   * If `this` is already in `container`, returns the id given to `this` in the container.
   */
  getUniqueIdIn(container) {
    let id = this.getId();
    let idCounter5 = 0;
    while (id in container && container[id] !== this) {
      id = this.getId() + "-" + idCounter5.toString();
      idCounter5++;
    }
    return id;
  }
  // Add content to the widget's associated dropdown menu.
  // Returns true if such a menu should be created, false otherwise.
  fillDropdown(dropdown, helpDisplay) {
    if (Object.keys(this.subWidgets).length === 0) {
      return false;
    }
    for (const widgetId in this.subWidgets) {
      const widget = this.subWidgets[widgetId];
      const widgetElement = widget.addTo(dropdown);
      widget.setIsToplevel(false);
      const helpText = widget.getHelpText();
      if (helpText) {
        helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(widgetElement, helpText);
      }
    }
    return true;
  }
  /**
   * Should return a 1-2 sentence description of the widget.
   *
   * At present, this is only used if this widget has an associated dropdown.
   */
  getHelpText() {
    return void 0;
  }
  /** @deprecated Renamed to `setUpButtonEventListeners`. */
  setupActionBtnClickListener(button) {
    return this.setUpButtonEventListeners(button);
  }
  setUpButtonEventListeners(button) {
    const clickTriggers = { Enter: true, " ": true };
    button.onkeydown = (evt) => {
      let handled = false;
      if (evt.key in clickTriggers) {
        if (!this.disabled) {
          this.handleClick();
          handled = true;
        }
      }
      if (!handled) {
        const editorEvent = keyPressEventFromHTMLEvent(evt);
        handled = this.editor.toolController.dispatchInputEvent(editorEvent);
      }
      if (handled) {
        evt.preventDefault();
      }
    };
    button.onkeyup = (htmlEvent) => {
      if (htmlEvent.key in clickTriggers) {
        return;
      }
      const event = keyUpEventFromHTMLEvent(htmlEvent);
      const handled = this.editor.toolController.dispatchInputEvent(event);
      if (handled) {
        htmlEvent.preventDefault();
      }
    };
    button.onclick = () => {
      if (!this.disabled) {
        this.handleClick();
      }
    };
    button.ondblclick = (event) => {
      event.preventDefault();
    };
  }
  // Add a listener that is triggered when a key is pressed.
  // Listeners will fire regardless of whether this widget is selected and require that
  // {@link Editor.toolController} to have an enabled {@link ToolbarShortcutHandler} tool.
  onKeyPress(_event) {
    return false;
  }
  get hasDropdown() {
    return __classPrivateFieldGet12(this, _BaseWidget_hasDropdown, "f");
  }
  // Add a widget to this' dropdown. Must be called before this.addTo.
  addSubWidget(widget) {
    const id = widget.getUniqueIdIn(this.subWidgets);
    this.subWidgets[id] = widget;
  }
  setLayoutManager(manager) {
    if (manager === this.layoutManager) {
      return;
    }
    this.layoutManager = manager;
    if (this.container.parentElement) {
      this.addTo(this.container.parentElement);
    }
  }
  /**
   * Adds this to `parent`.
   * Returns the element that was just added to `parent`.
   * @internal
   */
  addTo(parent) {
    var _a6;
    this.icon = null;
    this.updateIcon();
    this.label.innerText = this.getTitle();
    const longLabelCSSClass = "long-label";
    if (this.label.innerText.length > 7) {
      this.label.classList.add(longLabelCSSClass);
    } else {
      this.label.classList.remove(longLabelCSSClass);
    }
    this.setUpButtonEventListeners(this.button);
    this.container.replaceChildren();
    this.button.replaceChildren(this.icon, this.label);
    this.container.appendChild(this.button);
    const helpDisplay = new HelpDisplay_default((content) => this.editor.createHTMLOverlay(content), this.editor);
    const helpText = this.getHelpText();
    if (helpText) {
      helpDisplay.registerTextHelpForElement(this.dropdownContent, [this.getTitle(), helpText].join("\n\n"));
    }
    this.dropdownContent.replaceChildren();
    __classPrivateFieldSet10(this, _BaseWidget_hasDropdown, this.fillDropdown(this.dropdownContent, helpDisplay), "f");
    if (__classPrivateFieldGet12(this, _BaseWidget_hasDropdown, "f")) {
      this.button.classList.add("has-dropdown");
      (_a6 = this.dropdown) == null ? void 0 : _a6.destroy();
      this.dropdownIcon = this.createDropdownIcon();
      this.button.appendChild(this.dropdownIcon);
      this.dropdown = this.layoutManager.createToolMenu({
        target: this.button,
        getTitle: () => this.getTitle(),
        isToplevel: () => this.toplevel
      });
      this.dropdown.visible.onUpdate((visible) => {
        if (visible) {
          this.container.classList.add("dropdownVisible");
        } else {
          this.container.classList.remove("dropdownVisible");
        }
        if (!visible) {
          this.focus();
        }
      });
      if (helpDisplay.hasHelpText()) {
        this.dropdown.appendChild(helpDisplay.createToggleButton());
      }
      this.dropdown.appendChild(this.dropdownContent);
    }
    this.setDropdownVisible(false);
    if (this.container.parentElement) {
      this.container.remove();
    }
    __classPrivateFieldGet12(this, _BaseWidget_instances, "m", _BaseWidget_addEditorListeners).call(this);
    parent.appendChild(this.container);
    return this.container;
  }
  /**
   * Remove this. This allows the widget to be added to a toolbar again
   * in the future using `addTo`.
   */
  remove() {
    var _a6;
    this.container.remove();
    (_a6 = __classPrivateFieldGet12(this, _BaseWidget_removeEditorListeners, "f")) == null ? void 0 : _a6.call(this);
  }
  focus() {
    this.button.focus();
  }
  /**
   * @internal
   */
  addCSSClassToContainer(className) {
    this.container.classList.add(className);
  }
  removeCSSClassFromContainer(className) {
    this.container.classList.remove(className);
  }
  updateIcon() {
    var _a6;
    let newIcon = this.createIcon();
    if (!newIcon) {
      newIcon = document.createElement("div");
      this.container.classList.add("no-icon");
    } else {
      this.container.classList.remove("no-icon");
    }
    (_a6 = this.icon) == null ? void 0 : _a6.replaceWith(newIcon);
    this.icon = newIcon;
    this.icon.classList.add(`${toolbarCSSPrefix}icon`);
  }
  setDisabled(disabled) {
    this.disabled = disabled;
    __classPrivateFieldSet10(this, _BaseWidget_disabledDueToReadOnlyEditor, false, "f");
    if (this.disabled) {
      this.button.classList.add("disabled");
      this.button.setAttribute("aria-disabled", "true");
    } else {
      this.button.classList.remove("disabled");
      this.button.removeAttribute("aria-disabled");
    }
  }
  setSelected(selected) {
    const currentlySelected = this.isSelected();
    if (currentlySelected === selected) {
      return;
    }
    this.button.setAttribute("role", "switch");
    if (selected) {
      this.container.classList.add("selected");
      this.button.setAttribute("aria-checked", "true");
    } else {
      this.container.classList.remove("selected");
      this.button.setAttribute("aria-checked", "false");
    }
  }
  setDropdownVisible(visible) {
    var _a6, _b2;
    if (visible) {
      (_a6 = this.dropdown) == null ? void 0 : _a6.requestShow();
    } else {
      (_b2 = this.dropdown) == null ? void 0 : _b2.requestHide();
    }
  }
  /**
   * Only used by some layout managers.
   * In those layout managers, makes this dropdown visible.
   */
  activateDropdown() {
    var _a6;
    (_a6 = this.dropdown) == null ? void 0 : _a6.onActivated();
  }
  /**
   * Returns `true` if this widget must always be in a toplevel menu and not
   * in a scrolling/overflow menu.
   *
   * This method can be overidden to override the default of `true`.
   */
  mustBeInToplevelMenu() {
    return false;
  }
  /**
   * Returns true iff this widget can be in a nontoplevel menu.
   *
   * @deprecated Use `!mustBeInToplevelMenu()` instead.
   */
  canBeInOverflowMenu() {
    return !this.mustBeInToplevelMenu();
  }
  getButtonWidth() {
    return this.button.clientWidth;
  }
  isHidden() {
    return this.container.style.display === "none";
  }
  setHidden(hidden) {
    this.container.style.display = hidden ? "none" : "";
  }
  /** Set whether the widget is contained within another. @internal */
  setIsToplevel(toplevel) {
    this.toplevel = toplevel;
  }
  /** Returns true if the menu for this widget is open. */
  isDropdownVisible() {
    var _a6, _b2;
    return ((_b2 = (_a6 = this.dropdown) == null ? void 0 : _a6.visible) == null ? void 0 : _b2.get()) ?? false;
  }
  isSelected() {
    return this.container.classList.contains("selected");
  }
  createDropdownIcon() {
    const icon = this.editor.icons.makeDropdownIcon();
    icon.classList.add(`${toolbarCSSPrefix}showHideDropdownIcon`);
    return icon;
  }
  /**
   * Serialize state associated with this widget.
   * Override this method to allow saving/restoring from state on application load.
   *
   * Overriders should call `super` and include the output of `super.serializeState` in
   * the output dictionary.
   *
   * Clients should not rely on the output from `saveState` being in any particular
   * format.
   */
  serializeState() {
    const subwidgetState = {};
    for (const subwidgetId in this.subWidgets) {
      subwidgetState[subwidgetId] = this.subWidgets[subwidgetId].serializeState();
    }
    return {
      subwidgetState
    };
  }
  /**
   * Restore widget state from serialized data. See also `saveState`.
   *
   * Overriders must call `super`.
   */
  deserializeFrom(state) {
    if (state.subwidgetState) {
      assertIsObject(state.subwidgetState);
      for (const subwidgetId in state.subwidgetState) {
        if (subwidgetId in this.subWidgets) {
          const serializedSubwidgetState = state.subwidgetState[subwidgetId];
          if (serializedSubwidgetState) {
            this.subWidgets[subwidgetId].deserializeFrom(serializedSubwidgetState);
          }
        }
      }
    }
  }
};
_a5 = BaseWidget, _BaseWidget_hasDropdown = /* @__PURE__ */ new WeakMap(), _BaseWidget_disabledDueToReadOnlyEditor = /* @__PURE__ */ new WeakMap(), _BaseWidget_tags = /* @__PURE__ */ new WeakMap(), _BaseWidget_removeEditorListeners = /* @__PURE__ */ new WeakMap(), _BaseWidget_instances = /* @__PURE__ */ new WeakSet(), _BaseWidget_addEditorListeners = function _BaseWidget_addEditorListeners2() {
  var _a6;
  (_a6 = __classPrivateFieldGet12(this, _BaseWidget_removeEditorListeners, "f")) == null ? void 0 : _a6.call(this);
  const toolbarShortcutHandlers = this.editor.toolController.getMatchingTools(ToolbarShortcutHandler);
  let removeKeyPressListener = null;
  if (toolbarShortcutHandlers.length > 0 && this.onKeyPress !== _a5.prototype.onKeyPress) {
    const keyPressListener = (event) => this.onKeyPress(event);
    const handler = toolbarShortcutHandlers[0];
    handler.registerListener(keyPressListener);
    removeKeyPressListener = () => {
      handler.removeListener(keyPressListener);
    };
  }
  const readOnlyListener = this.editor.isReadOnlyReactiveValue().onUpdateAndNow((readOnly) => {
    var _a7;
    if (readOnly && this.shouldAutoDisableInReadOnlyEditor() && !this.disabled) {
      this.setDisabled(true);
      __classPrivateFieldSet10(this, _BaseWidget_disabledDueToReadOnlyEditor, true, "f");
      if (__classPrivateFieldGet12(this, _BaseWidget_hasDropdown, "f")) {
        (_a7 = this.dropdown) == null ? void 0 : _a7.requestHide();
      }
    } else if (!readOnly && __classPrivateFieldGet12(this, _BaseWidget_disabledDueToReadOnlyEditor, "f")) {
      __classPrivateFieldSet10(this, _BaseWidget_disabledDueToReadOnlyEditor, false, "f");
      this.setDisabled(false);
    }
  });
  __classPrivateFieldSet10(this, _BaseWidget_removeEditorListeners, () => {
    readOnlyListener.remove();
    removeKeyPressListener == null ? void 0 : removeKeyPressListener();
    __classPrivateFieldSet10(this, _BaseWidget_removeEditorListeners, null, "f");
  }, "f");
};
var BaseWidget_default = BaseWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.mjs
var EdgeToolbarLayoutManager = class {
  // @internal
  constructor(setSidebarContent, sidebarTitle, sidebarVisibility, announceForAccessibility, localization4) {
    this.setSidebarContent = setSidebarContent;
    this.sidebarTitle = sidebarTitle;
    this.sidebarVisibility = sidebarVisibility;
    this.announceForAccessibility = announceForAccessibility;
    this.localization = localization4;
    this.visibleWidgetContent = ReactiveValue.fromInitialValue(null);
  }
  /** Creates a dropdown within `parent`. */
  createToolMenu(parent) {
    const contentElem = document.createElement("div");
    let result = null;
    const visible = ReactiveValue.fromCallback(() => {
      return this.visibleWidgetContent.get() === result && this.sidebarVisibility.get();
    }, [this.visibleWidgetContent, this.sidebarVisibility]);
    result = {
      visible,
      requestShow: () => {
        this.setSidebarContent(contentElem);
        this.sidebarTitle.set(parent.getTitle());
        this.visibleWidgetContent.set(result);
        this.sidebarVisibility.set(true);
        this.announceForAccessibility(this.localization.dropdownShown(parent.getTitle()));
      },
      onActivated: () => {
      },
      requestHide: () => {
        if (visible.get()) {
          this.sidebarVisibility.set(false);
        }
      },
      appendChild: (item) => {
        contentElem.appendChild(item);
      },
      clearChildren: () => {
        contentElem.replaceChildren();
      },
      destroy: () => {
        result == null ? void 0 : result.requestHide();
        if (contentElem.parentElement) {
          contentElem.remove();
        }
        if (this.visibleWidgetContent.get() === result) {
          this.visibleWidgetContent.set(null);
        }
      }
    };
    return result;
  }
};

// node_modules/@melloware/coloris/dist/esm/coloris.js
var Coloris = (() => {
  return ((window2, document2, Math2, undefined2) => {
    const ctx = document2.createElement("canvas").getContext("2d");
    const currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };
    let container, picker, colorArea, colorMarker, colorPreview, colorValue, clearButton, closeButton, hueSlider, hueMarker, alphaSlider, alphaMarker, currentEl, currentFormat, oldColor, keyboardNav, colorAreaDims = {};
    const settings = {
      el: "[data-coloris]",
      parent: "body",
      theme: "default",
      themeMode: "light",
      rtl: false,
      wrap: true,
      margin: 2,
      format: "hex",
      formatToggle: false,
      swatches: [],
      swatchesOnly: false,
      alpha: true,
      forceAlpha: false,
      focusInput: true,
      selectInput: false,
      inline: false,
      defaultColor: "#000000",
      clearButton: false,
      clearLabel: "Clear",
      closeButton: false,
      closeLabel: "Close",
      onChange: () => undefined2,
      a11y: {
        open: "Open color picker",
        close: "Close color picker",
        clear: "Clear the selected color",
        marker: "Saturation: {s}. Brightness: {v}.",
        hueSlider: "Hue slider",
        alphaSlider: "Opacity slider",
        input: "Color value field",
        format: "Color format",
        swatch: "Color swatch",
        instruction: "Saturation and brightness selector. Use up, down, left and right arrow keys to select."
      }
    };
    const instances = {};
    let currentInstanceId = "";
    let defaultInstance = {};
    let hasInstance = false;
    function configure(options) {
      if (typeof options !== "object") {
        return;
      }
      for (const key in options) {
        switch (key) {
          case "el":
            bindFields(options.el);
            if (options.wrap !== false) {
              wrapFields(options.el);
            }
            break;
          case "parent":
            container = document2.querySelector(options.parent);
            if (container) {
              container.appendChild(picker);
              settings.parent = options.parent;
              if (container === document2.body) {
                container = undefined2;
              }
            }
            break;
          case "themeMode":
            settings.themeMode = options.themeMode;
            if (options.themeMode === "auto" && window2.matchMedia && window2.matchMedia("(prefers-color-scheme: dark)").matches) {
              settings.themeMode = "dark";
            }
          // The lack of a break statement is intentional
          case "theme":
            if (options.theme) {
              settings.theme = options.theme;
            }
            picker.className = `clr-picker clr-${settings.theme} clr-${settings.themeMode}`;
            if (settings.inline) {
              updatePickerPosition();
            }
            break;
          case "rtl":
            settings.rtl = !!options.rtl;
            document2.querySelectorAll(".clr-field").forEach((field) => field.classList.toggle("clr-rtl", settings.rtl));
            break;
          case "margin":
            options.margin *= 1;
            settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;
            break;
          case "wrap":
            if (options.el && options.wrap) {
              wrapFields(options.el);
            }
            break;
          case "formatToggle":
            settings.formatToggle = !!options.formatToggle;
            getEl("clr-format").style.display = settings.formatToggle ? "block" : "none";
            if (settings.formatToggle) {
              settings.format = "auto";
            }
            break;
          case "swatches":
            if (Array.isArray(options.swatches)) {
              const swatches = [];
              options.swatches.forEach((swatch, i) => {
                swatches.push(`<button type="button" id="clr-swatch-${i}" aria-labelledby="clr-swatch-label clr-swatch-${i}" style="color: ${swatch};">${swatch}</button>`);
              });
              getEl("clr-swatches").innerHTML = swatches.length ? `<div>${swatches.join("")}</div>` : "";
              settings.swatches = options.swatches.slice();
            }
            break;
          case "swatchesOnly":
            settings.swatchesOnly = !!options.swatchesOnly;
            picker.setAttribute("data-minimal", settings.swatchesOnly);
            break;
          case "alpha":
            settings.alpha = !!options.alpha;
            picker.setAttribute("data-alpha", settings.alpha);
            break;
          case "inline":
            settings.inline = !!options.inline;
            picker.setAttribute("data-inline", settings.inline);
            if (settings.inline) {
              const defaultColor = options.defaultColor || settings.defaultColor;
              currentFormat = getColorFormatFromStr(defaultColor);
              updatePickerPosition();
              setColorFromStr(defaultColor);
            }
            break;
          case "clearButton":
            if (typeof options.clearButton === "object") {
              if (options.clearButton.label) {
                settings.clearLabel = options.clearButton.label;
                clearButton.innerHTML = settings.clearLabel;
              }
              options.clearButton = options.clearButton.show;
            }
            settings.clearButton = !!options.clearButton;
            clearButton.style.display = settings.clearButton ? "block" : "none";
            break;
          case "clearLabel":
            settings.clearLabel = options.clearLabel;
            clearButton.innerHTML = settings.clearLabel;
            break;
          case "closeButton":
            settings.closeButton = !!options.closeButton;
            if (settings.closeButton) {
              picker.insertBefore(closeButton, colorPreview);
            } else {
              colorPreview.appendChild(closeButton);
            }
            break;
          case "closeLabel":
            settings.closeLabel = options.closeLabel;
            closeButton.innerHTML = settings.closeLabel;
            break;
          case "a11y":
            const labels = options.a11y;
            let update = false;
            if (typeof labels === "object") {
              for (const label in labels) {
                if (labels[label] && settings.a11y[label]) {
                  settings.a11y[label] = labels[label];
                  update = true;
                }
              }
            }
            if (update) {
              const openLabel = getEl("clr-open-label");
              const swatchLabel = getEl("clr-swatch-label");
              openLabel.innerHTML = settings.a11y.open;
              swatchLabel.innerHTML = settings.a11y.swatch;
              closeButton.setAttribute("aria-label", settings.a11y.close);
              clearButton.setAttribute("aria-label", settings.a11y.clear);
              hueSlider.setAttribute("aria-label", settings.a11y.hueSlider);
              alphaSlider.setAttribute("aria-label", settings.a11y.alphaSlider);
              colorValue.setAttribute("aria-label", settings.a11y.input);
              colorArea.setAttribute("aria-label", settings.a11y.instruction);
            }
            break;
          default:
            settings[key] = options[key];
        }
      }
    }
    function setVirtualInstance(selector, options) {
      if (typeof selector === "string" && typeof options === "object") {
        instances[selector] = options;
        hasInstance = true;
      }
    }
    function removeVirtualInstance(selector) {
      delete instances[selector];
      if (Object.keys(instances).length === 0) {
        hasInstance = false;
        if (selector === currentInstanceId) {
          resetVirtualInstance();
        }
      }
    }
    function attachVirtualInstance(element) {
      if (hasInstance) {
        const unsupportedOptions = ["el", "wrap", "rtl", "inline", "defaultColor", "a11y"];
        for (let selector in instances) {
          const options = instances[selector];
          if (element.matches(selector)) {
            currentInstanceId = selector;
            defaultInstance = {};
            unsupportedOptions.forEach((option) => delete options[option]);
            for (let option in options) {
              defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];
            }
            configure(options);
            break;
          }
        }
      }
    }
    function resetVirtualInstance() {
      if (Object.keys(defaultInstance).length > 0) {
        configure(defaultInstance);
        currentInstanceId = "";
        defaultInstance = {};
      }
    }
    function bindFields(selector) {
      addListener(document2, "click", selector, (event) => {
        if (settings.inline) {
          return;
        }
        attachVirtualInstance(event.target);
        currentEl = event.target;
        oldColor = currentEl.value;
        currentFormat = getColorFormatFromStr(oldColor);
        picker.classList.add("clr-open");
        updatePickerPosition();
        setColorFromStr(oldColor);
        if (settings.focusInput || settings.selectInput) {
          colorValue.focus({ preventScroll: true });
          colorValue.setSelectionRange(currentEl.selectionStart, currentEl.selectionEnd);
        }
        if (settings.selectInput) {
          colorValue.select();
        }
        if (keyboardNav || settings.swatchesOnly) {
          getFocusableElements().shift().focus();
        }
        currentEl.dispatchEvent(new Event("open", { bubbles: true }));
      });
      addListener(document2, "input", selector, (event) => {
        const parent = event.target.parentNode;
        if (parent.classList.contains("clr-field")) {
          parent.style.color = event.target.value;
        }
      });
    }
    function updatePickerPosition() {
      if (!picker || !currentEl && !settings.inline) return;
      const parent = container;
      const scrollY = window2.scrollY;
      const pickerWidth = picker.offsetWidth;
      const pickerHeight = picker.offsetHeight;
      const reposition = { left: false, top: false };
      let parentStyle, parentMarginTop, parentBorderTop;
      let offset = { x: 0, y: 0 };
      if (parent) {
        parentStyle = window2.getComputedStyle(parent);
        parentMarginTop = parseFloat(parentStyle.marginTop);
        parentBorderTop = parseFloat(parentStyle.borderTopWidth);
        offset = parent.getBoundingClientRect();
        offset.y += parentBorderTop + scrollY;
      }
      if (!settings.inline) {
        const coords = currentEl.getBoundingClientRect();
        let left = coords.x;
        let top = scrollY + coords.y + coords.height + settings.margin;
        if (parent) {
          left -= offset.x;
          top -= offset.y;
          if (left + pickerWidth > parent.clientWidth) {
            left += coords.width - pickerWidth;
            reposition.left = true;
          }
          if (top + pickerHeight > parent.clientHeight - parentMarginTop) {
            if (pickerHeight + settings.margin <= coords.top - (offset.y - scrollY)) {
              top -= coords.height + pickerHeight + settings.margin * 2;
              reposition.top = true;
            }
          }
          top += parent.scrollTop;
        } else {
          if (left + pickerWidth > document2.documentElement.clientWidth) {
            left += coords.width - pickerWidth;
            reposition.left = true;
          }
          if (top + pickerHeight - scrollY > document2.documentElement.clientHeight) {
            if (pickerHeight + settings.margin <= coords.top) {
              top = scrollY + coords.y - pickerHeight - settings.margin;
              reposition.top = true;
            }
          }
        }
        picker.classList.toggle("clr-left", reposition.left);
        picker.classList.toggle("clr-top", reposition.top);
        picker.style.left = `${left}px`;
        picker.style.top = `${top}px`;
        offset.x += picker.offsetLeft;
        offset.y += picker.offsetTop;
      }
      colorAreaDims = {
        width: colorArea.offsetWidth,
        height: colorArea.offsetHeight,
        x: colorArea.offsetLeft + offset.x,
        y: colorArea.offsetTop + offset.y
      };
    }
    function wrapFields(selector) {
      document2.querySelectorAll(selector).forEach((field) => {
        const parentNode = field.parentNode;
        if (!parentNode.classList.contains("clr-field")) {
          const wrapper = document2.createElement("div");
          let classes = "clr-field";
          if (settings.rtl || field.classList.contains("clr-rtl")) {
            classes += " clr-rtl";
          }
          wrapper.innerHTML = `<button type="button" aria-labelledby="clr-open-label"></button>`;
          parentNode.insertBefore(wrapper, field);
          wrapper.setAttribute("class", classes);
          wrapper.style.color = field.value;
          wrapper.appendChild(field);
        }
      });
    }
    function closePicker(revert) {
      if (currentEl && !settings.inline) {
        const prevEl = currentEl;
        if (revert) {
          currentEl = undefined2;
          if (oldColor !== prevEl.value) {
            prevEl.value = oldColor;
            prevEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
        }
        setTimeout(() => {
          if (oldColor !== prevEl.value) {
            prevEl.dispatchEvent(new Event("change", { bubbles: true }));
          }
        });
        picker.classList.remove("clr-open");
        if (hasInstance) {
          resetVirtualInstance();
        }
        prevEl.dispatchEvent(new Event("close", { bubbles: true }));
        if (settings.focusInput) {
          prevEl.focus({ preventScroll: true });
        }
        currentEl = undefined2;
      }
    }
    function setColorFromStr(str) {
      const rgba = strToRGBA(str);
      const hsva = RGBAtoHSVA(rgba);
      updateMarkerA11yLabel(hsva.s, hsva.v);
      updateColor(rgba, hsva);
      hueSlider.value = hsva.h;
      picker.style.color = `hsl(${hsva.h}, 100%, 50%)`;
      hueMarker.style.left = `${hsva.h / 360 * 100}%`;
      colorMarker.style.left = `${colorAreaDims.width * hsva.s / 100}px`;
      colorMarker.style.top = `${colorAreaDims.height - colorAreaDims.height * hsva.v / 100}px`;
      alphaSlider.value = hsva.a * 100;
      alphaMarker.style.left = `${hsva.a * 100}%`;
    }
    function getColorFormatFromStr(str) {
      const format = str.substring(0, 3).toLowerCase();
      if (format === "rgb" || format === "hsl") {
        return format;
      }
      return "hex";
    }
    function pickColor(color) {
      color = color !== undefined2 ? color : colorValue.value;
      if (currentEl) {
        currentEl.value = color;
        currentEl.dispatchEvent(new Event("input", { bubbles: true }));
      }
      if (settings.onChange) {
        settings.onChange.call(window2, color, currentEl);
      }
      document2.dispatchEvent(new CustomEvent("coloris:pick", { detail: { color, currentEl } }));
    }
    function setColorAtPosition(x, y) {
      const hsva = {
        h: hueSlider.value * 1,
        s: x / colorAreaDims.width * 100,
        v: 100 - y / colorAreaDims.height * 100,
        a: alphaSlider.value / 100
      };
      const rgba = HSVAtoRGBA(hsva);
      updateMarkerA11yLabel(hsva.s, hsva.v);
      updateColor(rgba, hsva);
      pickColor();
    }
    function updateMarkerA11yLabel(saturation, value) {
      let label = settings.a11y.marker;
      saturation = saturation.toFixed(1) * 1;
      value = value.toFixed(1) * 1;
      label = label.replace("{s}", saturation);
      label = label.replace("{v}", value);
      colorMarker.setAttribute("aria-label", label);
    }
    function getPointerPosition(event) {
      return {
        pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,
        pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY
      };
    }
    function moveMarker(event) {
      const pointer = getPointerPosition(event);
      let x = pointer.pageX - colorAreaDims.x;
      let y = pointer.pageY - colorAreaDims.y;
      if (container) {
        y += container.scrollTop;
      }
      setMarkerPosition(x, y);
      event.preventDefault();
      event.stopPropagation();
    }
    function moveMarkerOnKeydown(offsetX, offsetY) {
      let x = colorMarker.style.left.replace("px", "") * 1 + offsetX;
      let y = colorMarker.style.top.replace("px", "") * 1 + offsetY;
      setMarkerPosition(x, y);
    }
    function setMarkerPosition(x, y) {
      x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;
      y = y < 0 ? 0 : y > colorAreaDims.height ? colorAreaDims.height : y;
      colorMarker.style.left = `${x}px`;
      colorMarker.style.top = `${y}px`;
      setColorAtPosition(x, y);
      colorMarker.focus();
    }
    function updateColor(rgba, hsva) {
      if (rgba === void 0) {
        rgba = {};
      }
      if (hsva === void 0) {
        hsva = {};
      }
      let format = settings.format;
      for (const key in rgba) {
        currentColor[key] = rgba[key];
      }
      for (const key in hsva) {
        currentColor[key] = hsva[key];
      }
      const hex = RGBAToHex(currentColor);
      const opaqueHex = hex.substring(0, 7);
      colorMarker.style.color = opaqueHex;
      alphaMarker.parentNode.style.color = opaqueHex;
      alphaMarker.style.color = hex;
      colorPreview.style.color = hex;
      colorArea.style.display = "none";
      colorArea.offsetHeight;
      colorArea.style.display = "";
      alphaMarker.nextElementSibling.style.display = "none";
      alphaMarker.nextElementSibling.offsetHeight;
      alphaMarker.nextElementSibling.style.display = "";
      if (format === "mixed") {
        format = currentColor.a === 1 ? "hex" : "rgb";
      } else if (format === "auto") {
        format = currentFormat;
      }
      switch (format) {
        case "hex":
          colorValue.value = hex;
          break;
        case "rgb":
          colorValue.value = RGBAToStr(currentColor);
          break;
        case "hsl":
          colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));
          break;
      }
      document2.querySelector(`.clr-format [value="${format}"]`).checked = true;
    }
    function setHue() {
      const hue = hueSlider.value * 1;
      const x = colorMarker.style.left.replace("px", "") * 1;
      const y = colorMarker.style.top.replace("px", "") * 1;
      picker.style.color = `hsl(${hue}, 100%, 50%)`;
      hueMarker.style.left = `${hue / 360 * 100}%`;
      setColorAtPosition(x, y);
    }
    function setAlpha() {
      const alpha = alphaSlider.value / 100;
      alphaMarker.style.left = `${alpha * 100}%`;
      updateColor({ a: alpha });
      pickColor();
    }
    function HSVAtoRGBA(hsva) {
      const saturation = hsva.s / 100;
      const value = hsva.v / 100;
      let chroma = saturation * value;
      let hueBy60 = hsva.h / 60;
      let x = chroma * (1 - Math2.abs(hueBy60 % 2 - 1));
      let m = value - chroma;
      chroma = chroma + m;
      x = x + m;
      const index = Math2.floor(hueBy60) % 6;
      const red = [chroma, x, m, m, x, chroma][index];
      const green = [x, chroma, chroma, x, m, m][index];
      const blue = [m, m, x, chroma, chroma, x][index];
      return {
        r: Math2.round(red * 255),
        g: Math2.round(green * 255),
        b: Math2.round(blue * 255),
        a: hsva.a
      };
    }
    function HSVAtoHSLA(hsva) {
      const value = hsva.v / 100;
      const lightness = value * (1 - hsva.s / 100 / 2);
      let saturation;
      if (lightness > 0 && lightness < 1) {
        saturation = Math2.round((value - lightness) / Math2.min(lightness, 1 - lightness) * 100);
      }
      return {
        h: hsva.h,
        s: saturation || 0,
        l: Math2.round(lightness * 100),
        a: hsva.a
      };
    }
    function RGBAtoHSVA(rgba) {
      const red = rgba.r / 255;
      const green = rgba.g / 255;
      const blue = rgba.b / 255;
      const xmax = Math2.max(red, green, blue);
      const xmin = Math2.min(red, green, blue);
      const chroma = xmax - xmin;
      const value = xmax;
      let hue = 0;
      let saturation = 0;
      if (chroma) {
        if (xmax === red) {
          hue = (green - blue) / chroma;
        }
        if (xmax === green) {
          hue = 2 + (blue - red) / chroma;
        }
        if (xmax === blue) {
          hue = 4 + (red - green) / chroma;
        }
        if (xmax) {
          saturation = chroma / xmax;
        }
      }
      hue = Math2.floor(hue * 60);
      return {
        h: hue < 0 ? hue + 360 : hue,
        s: Math2.round(saturation * 100),
        v: Math2.round(value * 100),
        a: rgba.a
      };
    }
    function strToRGBA(str) {
      const regex = /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i;
      let match, rgba;
      ctx.fillStyle = "#000";
      ctx.fillStyle = str;
      match = regex.exec(ctx.fillStyle);
      if (match) {
        rgba = {
          r: match[3] * 1,
          g: match[4] * 1,
          b: match[5] * 1,
          a: match[6] * 1
        };
        rgba.a = +rgba.a.toFixed(2);
      } else {
        match = ctx.fillStyle.replace("#", "").match(/.{2}/g).map((h) => parseInt(h, 16));
        rgba = {
          r: match[0],
          g: match[1],
          b: match[2],
          a: 1
        };
      }
      return rgba;
    }
    function RGBAToHex(rgba) {
      let R = rgba.r.toString(16);
      let G = rgba.g.toString(16);
      let B = rgba.b.toString(16);
      let A = "";
      if (rgba.r < 16) {
        R = "0" + R;
      }
      if (rgba.g < 16) {
        G = "0" + G;
      }
      if (rgba.b < 16) {
        B = "0" + B;
      }
      if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {
        const alpha = rgba.a * 255 | 0;
        A = alpha.toString(16);
        if (alpha < 16) {
          A = "0" + A;
        }
      }
      return "#" + R + G + B + A;
    }
    function RGBAToStr(rgba) {
      if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {
        return `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`;
      } else {
        return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      }
    }
    function HSLAToStr(hsla) {
      if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {
        return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%)`;
      } else {
        return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;
      }
    }
    function init() {
      if (document2.getElementById("clr-picker")) return;
      container = undefined2;
      picker = document2.createElement("div");
      picker.setAttribute("id", "clr-picker");
      picker.className = "clr-picker";
      picker.innerHTML = `<input id="clr-color-value" name="clr-color-value" class="clr-color" type="text" value="" spellcheck="false" aria-label="${settings.a11y.input}"><div id="clr-color-area" class="clr-gradient" role="application" aria-label="${settings.a11y.instruction}"><div id="clr-color-marker" class="clr-marker" tabindex="0"></div></div><div class="clr-hue"><input id="clr-hue-slider" name="clr-hue-slider" type="range" min="0" max="360" step="1" aria-label="${settings.a11y.hueSlider}"><div id="clr-hue-marker"></div></div><div class="clr-alpha"><input id="clr-alpha-slider" name="clr-alpha-slider" type="range" min="0" max="100" step="1" aria-label="${settings.a11y.alphaSlider}"><div id="clr-alpha-marker"></div><span></span></div><div id="clr-format" class="clr-format"><fieldset class="clr-segmented"><legend>${settings.a11y.format}</legend><input id="clr-f1" type="radio" name="clr-format" value="hex"><label for="clr-f1">Hex</label><input id="clr-f2" type="radio" name="clr-format" value="rgb"><label for="clr-f2">RGB</label><input id="clr-f3" type="radio" name="clr-format" value="hsl"><label for="clr-f3">HSL</label><span></span></fieldset></div><div id="clr-swatches" class="clr-swatches"></div><button type="button" id="clr-clear" class="clr-clear" aria-label="${settings.a11y.clear}">${settings.clearLabel}</button><div id="clr-color-preview" class="clr-preview"><button type="button" id="clr-close" class="clr-close" aria-label="${settings.a11y.close}">${settings.closeLabel}</button></div><span id="clr-open-label" hidden>${settings.a11y.open}</span><span id="clr-swatch-label" hidden>${settings.a11y.swatch}</span>`;
      document2.body.appendChild(picker);
      colorArea = getEl("clr-color-area");
      colorMarker = getEl("clr-color-marker");
      clearButton = getEl("clr-clear");
      closeButton = getEl("clr-close");
      colorPreview = getEl("clr-color-preview");
      colorValue = getEl("clr-color-value");
      hueSlider = getEl("clr-hue-slider");
      hueMarker = getEl("clr-hue-marker");
      alphaSlider = getEl("clr-alpha-slider");
      alphaMarker = getEl("clr-alpha-marker");
      bindFields(settings.el);
      wrapFields(settings.el);
      addListener(picker, "mousedown", (event) => {
        picker.classList.remove("clr-keyboard-nav");
        event.stopPropagation();
      });
      addListener(colorArea, "mousedown", (event) => {
        addListener(document2, "mousemove", moveMarker);
      });
      addListener(colorArea, "touchstart", (event) => {
        document2.addEventListener("touchmove", moveMarker, { passive: false });
      });
      addListener(colorMarker, "mousedown", (event) => {
        addListener(document2, "mousemove", moveMarker);
      });
      addListener(colorMarker, "touchstart", (event) => {
        document2.addEventListener("touchmove", moveMarker, { passive: false });
      });
      addListener(colorValue, "change", (event) => {
        const value = colorValue.value;
        if (currentEl || settings.inline) {
          const color = value === "" ? value : setColorFromStr(value);
          pickColor(color);
        }
      });
      addListener(clearButton, "click", (event) => {
        pickColor("");
        closePicker();
      });
      addListener(closeButton, "click", (event) => {
        pickColor();
        closePicker();
      });
      addListener(getEl("clr-format"), "click", ".clr-format input", (event) => {
        currentFormat = event.target.value;
        updateColor();
        pickColor();
      });
      addListener(picker, "click", ".clr-swatches button", (event) => {
        setColorFromStr(event.target.textContent);
        pickColor();
        if (settings.swatchesOnly) {
          closePicker();
        }
      });
      addListener(document2, "mouseup", (event) => {
        document2.removeEventListener("mousemove", moveMarker);
      });
      addListener(document2, "touchend", (event) => {
        document2.removeEventListener("touchmove", moveMarker);
      });
      addListener(document2, "mousedown", (event) => {
        keyboardNav = false;
        picker.classList.remove("clr-keyboard-nav");
        closePicker();
      });
      addListener(document2, "keydown", (event) => {
        const key = event.key;
        const target = event.target;
        const shiftKey = event.shiftKey;
        const navKeys = ["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
        if (key === "Escape") {
          closePicker(true);
        } else if (navKeys.includes(key)) {
          keyboardNav = true;
          picker.classList.add("clr-keyboard-nav");
        }
        if (key === "Tab" && target.matches(".clr-picker *")) {
          const focusables = getFocusableElements();
          const firstFocusable = focusables.shift();
          const lastFocusable = focusables.pop();
          if (shiftKey && target === firstFocusable) {
            lastFocusable.focus();
            event.preventDefault();
          } else if (!shiftKey && target === lastFocusable) {
            firstFocusable.focus();
            event.preventDefault();
          }
        }
      });
      addListener(document2, "click", ".clr-field button", (event) => {
        if (hasInstance) {
          resetVirtualInstance();
        }
        event.target.nextElementSibling.dispatchEvent(new Event("click", { bubbles: true }));
      });
      addListener(colorMarker, "keydown", (event) => {
        const movements = {
          ArrowUp: [0, -1],
          ArrowDown: [0, 1],
          ArrowLeft: [-1, 0],
          ArrowRight: [1, 0]
        };
        if (Object.keys(movements).includes(event.key)) {
          moveMarkerOnKeydown(...movements[event.key]);
          event.preventDefault();
        }
      });
      addListener(colorArea, "click", moveMarker);
      addListener(hueSlider, "input", setHue);
      addListener(alphaSlider, "input", setAlpha);
    }
    function getFocusableElements() {
      const controls = Array.from(picker.querySelectorAll("input, button"));
      const focusables = controls.filter((node) => !!node.offsetWidth);
      return focusables;
    }
    function getEl(id) {
      return document2.getElementById(id);
    }
    function addListener(context, type, selector, fn) {
      const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
      if (typeof selector === "string") {
        context.addEventListener(type, (event) => {
          if (matches.call(event.target, selector)) {
            fn.call(event.target, event);
          }
        });
      } else {
        fn = selector;
        context.addEventListener(type, fn);
      }
    }
    function DOMReady(fn, args) {
      args = args !== undefined2 ? args : [];
      if (document2.readyState !== "loading") {
        fn(...args);
      } else {
        document2.addEventListener("DOMContentLoaded", () => {
          fn(...args);
        });
      }
    }
    if (NodeList !== undefined2 && NodeList.prototype && !NodeList.prototype.forEach) {
      NodeList.prototype.forEach = Array.prototype.forEach;
    }
    function setColor(color, target) {
      currentEl = target;
      oldColor = currentEl.value;
      attachVirtualInstance(target);
      currentFormat = getColorFormatFromStr(color);
      updatePickerPosition();
      setColorFromStr(color);
      pickColor();
      if (oldColor !== color) {
        currentEl.dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
    const Coloris2 = (() => {
      const methods = {
        init,
        set: configure,
        wrap: wrapFields,
        close: closePicker,
        setInstance: setVirtualInstance,
        setColor,
        removeInstance: removeVirtualInstance,
        updatePosition: updatePickerPosition,
        ready: DOMReady
      };
      function Coloris3(options) {
        DOMReady(() => {
          if (options) {
            if (typeof options === "string") {
              bindFields(options);
            } else {
              configure(options);
            }
          }
        });
      }
      for (const key in methods) {
        Coloris3[key] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          DOMReady(methods[key], args);
        };
      }
      DOMReady(() => {
        window2.addEventListener("resize", (event) => {
          Coloris3.updatePosition();
        });
        window2.addEventListener("scroll", (event) => {
          Coloris3.updatePosition();
        });
      });
      return Coloris3;
    })();
    Coloris2.coloris = Coloris2;
    return Coloris2;
  })(window, document, Math);
})();
var _coloris = Coloris.coloris;
var _init = Coloris.init;
var _set = Coloris.set;
var _wrap = Coloris.wrap;
var _close = Coloris.close;
var _setInstance = Coloris.setInstance;
var _removeInstance = Coloris.removeInstance;
var _updatePosition = Coloris.updatePosition;

// node_modules/js-draw/dist/mjs/components/builders/autocorrect/makeSnapToGridAutocorrect.mjs
var makeSnapToGridAutocorrect = (sourceFactory) => {
  return (startPoint, viewport) => {
    return new SnapToGridAutocompleteBuilder(sourceFactory, startPoint, viewport);
  };
};
var makeSnapToGridAutocorrect_default = makeSnapToGridAutocorrect;
var SnapToGridAutocompleteBuilder = class {
  constructor(sourceFactory, startPoint, viewport) {
    this.sourceFactory = sourceFactory;
    this.startPoint = startPoint;
    this.viewport = viewport;
    this.builder = sourceFactory(startPoint, viewport);
    this.points = [startPoint];
  }
  getBBox() {
    return this.builder.getBBox();
  }
  build() {
    return this.builder.build();
  }
  preview(renderer) {
    this.builder.preview(renderer);
  }
  addPoint(point) {
    this.points.push(point);
    this.builder.addPoint(point);
  }
  async autocorrectShape() {
    const snapToGrid = (point) => {
      return {
        ...point,
        pos: this.viewport.snapToGrid(point.pos)
      };
    };
    const startPoint = snapToGrid(this.startPoint);
    const builder = this.sourceFactory(startPoint, this.viewport);
    const points = this.points.map((point) => snapToGrid(point));
    for (const point of points) {
      builder.addPoint(point);
    }
    return builder.build();
  }
};

// node_modules/js-draw/dist/mjs/components/builders/ArrowBuilder.mjs
var makeArrowBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
  return new ArrowBuilder(initialPoint, viewport);
});
var ArrowBuilder = class {
  constructor(startPoint, viewport) {
    this.startPoint = startPoint;
    this.viewport = viewport;
    this.endPoint = startPoint;
  }
  getLineWidth() {
    return Math.max(this.endPoint.width, this.startPoint.width);
  }
  getBBox() {
    const preview = this.buildPreview();
    return preview.getBBox();
  }
  buildPreview() {
    const lineStartPoint = this.startPoint.pos;
    const endPoint = this.endPoint.pos;
    const toEnd = endPoint.minus(lineStartPoint).normalized();
    const arrowLength = endPoint.distanceTo(lineStartPoint);
    const arrowTipSize = Math.min(this.getLineWidth(), arrowLength / 2);
    const startSize = this.startPoint.width / 2;
    const endSize = this.endPoint.width / 2;
    const arrowTipBase = endPoint.minus(toEnd.times(arrowTipSize));
    const lineNormal = toEnd.orthog();
    const scaledStartNormal = lineNormal.times(startSize);
    const scaledBaseNormal = lineNormal.times(endSize);
    const path = new Path(arrowTipBase.minus(scaledBaseNormal), [
      // Stem
      {
        kind: PathCommandType.LineTo,
        point: lineStartPoint.minus(scaledStartNormal)
      },
      {
        kind: PathCommandType.LineTo,
        point: lineStartPoint.plus(scaledStartNormal)
      },
      {
        kind: PathCommandType.LineTo,
        point: arrowTipBase.plus(scaledBaseNormal)
      },
      // Head
      {
        kind: PathCommandType.LineTo,
        point: arrowTipBase.plus(lineNormal.times(arrowTipSize).plus(scaledBaseNormal))
      },
      {
        kind: PathCommandType.LineTo,
        point: endPoint.plus(toEnd.times(endSize))
      },
      {
        kind: PathCommandType.LineTo,
        point: arrowTipBase.plus(lineNormal.times(-arrowTipSize).minus(scaledBaseNormal))
      },
      {
        kind: PathCommandType.LineTo,
        point: arrowTipBase.minus(scaledBaseNormal)
      }
      // Round all points in the arrow (to remove unnecessary decimal places)
    ]).mapPoints((point) => this.viewport.roundPoint(point));
    const preview = new Stroke([
      {
        startPoint: path.startPoint,
        commands: path.parts,
        style: {
          fill: this.startPoint.color
        }
      }
    ]);
    return preview;
  }
  build() {
    return this.buildPreview();
  }
  preview(renderer) {
    this.buildPreview().render(renderer);
  }
  addPoint(point) {
    this.endPoint = point;
  }
};

// node_modules/js-draw/dist/mjs/components/builders/LineBuilder.mjs
var makeLineBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
  return new LineBuilder(initialPoint, viewport);
});
var LineBuilder = class {
  constructor(startPoint, viewport) {
    this.startPoint = startPoint;
    this.viewport = viewport;
    this.endPoint = startPoint;
  }
  getBBox() {
    const preview = this.buildPreview();
    return preview.getBBox();
  }
  buildPreview() {
    const startPoint = this.startPoint.pos;
    const endPoint = this.endPoint.pos;
    const toEnd = endPoint.minus(startPoint).normalized();
    const startSize = this.startPoint.width / 2;
    const endSize = this.endPoint.width / 2;
    const lineNormal = toEnd.orthog();
    const scaledStartNormal = lineNormal.times(startSize);
    const scaledEndNormal = lineNormal.times(endSize);
    const strokeStartPoint = startPoint.minus(scaledStartNormal);
    const path = new Path(strokeStartPoint, [
      {
        kind: PathCommandType.LineTo,
        point: startPoint.plus(scaledStartNormal)
      },
      {
        kind: PathCommandType.LineTo,
        point: endPoint.plus(scaledEndNormal)
      },
      {
        kind: PathCommandType.LineTo,
        point: endPoint.minus(scaledEndNormal)
      },
      {
        kind: PathCommandType.LineTo,
        point: startPoint.minus(scaledStartNormal)
      }
    ]).mapPoints((point) => this.viewport.roundPoint(point));
    const preview = new Stroke([pathToRenderable(path, { fill: this.startPoint.color })]);
    return preview;
  }
  build() {
    return this.buildPreview();
  }
  preview(renderer) {
    this.buildPreview().render(renderer);
  }
  addPoint(point) {
    this.endPoint = point;
  }
};

// node_modules/js-draw/dist/mjs/components/builders/RectangleBuilder.mjs
var makeFilledRectangleBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
  return new RectangleBuilder(initialPoint, true, viewport);
});
var makeOutlinedRectangleBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
  return new RectangleBuilder(initialPoint, false, viewport);
});
var RectangleBuilder = class {
  constructor(startPoint, filled, viewport) {
    this.startPoint = startPoint;
    this.filled = filled;
    this.viewport = viewport;
    this.endPoint = startPoint;
  }
  getBBox() {
    const preview = this.buildPreview();
    return preview.getBBox();
  }
  buildPreview() {
    const canvasAngle = this.viewport.getRotationAngle();
    const rotationMat = Mat33.zRotation(-canvasAngle);
    const startPoint = rotationMat.inverse().transformVec2(this.startPoint.pos);
    const endPoint = rotationMat.inverse().transformVec2(this.endPoint.pos);
    const rect = Rect2.fromCorners(startPoint, endPoint);
    const path = Path.fromRect(rect, this.filled ? null : this.endPoint.width).transformedBy(
      // Rotate the canvas rectangle so that its rotation matches the screen
      rotationMat
    ).mapPoints((point) => this.viewport.roundPoint(point));
    const preview = new Stroke([
      pathToRenderable(path, {
        fill: this.endPoint.color
      })
    ]);
    return preview;
  }
  build() {
    return this.buildPreview();
  }
  preview(renderer) {
    this.buildPreview().render(renderer);
  }
  addPoint(point) {
    this.endPoint = point;
  }
};

// node_modules/js-draw/dist/mjs/components/builders/CircleBuilder.mjs
var makeOutlinedCircleBuilder = makeSnapToGridAutocorrect_default((initialPoint, viewport) => {
  return new CircleBuilder(initialPoint, viewport);
});
var CircleBuilder = class {
  constructor(startPoint, viewport) {
    this.startPoint = startPoint;
    this.viewport = viewport;
    this.endPoint = startPoint;
  }
  getBBox() {
    const preview = this.buildPreview();
    return preview.getBBox();
  }
  buildPreview() {
    const pathCommands = [];
    const numDivisions = 6;
    const stepSize = Math.PI * 2 / numDivisions;
    const strokeWidth = Viewport_default.roundPoint(this.endPoint.width, 5 / this.viewport.getScaleFactor());
    const center = this.startPoint.pos.lerp(this.endPoint.pos, 0.5);
    const startEndDelta = this.endPoint.pos.minus(center);
    const radius = startEndDelta.length() - strokeWidth / 2;
    const startPoint = center.plus(Vec2.of(radius, 0));
    for (let t2 = stepSize; t2 <= Math.PI * 2; t2 += stepSize) {
      const endPoint = Vec2.of(radius * Math.cos(t2), -radius * Math.sin(t2)).plus(center);
      const controlPointRadiusScale = 1.141;
      const controlPoint = Vec2.of(Math.cos(t2 - stepSize / 2), -Math.sin(t2 - stepSize / 2)).times(radius * controlPointRadiusScale).plus(center);
      pathCommands.push({
        kind: PathCommandType.QuadraticBezierTo,
        controlPoint,
        endPoint
      });
    }
    pathCommands.push({
      kind: PathCommandType.LineTo,
      point: startPoint
    });
    const path = new Path(startPoint, pathCommands).mapPoints((point) => this.viewport.roundPoint(point));
    const preview = new Stroke([
      pathToRenderable(path, {
        fill: Color4.transparent,
        stroke: {
          width: strokeWidth,
          color: this.endPoint.color
        }
      })
    ]);
    return preview;
  }
  build() {
    return this.buildPreview();
  }
  preview(renderer) {
    this.buildPreview().render(renderer);
  }
  addPoint(point) {
    this.endPoint = point;
  }
};

// node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeColorInput.mjs
var makeColorInput = (editor, onColorChange) => {
  const container = document.createElement("span");
  const inputWrapper = document.createElement("span");
  const colorInput = document.createElement("input");
  colorInput.type = "button";
  colorInput.classList.add("coloris_input");
  container.classList.add("color-input-container");
  inputWrapper.classList.add("color-input-wrapper");
  inputWrapper.appendChild(colorInput);
  container.appendChild(inputWrapper);
  const pipetteController = addPipetteTool(editor, container, (color) => {
    colorInput.value = color.toHexString();
    onInputEnd();
    const parentElem = colorInput.parentElement;
    if (parentElem && parentElem.classList.contains("clr-field")) {
      parentElem.style.color = colorInput.value;
    }
  });
  let currentColor;
  const handleColorInput = () => {
    currentColor = Color4.fromHex(colorInput.value);
  };
  const onInputEnd = () => {
    handleColorInput();
    if (currentColor) {
      editor.announceForAccessibility(editor.localization.colorChangedAnnouncement(currentColor.toHexString()));
      onColorChange(currentColor);
      editor.notifier.dispatch(EditorEventType.ColorPickerColorSelected, {
        kind: EditorEventType.ColorPickerColorSelected,
        color: currentColor
      });
    }
  };
  colorInput.oninput = handleColorInput;
  let isOpen = false;
  colorInput.addEventListener("open", () => {
    isOpen = true;
    editor.notifier.dispatch(EditorEventType.ColorPickerToggled, {
      kind: EditorEventType.ColorPickerToggled,
      open: true
    });
    pipetteController.cancel();
    container.classList.add("picker-open");
    const colorPickerElem = document.querySelector("#clr-picker #clr-hue-slider");
    colorPickerElem == null ? void 0 : colorPickerElem.focus();
  });
  const onClose = () => {
    isOpen = false;
    editor.notifier.dispatch(EditorEventType.ColorPickerToggled, {
      kind: EditorEventType.ColorPickerToggled,
      open: false
    });
    onInputEnd();
    colorInput.focus();
    container.classList.remove("picker-open");
  };
  colorInput.addEventListener("close", () => {
    onClose();
  });
  const setColorInputValue = (color) => {
    if (typeof color === "object") {
      color = color.toHexString();
    }
    colorInput.value = color;
    colorInput.dispatchEvent(new Event("input", { bubbles: true }));
  };
  return {
    input: colorInput,
    container,
    setValue: setColorInputValue,
    closePicker: () => {
      if (isOpen) {
        onInputEnd();
      }
    },
    registerWithHelpTextDisplay: (helpDisplay) => {
      helpDisplay.registerTextHelpForElement(inputWrapper, editor.localization.colorPickerToggleHelpText);
      pipetteController.registerWithHelpTextDisplay(helpDisplay);
    }
  };
};
var addPipetteTool = (editor, container, onColorChange) => {
  const pipetteButton = document.createElement("button");
  pipetteButton.classList.add("pipetteButton");
  pipetteButton.title = editor.localization.pickColorFromScreen;
  pipetteButton.setAttribute("alt", pipetteButton.title);
  const pickColorLabel = document.createElement("span");
  pickColorLabel.classList.add("pickColorInstructions");
  pickColorLabel.innerText = editor.localization.clickToPickColorAnnouncement;
  const updatePipetteButtonContent = (color) => {
    pipetteButton.replaceChildren(editor.icons.makePipetteIcon(color), pickColorLabel);
  };
  updatePipetteButtonContent();
  const pipetteTool = editor.toolController.getMatchingTools(PipetteTool)[0];
  const endColorSelectMode = () => {
    pipetteTool == null ? void 0 : pipetteTool.clearColorListener();
    updatePipetteButtonContent();
    pipetteButton.classList.remove("active");
  };
  const pipetteColorSelect = (color) => {
    endColorSelectMode();
    if (color) {
      onColorChange(color);
    }
  };
  const pipetteColorPreview = (color) => {
    if (color) {
      updatePipetteButtonContent(color);
    } else {
      updatePipetteButtonContent();
    }
  };
  pipetteButton.onclick = () => {
    if (pipetteButton.classList.contains("active")) {
      endColorSelectMode();
      editor.announceForAccessibility(editor.localization.colorSelectionCanceledAnnouncement);
      return;
    }
    pipetteTool == null ? void 0 : pipetteTool.setColorListener(pipetteColorPreview, pipetteColorSelect);
    if (pipetteTool) {
      pipetteButton.classList.add("active");
      editor.announceForAccessibility(editor.localization.clickToPickColorAnnouncement);
    }
  };
  container.appendChild(pipetteButton);
  return {
    // Cancel a pipette color selection if one is in progress.
    cancel: () => {
      endColorSelectMode();
    },
    registerWithHelpTextDisplay: (helpDisplay) => {
      helpDisplay.registerTextHelpForElement(pipetteButton, editor.localization.colorPickerPipetteHelpText);
    }
  };
};
var makeColorInput_default = makeColorInput;

// node_modules/js-draw/dist/mjs/toolbar/widgets/BaseToolWidget.mjs
var isToolWidgetFocused = () => {
  const currentFocus = [...document.querySelectorAll("*:focus")];
  return currentFocus.length && currentFocus.some((elem) => elem.classList.contains(`${toolbarCSSPrefix}button`));
};
var BaseToolWidget = class extends BaseWidget_default {
  constructor(editor, targetTool, id, localizationTable) {
    super(editor, id, localizationTable);
    this.targetTool = targetTool;
    this.targetTool.enabledValue().onUpdateAndNow((enabled) => {
      if (enabled) {
        this.setSelected(true);
        if (isToolWidgetFocused()) {
          this.focus();
        }
      } else {
        this.setSelected(false);
        this.setDropdownVisible(false);
      }
    });
  }
  shouldAutoDisableInReadOnlyEditor() {
    return !this.targetTool.canReceiveInputInReadOnlyEditor();
  }
  handleClick() {
    if (this.hasDropdown) {
      if (!this.targetTool.isEnabled()) {
        this.targetTool.setEnabled(true);
        this.activateDropdown();
      } else {
        this.setDropdownVisible(!this.isDropdownVisible());
      }
    } else {
      this.targetTool.setEnabled(!this.targetTool.isEnabled());
    }
  }
  onKeyPress(event) {
    if (this.isSelected() && event.code === "Space" && this.hasDropdown) {
      this.handleClick();
      return true;
    }
    return false;
  }
  addTo(parent) {
    const result = super.addTo(parent);
    this.setSelected(this.targetTool.isEnabled());
    return result;
  }
};

// node_modules/js-draw/dist/mjs/toolbar/widgets/keybindings.mjs
var resizeImageToSelectionKeyboardShortcut = "jsdraw.toolbar.SelectionTool.resizeImageToSelection";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(resizeImageToSelectionKeyboardShortcut, ["ctrlOrMeta+r"], "Resize image to selection");
var selectStrokeTypeKeyboardShortcutIds = [1, 2, 3, 4, 5, 6, 7, 8, 9].map((id) => `jsdraw.toolbar.PenTool.select-pen-${id}`);
for (let i = 0; i < selectStrokeTypeKeyboardShortcutIds.length; i++) {
  const id = selectStrokeTypeKeyboardShortcutIds[i];
  KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(id, [`CtrlOrMeta+Digit${i + 1}`], "Select pen style " + (i + 1));
}
var saveKeyboardShortcut = "jsdraw.toolbar.SaveActionWidget.save";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(saveKeyboardShortcut, ["ctrlOrMeta+KeyS"], "Save");
var exitKeyboardShortcut = "jsdraw.toolbar.ExitActionWidget.exit";
KeyboardShortcutManager_default.registerDefaultKeyboardShortcut(exitKeyboardShortcut, ["Alt+KeyQ"], "Exit");

// node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeThicknessSlider.mjs
var idCounter2 = 0;
var makeThicknessSlider = (context, onChange) => {
  const container = document.createElement("div");
  const thicknessLabel = document.createElement("label");
  const thicknessInput = document.createElement("input");
  container.classList.add(`${toolbarCSSPrefix}thicknessSliderContainer`);
  thicknessInput.id = `${toolbarCSSPrefix}thicknessInput${idCounter2++}`;
  thicknessLabel.innerText = context.localization.thicknessLabel;
  thicknessLabel.setAttribute("for", thicknessInput.id);
  const inverseThicknessInputFn = (t2) => Math.log10(t2);
  const thicknessInputFn = (t2) => 10 ** t2;
  thicknessInput.type = "range";
  thicknessInput.oninput = () => {
    onChange(thicknessInputFn(parseFloat(thicknessInput.value)));
  };
  container.appendChild(thicknessLabel);
  container.appendChild(thicknessInput);
  const setBounds = (min2, max2) => {
    const round = (value, roundUp) => {
      const roundFn = roundUp ? Math.ceil : Math.floor;
      return roundFn(value * 100) / 100;
    };
    const sliderMin = round(inverseThicknessInputFn(min2), false);
    const sliderMax = round(inverseThicknessInputFn(max2), true);
    thicknessInput.min = `${sliderMin}`;
    thicknessInput.max = `${sliderMax}`;
    thicknessInput.step = `${toRoundedString((sliderMax - sliderMin) / 20)}`;
  };
  setBounds(2, 262);
  return {
    container,
    addTo: (parent) => {
      parent.appendChild(container);
    },
    setBounds,
    setValue: (thickness) => {
      thicknessInput.value = inverseThicknessInputFn(thickness).toString();
    }
  };
};
var makeThicknessSlider_default = makeThicknessSlider;

// node_modules/js-draw/dist/mjs/util/stopPropagationOfScrollingWheelEvents.mjs
var stopPropagationOfScrollingWheelEvents = (scrollingContainer) => {
  const scrollsAxis = (delta, clientSize, scrollOffset, scrollSize) => {
    const hasScroll = clientSize !== scrollSize && delta !== 0;
    const eventScrollsPastStart = scrollOffset + delta <= 0;
    const scrollEnd = scrollOffset + clientSize;
    const eventScrollsPastEnd = scrollEnd + delta > scrollSize;
    return hasScroll && !eventScrollsPastStart && !eventScrollsPastEnd;
  };
  scrollingContainer.onwheel = (event) => {
    const scrollsX = scrollsAxis(event.deltaX, scrollingContainer.clientWidth, scrollingContainer.scrollLeft, scrollingContainer.scrollWidth);
    const scrollsY = scrollsAxis(event.deltaY, scrollingContainer.clientHeight, scrollingContainer.scrollTop, scrollingContainer.scrollHeight);
    if (scrollsX || scrollsY) {
      event.stopPropagation();
    }
  };
};
var stopPropagationOfScrollingWheelEvents_default = stopPropagationOfScrollingWheelEvents;

// node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeGridSelector.mjs
var idCounter3 = 0;
var makeGridSelector = (labelText, defaultId, choices) => {
  const outerContainer = document.createElement("div");
  outerContainer.classList.add(`${toolbarCSSPrefix}grid-selector`);
  const selectedValue = MutableReactiveValue.fromInitialValue(defaultId);
  const menuContainer = document.createElement("div");
  menuContainer.role = "group";
  menuContainer.id = `${toolbarCSSPrefix}-grid-select-id-${idCounter3++}`;
  stopPropagationOfScrollingWheelEvents_default(menuContainer);
  const label = document.createElement("label");
  label.textContent = labelText;
  label.htmlFor = menuContainer.id;
  outerContainer.appendChild(label);
  let radiogroupName = `${toolbarCSSPrefix}-grid-selector-${idCounter3++}`;
  const createChoiceButton = (record) => {
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("choice-button");
    const button = document.createElement("input");
    button.type = "radio";
    button.id = `${toolbarCSSPrefix}-grid-select-button-${idCounter3++}`;
    addLongPressOrHoverCssClasses_default(buttonContainer);
    const labelContainer = document.createElement("label");
    const rebuildLabel = () => {
      labelContainer.setAttribute("title", record.title);
      const labelText2 = document.createElement("span");
      labelText2.classList.add("button-label-text");
      const icon = record.makeIcon();
      icon.classList.add("icon");
      labelText2.innerText = record.title;
      labelContainer.htmlFor = button.id;
      labelContainer.replaceChildren(icon, labelText2);
    };
    rebuildLabel();
    const updateButtonRadiogroupName = () => {
      button.name = radiogroupName;
    };
    updateButtonRadiogroupName();
    const updateButtonCSS = () => {
      if (button.checked) {
        buttonContainer.classList.add("checked");
      } else {
        buttonContainer.classList.remove("checked");
      }
    };
    button.oninput = () => {
      if (button.checked) {
        selectedValue.set(record.id);
      }
      updateButtonCSS();
    };
    button.onfocus = () => {
      if (buttonContainer.querySelector(":focus-visible")) {
        buttonContainer.classList.add("focus-visible");
      }
    };
    button.onblur = () => {
      buttonContainer.classList.remove("focus-visible");
    };
    buttonContainer.oncontextmenu = (event) => {
      event.preventDefault();
    };
    buttonContainer.replaceChildren(button, labelContainer);
    menuContainer.appendChild(buttonContainer);
    const setChecked = (checked) => {
      button.checked = checked;
      updateButtonCSS();
    };
    setChecked(false);
    const updateIcon = () => {
      rebuildLabel();
    };
    return {
      choiceRecord: record,
      setChecked,
      updateIcon,
      updateButtonRadiogroupName
    };
  };
  const buttons = [];
  for (const choice of choices) {
    buttons.push(createChoiceButton(choice));
  }
  outerContainer.appendChild(menuContainer);
  selectedValue.onUpdateAndNow((choiceId) => {
    for (let i = 0; i < buttons.length; i++) {
      buttons[i].setChecked(buttons[i].choiceRecord.id === choiceId);
    }
  });
  const result = {
    value: selectedValue,
    _radiogroupName: radiogroupName,
    linkWith: (other) => {
      result._radiogroupName = other._radiogroupName;
      radiogroupName = other._radiogroupName;
      for (const button of buttons) {
        button.updateButtonRadiogroupName();
      }
    },
    updateIcons: () => {
      buttons.forEach((button) => button.updateIcon());
    },
    getRootElement() {
      return outerContainer;
    },
    addTo: (parent) => {
      parent.appendChild(outerContainer);
    }
  };
  return result;
};
var makeGridSelector_default = makeGridSelector;

// node_modules/js-draw/dist/mjs/toolbar/widgets/PenToolWidget.mjs
var PenToolWidget = class _PenToolWidget extends BaseToolWidget {
  constructor(editor, tool, localization4) {
    var _a6, _b2;
    super(editor, tool, "pen", localization4);
    this.tool = tool;
    this.updateInputs = () => {
    };
    this.shapelikeIDs = ["pressure-sensitive-pen", "freehand-pen"];
    const additionalPens = ((_a6 = editor.getCurrentSettings().pens) == null ? void 0 : _a6.additionalPenTypes) ?? [];
    const filterPens = ((_b2 = editor.getCurrentSettings().pens) == null ? void 0 : _b2.filterPenTypes) ?? (() => true);
    this.penTypes = [
      // Non-shape pens
      {
        name: this.localizationTable.flatTipPen,
        id: "pressure-sensitive-pen",
        factory: makePressureSensitiveFreehandLineBuilder
      },
      {
        name: this.localizationTable.roundedTipPen,
        id: "freehand-pen",
        factory: makeFreehandLineBuilder
      },
      {
        name: this.localizationTable.roundedTipPen2,
        id: "polyline-pen",
        factory: makePolylineBuilder
      },
      ...additionalPens.filter((pen) => !pen.isShapeBuilder),
      // Shape pens
      {
        name: this.localizationTable.arrowPen,
        id: "arrow",
        isShapeBuilder: true,
        factory: makeArrowBuilder
      },
      {
        name: this.localizationTable.linePen,
        id: "line",
        isShapeBuilder: true,
        factory: makeLineBuilder
      },
      {
        name: this.localizationTable.filledRectanglePen,
        id: "filled-rectangle",
        isShapeBuilder: true,
        factory: makeFilledRectangleBuilder
      },
      {
        name: this.localizationTable.outlinedRectanglePen,
        id: "outlined-rectangle",
        isShapeBuilder: true,
        factory: makeOutlinedRectangleBuilder
      },
      {
        name: this.localizationTable.outlinedCirclePen,
        id: "outlined-circle",
        isShapeBuilder: true,
        factory: makeOutlinedCircleBuilder
      },
      ...additionalPens.filter((pen) => pen.isShapeBuilder)
    ].filter(filterPens);
    this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
      if (toolEvt.kind !== EditorEventType.ToolUpdated) {
        throw new Error("Invalid event type!");
      }
      if (toolEvt.tool === this.tool) {
        this.updateIcon();
        this.updateInputs();
      }
    });
  }
  getTitle() {
    return this.targetTool.description;
  }
  // Return the index of this tool's stroke factory in the list of
  // all stroke factories.
  //
  // Returns -1 if the stroke factory is not in the list of all stroke factories.
  getCurrentPenTypeIdx() {
    const currentFactory = this.tool.getStrokeFactory();
    for (let i = 0; i < this.penTypes.length; i++) {
      if (this.penTypes[i].factory === currentFactory) {
        return i;
      }
    }
    return -1;
  }
  getCurrentPenType() {
    for (const penType of this.penTypes) {
      if (penType.factory === this.tool.getStrokeFactory()) {
        return penType;
      }
    }
    return null;
  }
  createIconForRecord(record) {
    const style = {
      ...this.tool.getStyleValue().get()
    };
    if (record == null ? void 0 : record.factory) {
      style.factory = record.factory;
    }
    const strokeFactory = record == null ? void 0 : record.factory;
    if (!strokeFactory || strokeFactory === makeFreehandLineBuilder || strokeFactory === makePressureSensitiveFreehandLineBuilder || strokeFactory === makePolylineBuilder) {
      return this.editor.icons.makePenIcon(style);
    } else {
      return this.editor.icons.makeIconFromFactory(style);
    }
  }
  createIcon() {
    return this.createIconForRecord(this.getCurrentPenType());
  }
  // Creates a widget that allows selecting different pen types
  createPenTypeSelector(helpOverlay) {
    const allChoices = this.penTypes.map((penType, index) => {
      return {
        id: index,
        makeIcon: () => this.createIconForRecord(penType),
        title: penType.name,
        isShapeBuilder: penType.isShapeBuilder ?? false
      };
    });
    const penItems = allChoices.filter((choice) => !choice.isShapeBuilder);
    const penSelector = makeGridSelector_default(this.localizationTable.selectPenType, this.getCurrentPenTypeIdx(), penItems);
    const shapeItems = allChoices.filter((choice) => choice.isShapeBuilder);
    const shapeSelector = makeGridSelector_default(this.localizationTable.selectShape, this.getCurrentPenTypeIdx(), shapeItems);
    const onSelectorUpdate = (newPenTypeIndex) => {
      this.tool.setStrokeFactory(this.penTypes[newPenTypeIndex].factory);
    };
    penSelector.value.onUpdate(onSelectorUpdate);
    shapeSelector.value.onUpdate(onSelectorUpdate);
    helpOverlay == null ? void 0 : helpOverlay.registerTextHelpForElements([penSelector.getRootElement(), shapeSelector.getRootElement()], this.localizationTable.penDropdown__penTypeHelpText);
    return {
      setValue: (penTypeIndex) => {
        penSelector.value.set(penTypeIndex);
        shapeSelector.value.set(penTypeIndex);
      },
      updateIcons: () => {
        penSelector.updateIcons();
        shapeSelector.updateIcons();
      },
      addTo: (parent) => {
        if (penItems.length) {
          penSelector.addTo(parent);
        }
        if (shapeItems.length) {
          shapeSelector.addTo(parent);
        }
      }
    };
  }
  createStrokeCorrectionOptions(helpOverlay) {
    const container = document.createElement("div");
    container.classList.add("action-button-row", `${toolbarCSSPrefix}-pen-tool-toggle-buttons`);
    const addToggleButton = (labelText, icon) => {
      const button = document.createElement("button");
      button.classList.add(`${toolbarCSSPrefix}-toggle-button`);
      const iconElement = icon.cloneNode(true);
      iconElement.classList.add("icon");
      const label = document.createElement("span");
      label.innerText = labelText;
      button.replaceChildren(iconElement, label);
      button.setAttribute("role", "switch");
      container.appendChild(button);
      let checked = false;
      let onChangeListener = (_checked) => {
      };
      const result = {
        setChecked(newChecked) {
          checked = newChecked;
          button.setAttribute("aria-checked", `${checked}`);
          onChangeListener(checked);
        },
        setOnInputListener(listener) {
          onChangeListener = listener;
        },
        addHelpText(text) {
          helpOverlay == null ? void 0 : helpOverlay.registerTextHelpForElement(button, text);
        }
      };
      button.onclick = () => {
        result.setChecked(!checked);
      };
      return result;
    };
    const stabilizationOption = addToggleButton(this.localizationTable.inputStabilization, this.editor.icons.makeStrokeSmoothingIcon());
    stabilizationOption.setOnInputListener((enabled) => {
      this.tool.setHasStabilization(enabled);
    });
    const autocorrectOption = addToggleButton(this.localizationTable.strokeAutocorrect, this.editor.icons.makeShapeAutocorrectIcon());
    autocorrectOption.setOnInputListener((enabled) => {
      this.tool.setStrokeAutocorrectEnabled(enabled);
    });
    const pressureSensitivityOption = addToggleButton(this.localizationTable.pressureSensitivity, this.editor.icons.makePressureSensitivityIcon());
    pressureSensitivityOption.setOnInputListener((enabled) => {
      this.tool.setPressureSensitivityEnabled(enabled);
    });
    autocorrectOption.addHelpText(this.localizationTable.penDropdown__autocorrectHelpText);
    stabilizationOption.addHelpText(this.localizationTable.penDropdown__stabilizationHelpText);
    pressureSensitivityOption.addHelpText(this.localizationTable.penDropdown__pressureSensitivityHelpText);
    return {
      update: () => {
        stabilizationOption.setChecked(!!this.tool.getInputMapper());
        autocorrectOption.setChecked(this.tool.getStrokeAutocorrectionEnabled());
        pressureSensitivityOption.setChecked(this.tool.getPressureSensitivityEnabled());
      },
      addTo: (parent) => {
        parent.appendChild(container);
      }
    };
  }
  getHelpText() {
    return this.localizationTable.penDropdown__baseHelpText;
  }
  fillDropdown(dropdown, helpDisplay) {
    const container = document.createElement("div");
    container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
    const { container: thicknessRow, setValue: setThickness } = makeThicknessSlider_default(this.editor, (thickness) => {
      this.tool.setThickness(thickness);
    });
    const colorRow = document.createElement("div");
    const colorLabel = document.createElement("label");
    const colorInputControl = makeColorInput_default(this.editor, (color) => {
      this.tool.setColor(color);
    });
    const { input: colorInput, container: colorInputContainer } = colorInputControl;
    colorInput.id = `${toolbarCSSPrefix}colorInput${_PenToolWidget.idCounter++}`;
    colorLabel.innerText = this.localizationTable.colorLabel;
    colorLabel.setAttribute("for", colorInput.id);
    colorRow.appendChild(colorLabel);
    colorRow.appendChild(colorInputContainer);
    const toggleButtonRow = this.createStrokeCorrectionOptions(helpDisplay);
    const penTypeSelect = this.createPenTypeSelector(helpDisplay);
    helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(colorRow, this.localizationTable.penDropdown__colorHelpText);
    if (helpDisplay) {
      colorInputControl.registerWithHelpTextDisplay(helpDisplay);
    }
    helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(thicknessRow, this.localizationTable.penDropdown__thicknessHelpText);
    this.updateInputs = () => {
      colorInputControl.setValue(this.tool.getColor());
      setThickness(this.tool.getThickness());
      penTypeSelect.updateIcons();
      penTypeSelect.setValue(this.getCurrentPenTypeIdx());
      toggleButtonRow.update();
    };
    this.updateInputs();
    container.replaceChildren(colorRow, thicknessRow);
    penTypeSelect.addTo(container);
    dropdown.replaceChildren(container);
    toggleButtonRow.addTo(dropdown);
    return true;
  }
  onKeyPress(event) {
    if (!this.isSelected()) {
      return false;
    }
    for (let i = 0; i < selectStrokeTypeKeyboardShortcutIds.length; i++) {
      const shortcut = selectStrokeTypeKeyboardShortcutIds[i];
      if (this.editor.shortcuts.matchesShortcut(shortcut, event)) {
        const penTypeIdx = i;
        if (penTypeIdx < this.penTypes.length) {
          this.tool.setStrokeFactory(this.penTypes[penTypeIdx].factory);
          return true;
        }
      }
    }
    if (super.onKeyPress(event)) {
      return true;
    }
    return false;
  }
  serializeState() {
    var _a6;
    return {
      ...super.serializeState(),
      color: this.tool.getColor().toHexString(),
      thickness: this.tool.getThickness(),
      strokeFactoryId: (_a6 = this.getCurrentPenType()) == null ? void 0 : _a6.id,
      inputStabilization: !!this.tool.getInputMapper(),
      strokeAutocorrect: this.tool.getStrokeAutocorrectionEnabled(),
      pressureSensitivity: this.tool.getPressureSensitivityEnabled()
    };
  }
  deserializeFrom(state) {
    super.deserializeFrom(state);
    const verifyPropertyType = (propertyName, expectedType) => {
      const actualType = typeof state[propertyName];
      if (actualType !== expectedType) {
        throw new Error(`Deserializing property ${propertyName}: Invalid type. Expected ${expectedType}, was ${actualType}.`);
      }
    };
    if (state.color) {
      verifyPropertyType("color", "string");
      this.tool.setColor(Color4.fromHex(state.color));
    }
    if (state.thickness) {
      verifyPropertyType("thickness", "number");
      this.tool.setThickness(state.thickness);
    }
    if (state.strokeFactoryId) {
      verifyPropertyType("strokeFactoryId", "string");
      const factoryId = state.strokeFactoryId;
      for (const penType of this.penTypes) {
        if (factoryId === penType.id) {
          this.tool.setStrokeFactory(penType.factory);
          break;
        }
      }
    }
    if (state.inputStabilization !== void 0) {
      this.tool.setHasStabilization(!!state.inputStabilization);
    }
    if (state.strokeAutocorrect !== void 0) {
      this.tool.setStrokeAutocorrectEnabled(!!state.strokeAutocorrect);
    }
    if (state.pressureSensitivity !== void 0) {
      this.tool.setPressureSensitivityEnabled(!!state.pressureSensitivity);
    }
  }
};
PenToolWidget.idCounter = 0;
var PenToolWidget_default = PenToolWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/EraserToolWidget.mjs
var EraserToolWidget = class _EraserToolWidget extends BaseToolWidget {
  constructor(editor, tool, localizationTable) {
    super(editor, tool, "eraser-tool-widget", localizationTable);
    this.tool = tool;
    this.updateInputs = () => {
    };
    this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
      if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === this.tool) {
        this.updateInputs();
        this.updateIcon();
      }
    });
  }
  getHelpText() {
    return this.localizationTable.eraserDropdown__baseHelpText;
  }
  getTitle() {
    return this.localizationTable.eraser;
  }
  makeIconForType(mode) {
    return this.editor.icons.makeEraserIcon(this.tool.getThickness(), mode);
  }
  createIcon() {
    return this.makeIconForType(this.tool.getModeValue().get());
  }
  makeEraserTypeSelector(helpDisplay) {
    const container = document.createElement("div");
    const labelElement = document.createElement("label");
    const checkboxElement = document.createElement("input");
    checkboxElement.id = `${toolbarCSSPrefix}eraserToolWidget-${_EraserToolWidget.idCounter++}`;
    labelElement.htmlFor = checkboxElement.id;
    labelElement.innerText = this.localizationTable.fullStrokeEraser;
    checkboxElement.type = "checkbox";
    checkboxElement.oninput = () => {
      this.tool.getModeValue().set(checkboxElement.checked ? EraserMode.FullStroke : EraserMode.PartialStroke);
    };
    const updateValue = () => {
      checkboxElement.checked = this.tool.getModeValue().get() === EraserMode.FullStroke;
    };
    container.replaceChildren(labelElement, checkboxElement);
    helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(container, this.localizationTable.eraserDropdown__fullStrokeEraserHelpText);
    return {
      addTo: (parent) => {
        parent.appendChild(container);
      },
      updateValue
    };
  }
  fillDropdown(dropdown, helpDisplay) {
    const container = document.createElement("div");
    container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
    const thicknessSlider = makeThicknessSlider_default(this.editor, (thickness) => {
      this.tool.setThickness(thickness);
    });
    thicknessSlider.setBounds(10, 55);
    helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(thicknessSlider.container, this.localizationTable.eraserDropdown__thicknessHelpText);
    const modeSelector = this.makeEraserTypeSelector(helpDisplay);
    this.updateInputs = () => {
      thicknessSlider.setValue(this.tool.getThickness());
      modeSelector.updateValue();
    };
    this.updateInputs();
    container.replaceChildren(thicknessSlider.container);
    modeSelector.addTo(container);
    dropdown.replaceChildren(container);
    return true;
  }
  serializeState() {
    return {
      ...super.serializeState(),
      thickness: this.tool.getThickness(),
      mode: this.tool.getModeValue().get()
    };
  }
  deserializeFrom(state) {
    super.deserializeFrom(state);
    if (state.thickness) {
      const parsedThickness = parseFloat(state.thickness);
      if (typeof parsedThickness !== "number" || !isFinite(parsedThickness)) {
        throw new Error(`Deserializing property ${parsedThickness} is not a number or is not finite.`);
      }
      this.tool.setThickness(parsedThickness);
    }
    if (state.mode) {
      const mode = state.mode;
      if (Object.values(EraserMode).includes(mode)) {
        this.tool.getModeValue().set(mode);
      }
    }
  }
};
EraserToolWidget.idCounter = 0;
var EraserToolWidget_default = EraserToolWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSeparator.mjs
var makeSeparator = (header = "") => {
  const container = document.createElement("div");
  container.classList.add("tool-dropdown-separator");
  container.innerText = header;
  return {
    addTo: (parent) => {
      parent.appendChild(container);
    }
  };
};
var makeSeparator_default = makeSeparator;

// node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeButtonGrid.mjs
var makeButtonGrid = (buttonSpecs, columnCount) => {
  const container = document.createElement("div");
  container.classList.add("toolbar-button-grid");
  container.style.setProperty("--column-count", `${columnCount}`);
  const makeButton = (buttonSpec) => {
    var _a6;
    const buttonElement = document.createElement("button");
    buttonElement.classList.add("button");
    const iconElement = buttonSpec.icon();
    iconElement.classList.add("icon");
    const labelElement = document.createElement("label");
    labelElement.textContent = buttonSpec.label;
    labelElement.classList.add("button-label-text");
    buttonElement.onclick = buttonSpec.onClick;
    if (buttonSpec.enabled) {
      buttonSpec.enabled.onUpdateAndNow((enabled) => {
        buttonElement.disabled = !enabled;
      });
    }
    buttonElement.replaceChildren(iconElement, labelElement);
    container.appendChild(buttonElement);
    addLongPressOrHoverCssClasses_default(buttonElement);
    (_a6 = buttonSpec.onCreated) == null ? void 0 : _a6.call(buttonSpec, buttonElement);
    return buttonElement;
  };
  buttonSpecs.map(makeButton);
  return {
    container
  };
};
var makeButtonGrid_default = makeButtonGrid;

// node_modules/js-draw/dist/mjs/toolbar/widgets/SelectionToolWidget.mjs
var makeFormatMenu = (editor, selectionTool, localizationTable) => {
  const container = document.createElement("div");
  container.classList.add("selection-format-menu", `${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}indentedList`);
  const colorRow = document.createElement("div");
  const colorLabel = document.createElement("label");
  const colorInputControl = makeColorInput_default(editor, (color) => {
    const selection = selectionTool.getSelection();
    if (selection) {
      const updateStyleCommands = [];
      for (const elem of selection.getSelectedObjects()) {
        if (isRestylableComponent(elem)) {
          updateStyleCommands.push(elem.updateStyle({ color }));
        }
      }
      const unitedCommand = uniteCommands_default(updateStyleCommands);
      editor.dispatch(unitedCommand);
    }
  });
  const { input: colorInput, container: colorInputContainer } = colorInputControl;
  colorLabel.innerText = localizationTable.colorLabel;
  const update = () => {
    const selection = selectionTool.getSelection();
    if (selection && selection.getSelectedItemCount() > 0) {
      colorInput.disabled = false;
      container.classList.remove("disabled");
      const colors = [];
      for (const elem of selection.getSelectedObjects()) {
        if (isRestylableComponent(elem)) {
          const color = elem.getStyle().color;
          if (color) {
            colors.push(color);
          }
        }
      }
      colorInputControl.setValue(Color4.average(colors));
    } else {
      colorInput.disabled = true;
      container.classList.add("disabled");
      colorInputControl.setValue(Color4.transparent);
    }
  };
  colorRow.replaceChildren(colorLabel, colorInputContainer);
  container.replaceChildren(colorRow);
  return {
    addTo: (parent) => {
      parent.appendChild(container);
    },
    update,
    registerHelpText: (helpDisplay) => {
      helpDisplay.registerTextHelpForElement(colorRow, localizationTable.selectionDropdown__changeColorHelpText);
      colorInputControl.registerWithHelpTextDisplay(helpDisplay);
    }
  };
};
var LassoSelectToggle = class extends BaseWidget_default {
  constructor(editor, tool, localizationTable) {
    super(editor, "selection-mode-toggle", localizationTable);
    this.tool = tool;
    editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
      if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === tool) {
        this.setSelected(tool.modeValue.get() === SelectionMode.Lasso);
      }
    });
    this.setSelected(false);
  }
  shouldAutoDisableInReadOnlyEditor() {
    return false;
  }
  setModeFlag(enabled) {
    this.tool.modeValue.set(enabled ? SelectionMode.Lasso : SelectionMode.Rectangle);
  }
  handleClick() {
    this.setModeFlag(!this.isSelected());
  }
  getTitle() {
    return this.localizationTable.selectionTool__lassoSelect;
  }
  createIcon() {
    return this.editor.icons.makeSelectionIcon(SelectionMode.Lasso);
  }
  fillDropdown(_dropdown) {
    return false;
  }
  getHelpText() {
    return this.localizationTable.selectionTool__lassoSelect__help;
  }
};
var SelectionToolWidget = class extends BaseToolWidget {
  constructor(editor, tool, localization4) {
    super(editor, tool, "selection-tool-widget", localization4);
    this.tool = tool;
    this.updateFormatMenu = () => {
    };
    this.addSubWidget(new LassoSelectToggle(editor, tool, this.localizationTable));
    const hasSelection = () => {
      const selection = this.tool.getSelection();
      return !!selection && selection.getSelectedItemCount() > 0;
    };
    this.hasSelectionValue = MutableReactiveValue.fromInitialValue(hasSelection());
    this.editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
      if (toolEvt.kind !== EditorEventType.ToolUpdated) {
        throw new Error("Invalid event type!");
      }
      if (toolEvt.tool === this.tool) {
        this.hasSelectionValue.set(hasSelection());
        this.updateFormatMenu();
      }
    });
    tool.modeValue.onUpdate(() => {
      this.updateIcon();
    });
  }
  resizeImageToSelection() {
    const selection = this.tool.getSelection();
    if (selection) {
      this.editor.dispatch(this.editor.setImportExportRect(selection.region));
    }
  }
  onKeyPress(event) {
    const shortcuts = this.editor.shortcuts;
    if (shortcuts.matchesShortcut(resizeImageToSelectionKeyboardShortcut, event)) {
      this.resizeImageToSelection();
      return true;
    }
    if (super.onKeyPress(event)) {
      return true;
    }
    return false;
  }
  getTitle() {
    return this.localizationTable.select;
  }
  createIcon() {
    return this.editor.icons.makeSelectionIcon(this.tool.modeValue.get());
  }
  getHelpText() {
    return this.localizationTable.selectionDropdown__baseHelpText;
  }
  createSelectionActions(helpDisplay) {
    const icons = this.editor.icons;
    const grid = makeButtonGrid_default([
      {
        icon: () => icons.makeDeleteSelectionIcon(),
        label: this.localizationTable.deleteSelection,
        onCreated: (button) => {
          helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(button, this.localizationTable.selectionDropdown__deleteHelpText);
        },
        onClick: () => {
          const selection = this.tool.getSelection();
          this.editor.dispatch(selection.deleteSelectedObjects());
          this.tool.clearSelection();
        },
        enabled: this.hasSelectionValue
      },
      {
        icon: () => icons.makeDuplicateSelectionIcon(),
        label: this.localizationTable.duplicateSelection,
        onCreated: (button) => {
          helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(button, this.localizationTable.selectionDropdown__duplicateHelpText);
        },
        onClick: async () => {
          const selection = this.tool.getSelection();
          const command = await (selection == null ? void 0 : selection.duplicateSelectedObjects());
          if (command) {
            this.editor.dispatch(command);
          }
        },
        enabled: this.hasSelectionValue
      },
      {
        icon: () => icons.makeResizeImageToSelectionIcon(),
        label: this.localizationTable.resizeImageToSelection,
        onCreated: (button) => {
          helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(button, this.localizationTable.selectionDropdown__resizeToHelpText);
        },
        onClick: () => {
          this.resizeImageToSelection();
        },
        enabled: this.hasSelectionValue
      }
    ], 3);
    return { container: grid.container };
  }
  fillDropdown(dropdown, helpDisplay) {
    super.fillDropdown(dropdown, helpDisplay);
    const controlsContainer = document.createElement("div");
    controlsContainer.classList.add(`${toolbarCSSPrefix}nonbutton-controls-main-list`);
    dropdown.appendChild(controlsContainer);
    makeSeparator_default().addTo(controlsContainer);
    const actions = this.createSelectionActions(helpDisplay);
    controlsContainer.appendChild(actions.container);
    makeSeparator_default(this.localizationTable.reformatSelection).addTo(controlsContainer);
    const formatMenu = makeFormatMenu(this.editor, this.tool, this.localizationTable);
    formatMenu.addTo(controlsContainer);
    this.updateFormatMenu = () => formatMenu.update();
    if (helpDisplay) {
      formatMenu.registerHelpText(helpDisplay);
    }
    formatMenu.update();
    return true;
  }
  serializeState() {
    return {
      ...super.serializeState(),
      selectionMode: this.tool.modeValue.get()
    };
  }
  deserializeFrom(state) {
    super.deserializeFrom(state);
    const isValidSelectionMode = Object.values(SelectionMode).includes(state.selectionMode);
    if (isValidSelectionMode) {
      this.tool.modeValue.set(state.selectionMode);
    }
  }
};

// node_modules/js-draw/dist/mjs/toolbar/widgets/TextToolWidget.mjs
var TextToolWidget = class _TextToolWidget extends BaseToolWidget {
  constructor(editor, tool, localization4) {
    super(editor, tool, "text-tool-widget", localization4);
    this.tool = tool;
    this.updateDropdownInputs = null;
    editor.notifier.on(EditorEventType.ToolUpdated, (evt) => {
      var _a6;
      if (evt.kind === EditorEventType.ToolUpdated && evt.tool === tool) {
        this.updateIcon();
        (_a6 = this.updateDropdownInputs) == null ? void 0 : _a6.call(this);
      }
    });
  }
  getTitle() {
    return this.targetTool.description;
  }
  createIcon() {
    const textStyle = this.tool.getTextStyle();
    return this.editor.icons.makeTextIcon(textStyle);
  }
  fillDropdown(dropdown) {
    var _a6;
    const container = document.createElement("div");
    container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
    const fontRow = document.createElement("div");
    const colorRow = document.createElement("div");
    const sizeRow = document.createElement("div");
    const fontInput = document.createElement("select");
    const fontLabel = document.createElement("label");
    const sizeInput = document.createElement("input");
    const sizeLabel = document.createElement("label");
    const { input: colorInput, container: colorInputContainer, setValue: setColorInputValue } = makeColorInput_default(this.editor, (color) => {
      this.tool.setColor(color);
    });
    const colorLabel = document.createElement("label");
    const fontsInInput = /* @__PURE__ */ new Set();
    const addFontToInput = (fontName) => {
      const option = document.createElement("option");
      option.value = fontName;
      option.textContent = fontName;
      fontInput.appendChild(option);
      fontsInInput.add(fontName);
    };
    sizeInput.setAttribute("type", "number");
    sizeInput.min = "1";
    sizeInput.max = "128";
    fontLabel.innerText = this.localizationTable.fontLabel;
    colorLabel.innerText = this.localizationTable.colorLabel;
    sizeLabel.innerText = this.localizationTable.textSize;
    colorInput.id = `${toolbarCSSPrefix}-text-color-input-${_TextToolWidget.idCounter++}`;
    colorLabel.setAttribute("for", colorInput.id);
    sizeInput.id = `${toolbarCSSPrefix}-text-size-input-${_TextToolWidget.idCounter++}`;
    sizeLabel.setAttribute("for", sizeInput.id);
    const defaultFonts = ((_a6 = this.editor.getCurrentSettings().text) == null ? void 0 : _a6.fonts) ?? [];
    for (const font of defaultFonts) {
      addFontToInput(font);
    }
    fontInput.classList.add("font-selector");
    fontInput.id = `${toolbarCSSPrefix}-text-font-input-${_TextToolWidget.idCounter++}`;
    fontLabel.setAttribute("for", fontInput.id);
    fontInput.onchange = () => {
      this.tool.setFontFamily(fontInput.value);
    };
    sizeInput.onchange = () => {
      const size = parseInt(sizeInput.value);
      if (!isNaN(size) && size > 0) {
        this.tool.setFontSize(size);
      }
    };
    colorRow.appendChild(colorLabel);
    colorRow.appendChild(colorInputContainer);
    fontRow.appendChild(fontLabel);
    fontRow.appendChild(fontInput);
    sizeRow.appendChild(sizeLabel);
    sizeRow.appendChild(sizeInput);
    this.updateDropdownInputs = () => {
      const style = this.tool.getTextStyle();
      setColorInputValue(style.renderingStyle.fill);
      if (!fontsInInput.has(style.fontFamily)) {
        addFontToInput(style.fontFamily);
      }
      fontInput.value = style.fontFamily;
      sizeInput.value = `${style.size}`;
    };
    this.updateDropdownInputs();
    container.replaceChildren(colorRow, sizeRow, fontRow);
    dropdown.appendChild(container);
    return true;
  }
  serializeState() {
    const textStyle = this.tool.getTextStyle();
    return {
      ...super.serializeState(),
      fontFamily: textStyle.fontFamily,
      textSize: textStyle.size,
      color: textStyle.renderingStyle.fill.toHexString()
    };
  }
  deserializeFrom(state) {
    if (state.fontFamily && typeof state.fontFamily === "string") {
      this.tool.setFontFamily(state.fontFamily);
    }
    if (state.color && typeof state.color === "string") {
      this.tool.setColor(Color4.fromHex(state.color));
    }
    if (state.textSize && typeof state.textSize === "number") {
      this.tool.setFontSize(state.textSize);
    }
    super.deserializeFrom(state);
  }
};
TextToolWidget.idCounter = 0;
var TextToolWidget_default = TextToolWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/HandToolWidget.mjs
var makeZoomControl = (localizationTable, editor, helpDisplay) => {
  const zoomLevelRow = document.createElement("div");
  const increaseButton = document.createElement("button");
  const decreaseButton = document.createElement("button");
  const resetViewButton = document.createElement("button");
  const zoomLevelDisplay = document.createElement("span");
  increaseButton.innerText = "+";
  decreaseButton.innerText = "-";
  resetViewButton.innerText = localizationTable.resetView;
  zoomLevelRow.replaceChildren(zoomLevelDisplay, increaseButton, decreaseButton, resetViewButton);
  zoomLevelRow.classList.add(`${toolbarCSSPrefix}zoomLevelEditor`);
  zoomLevelDisplay.classList.add("zoomDisplay");
  let lastZoom;
  const updateZoomDisplay = () => {
    let zoomLevel = editor.viewport.getScaleFactor() * 100;
    if (zoomLevel > 0.1) {
      zoomLevel = Math.round(zoomLevel * 10) / 10;
    } else {
      zoomLevel = Math.round(zoomLevel * 1e3) / 1e3;
    }
    if (zoomLevel !== lastZoom) {
      zoomLevelDisplay.textContent = localizationTable.zoomLevel(zoomLevel);
      lastZoom = zoomLevel;
    }
  };
  updateZoomDisplay();
  editor.notifier.on(EditorEventType.ViewportChanged, (event) => {
    if (event.kind === EditorEventType.ViewportChanged) {
      updateZoomDisplay();
      resetViewButton.disabled = event.newTransform.eq(Mat33.identity);
    }
  });
  const zoomBy = (factor) => {
    const screenCenter = editor.viewport.visibleRect.center;
    const transformUpdate = Mat33.scaling2D(factor, screenCenter);
    editor.dispatch(Viewport_default.transformBy(transformUpdate), false);
  };
  increaseButton.onclick = () => {
    zoomBy(5 / 4);
  };
  decreaseButton.onclick = () => {
    zoomBy(4 / 5);
  };
  resetViewButton.onclick = () => {
    const addToHistory = false;
    editor.dispatch(Viewport_default.transformBy(editor.viewport.canvasToScreenTransform.inverse()), addToHistory);
  };
  helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(increaseButton, localizationTable.handDropdown__zoomInHelpText);
  helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(decreaseButton, localizationTable.handDropdown__zoomOutHelpText);
  helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(resetViewButton, localizationTable.handDropdown__resetViewHelpText);
  helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(zoomLevelDisplay, localizationTable.handDropdown__zoomDisplayHelpText);
  return zoomLevelRow;
};
var HandModeWidget = class extends BaseWidget_default {
  constructor(editor, tool, flag, makeIcon, title, helpText, localizationTable) {
    super(editor, `pan-mode-${flag}`, localizationTable);
    this.tool = tool;
    this.flag = flag;
    this.makeIcon = makeIcon;
    this.title = title;
    this.helpText = helpText;
    editor.notifier.on(EditorEventType.ToolUpdated, (toolEvt) => {
      if (toolEvt.kind === EditorEventType.ToolUpdated && toolEvt.tool === tool) {
        const allEnabled = !!(tool.getMode() & PanZoomMode.SinglePointerGestures);
        this.setSelected(!!(tool.getMode() & flag) || allEnabled);
        this.setDisabled(allEnabled && flag !== PanZoomMode.SinglePointerGestures);
      }
    });
    this.setSelected(false);
  }
  shouldAutoDisableInReadOnlyEditor() {
    return false;
  }
  setModeFlag(enabled) {
    this.tool.setModeEnabled(this.flag, enabled);
  }
  handleClick() {
    this.setModeFlag(!this.isSelected());
  }
  getTitle() {
    return this.title;
  }
  createIcon() {
    return this.makeIcon();
  }
  fillDropdown(_dropdown) {
    return false;
  }
  getHelpText() {
    return this.helpText;
  }
};
var HandToolWidget = class _HandToolWidget extends BaseToolWidget {
  constructor(editor, tool, localizationTable) {
    const isGivenToolPrimary = editor.toolController.getPrimaryTools().includes(tool);
    const primaryTool = (isGivenToolPrimary ? tool : _HandToolWidget.getPrimaryHandTool(editor.toolController)) ?? tool;
    super(editor, primaryTool, "hand-tool-widget", localizationTable);
    this.overridePanZoomTool = (isGivenToolPrimary ? _HandToolWidget.getOverrideHandTool(editor.toolController) : tool) ?? tool;
    this.allowTogglingBaseTool = primaryTool !== null;
    if (!this.allowTogglingBaseTool) {
      this.container.classList.add("dropdownShowable");
    }
    const touchPanningWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoomMode.OneFingerTouchGestures, () => this.editor.icons.makeTouchPanningIcon(), localizationTable.touchPanning, localizationTable.handDropdown__touchPanningHelpText, localizationTable);
    const rotationLockWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoomMode.RotationLocked, () => this.editor.icons.makeRotationLockIcon(), localizationTable.lockRotation, localizationTable.handDropdown__lockRotationHelpText, localizationTable);
    this.addSubWidget(touchPanningWidget);
    this.addSubWidget(rotationLockWidget);
  }
  static getPrimaryHandTool(toolController) {
    const primaryPanZoomToolList = toolController.getPrimaryTools().filter((tool) => tool instanceof PanZoom);
    const primaryPanZoomTool = primaryPanZoomToolList[0];
    return primaryPanZoomTool;
  }
  static getOverrideHandTool(toolController) {
    const panZoomToolList = toolController.getMatchingTools(PanZoom);
    const panZoomTool = panZoomToolList[0];
    return panZoomTool;
  }
  shouldAutoDisableInReadOnlyEditor() {
    return false;
  }
  getTitle() {
    return this.localizationTable.handTool;
  }
  createIcon() {
    return this.editor.icons.makeHandToolIcon();
  }
  handleClick() {
    if (this.allowTogglingBaseTool) {
      super.handleClick();
    } else {
      this.setDropdownVisible(!this.isDropdownVisible());
    }
  }
  getHelpText() {
    return this.localizationTable.handDropdown__baseHelpText;
  }
  fillDropdown(dropdown, helpDisplay) {
    super.fillDropdown(dropdown, helpDisplay);
    const nonbuttonActionContainer = document.createElement("div");
    nonbuttonActionContainer.classList.add(`${toolbarCSSPrefix}nonbutton-controls-main-list`);
    makeSeparator_default().addTo(nonbuttonActionContainer);
    const zoomControl = makeZoomControl(this.localizationTable, this.editor, helpDisplay);
    nonbuttonActionContainer.appendChild(zoomControl);
    dropdown.appendChild(nonbuttonActionContainer);
    return true;
  }
  setSelected(selected) {
    if (this.allowTogglingBaseTool) {
      super.setSelected(selected);
    }
  }
  serializeState() {
    const toolMode = this.overridePanZoomTool.getMode();
    return {
      ...super.serializeState(),
      touchPanning: toolMode & PanZoomMode.OneFingerTouchGestures,
      rotationLocked: toolMode & PanZoomMode.RotationLocked
    };
  }
  deserializeFrom(state) {
    if (state.touchPanning !== void 0) {
      this.overridePanZoomTool.setModeEnabled(PanZoomMode.OneFingerTouchGestures, !!state.touchPanning);
    }
    if (state.rotationLocked !== void 0) {
      this.overridePanZoomTool.setModeEnabled(PanZoomMode.RotationLocked, !!state.rotationLocked);
    }
    super.deserializeFrom(state);
  }
};

// node_modules/js-draw/dist/mjs/toolbar/widgets/ActionButtonWidget.mjs
var __classPrivateFieldSet11 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet13 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ActionButtonWidget_autoDisableInReadOnlyEditors;
var _ActionButtonWidget_helpText;
var ActionButtonWidget = class extends BaseWidget_default {
  constructor(editor, id, makeIcon, title, clickAction, localizationTable, mustBeToplevel = false, autoDisableInReadOnlyEditors = true) {
    super(editor, id, localizationTable);
    this.makeIcon = makeIcon;
    this.title = title;
    this.clickAction = clickAction;
    this.mustBeToplevel = mustBeToplevel;
    _ActionButtonWidget_autoDisableInReadOnlyEditors.set(this, void 0);
    _ActionButtonWidget_helpText.set(this, void 0);
    __classPrivateFieldSet11(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, autoDisableInReadOnlyEditors, "f");
  }
  /**
   * Sets the text shown in a help overlay for this button.
   *
   * See {@link getHelpText}.
   */
  setHelpText(helpText) {
    __classPrivateFieldSet11(this, _ActionButtonWidget_helpText, helpText, "f");
  }
  getHelpText() {
    return __classPrivateFieldGet13(this, _ActionButtonWidget_helpText, "f");
  }
  shouldAutoDisableInReadOnlyEditor() {
    return __classPrivateFieldGet13(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, "f");
  }
  handleClick() {
    this.clickAction();
  }
  getTitle() {
    return this.title;
  }
  createIcon() {
    return this.makeIcon();
  }
  fillDropdown(_dropdown) {
    return false;
  }
  mustBeInToplevelMenu() {
    return this.mustBeToplevel;
  }
};
_ActionButtonWidget_autoDisableInReadOnlyEditors = /* @__PURE__ */ new WeakMap(), _ActionButtonWidget_helpText = /* @__PURE__ */ new WeakMap();
var ActionButtonWidget_default = ActionButtonWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeFileInput.mjs
var idCounter4 = 0;
var makeFileInput = (labelText, context, { accepts = "*", allowMultiSelect = false, customPickerAction } = {}) => {
  const container = document.createElement("div");
  const label = document.createElement("label");
  const input = document.createElement("input");
  const descriptionBox = document.createElement("div");
  descriptionBox.classList.add("toolbar--file-input-description");
  const descriptionText = document.createElement("span");
  container.classList.add("toolbar--file-input-container");
  label.appendChild(document.createTextNode(labelText));
  input.accept = accepts;
  input.type = customPickerAction ? "button" : "file";
  input.classList.add("file-input");
  input.multiple = allowMultiSelect;
  const inputId = `js-draw-file-input-${idCounter4++}`;
  input.setAttribute("id", inputId);
  label.htmlFor = inputId;
  const icon = context.icons.makeUploadFileIcon();
  icon.classList.add("icon");
  descriptionBox.replaceChildren(icon, descriptionText);
  label.appendChild(descriptionBox);
  container.replaceChildren(label, input);
  const selectedFiles = ReactiveValue_default.fromInitialValue([]);
  let loading = false;
  let cancelLoading = null;
  const updateStatusText = () => {
    const files = selectedFiles.get();
    if (loading) {
      descriptionText.textContent = context.localization.fileInput__loading;
      if (cancelLoading) {
        const cancelText = document.createElement("b");
        cancelText.textContent = context.localization.cancel;
        cancelText.classList.add("cancel-button");
        descriptionText.appendChild(cancelText);
      }
      icon.style.display = "none";
    } else if (files.length > 0) {
      const fileNames = files.map((file) => file.name);
      const maxNames = 5;
      if (fileNames.length <= maxNames) {
        descriptionText.textContent = fileNames.join("\n");
      } else {
        const fileNamesToShow = fileNames.slice(0, maxNames - 1);
        descriptionText.textContent = [
          ...fileNamesToShow,
          context.localization.fileInput__andNMoreFiles(fileNames.length - fileNamesToShow.length)
        ].join("\n");
      }
      icon.style.display = "none";
    } else {
      icon.style.display = "";
      const text = context.localization.dragAndDropHereOrBrowse;
      const segments = text.split(/[{]{2}(.*)[}]{2}/g);
      descriptionText.replaceChildren();
      for (let i = 0; i < segments.length; i++) {
        if (i % 2 === 1) {
          const boldedText = document.createElement("b");
          boldedText.textContent = segments[i];
          descriptionText.appendChild(boldedText);
        } else {
          descriptionText.appendChild(document.createTextNode(segments[i]));
        }
      }
    }
  };
  const addFileEventListeners = () => {
    label.addEventListener("dragover", (event) => {
      event.preventDefault();
      label.classList.add("drag-target");
    });
    label.addEventListener("dragenter", (event) => {
      event.preventDefault();
      label.classList.add("drag-target");
    });
    label.addEventListener("dragleave", (event) => {
      event.preventDefault();
      const enteringElement = event.relatedTarget;
      if (!enteringElement || !label.contains(enteringElement)) {
        label.classList.remove("drag-target");
      }
    });
    label.addEventListener("drop", (event) => {
      event.preventDefault();
      label.classList.remove("drag-target");
      const fileList = [];
      if (event.dataTransfer) {
        fileList.push(...event.dataTransfer.files);
      }
      selectedFiles.set(fileList);
    });
    input.addEventListener("change", () => {
      const fileList = input.files ?? [];
      selectedFiles.set([...fileList]);
    });
  };
  addFileEventListeners();
  if (customPickerAction) {
    const promptForFiles = async () => {
      if (loading) {
        cancelLoading == null ? void 0 : cancelLoading();
        return;
      }
      container.classList.add("-loading");
      loading = true;
      updateStatusText();
      try {
        const data = await customPickerAction({
          setOnCancelCallback: (onCancel) => {
            if (!loading) {
              throw new Error("Task already completed. Can't register cancel handler.");
            }
            cancelLoading = () => {
              cancelLoading = null;
              updateStatusText();
              onCancel();
            };
            updateStatusText();
          }
        });
        if (data) {
          selectedFiles.set(data);
        }
      } finally {
        container.classList.remove("-loading");
        loading = false;
        updateStatusText();
      }
    };
    input.onclick = promptForFiles;
  }
  selectedFiles.onUpdate((files) => {
    if (files.length === 0 && input.files && input.files.length > 0) {
      input.value = "";
    }
    cancelLoading == null ? void 0 : cancelLoading();
  });
  selectedFiles.onUpdateAndNow(updateStatusText);
  return {
    container,
    input,
    selectedFiles,
    addTo: (parent) => {
      parent.appendChild(container);
    }
  };
};
var makeFileInput_default = makeFileInput;

// node_modules/js-draw/dist/mjs/util/bytesToSizeString.mjs
var bytesToSizeString = (sizeBytes) => {
  const sizeInKiB = sizeBytes / 1024;
  const sizeInMiB = sizeInKiB / 1024;
  const sizeInGiB = sizeInMiB / 1024;
  let units = "B";
  let size = sizeBytes;
  if (sizeInGiB >= 1) {
    size = sizeInGiB;
    units = "GiB";
  } else if (sizeInMiB >= 1) {
    size = sizeInMiB;
    units = "MiB";
  } else if (sizeInKiB >= 1) {
    size = sizeInKiB;
    units = "KiB";
  }
  return { size, units };
};
var bytesToSizeString_default = bytesToSizeString;

// node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/ImageWrapper.mjs
var ImageWrapper = class _ImageWrapper {
  constructor(imageBase64Url, preview, onUrlUpdate) {
    this.imageBase64Url = imageBase64Url;
    this.preview = preview;
    this.onUrlUpdate = onUrlUpdate;
    this.originalSrc = imageBase64Url;
    preview.src = imageBase64Url;
  }
  updateImageData(base64DataUrl) {
    this.preview.src = base64DataUrl;
    this.imageBase64Url = base64DataUrl;
    this.onUrlUpdate();
  }
  decreaseSize(resizeFactor = 3 / 4) {
    var _a6;
    const canvas = document.createElement("canvas");
    canvas.width = this.preview.naturalWidth * resizeFactor;
    canvas.height = this.preview.naturalHeight * resizeFactor;
    const ctx = canvas.getContext("2d");
    ctx == null ? void 0 : ctx.drawImage(this.preview, 0, 0, canvas.width, canvas.height);
    const format = ((_a6 = this.originalSrc) == null ? void 0 : _a6.startsWith("data:image/jpeg;")) ? "image/jpeg" : "image/png";
    this.updateImageData(canvas.toDataURL(format));
  }
  reset() {
    this.updateImageData(this.originalSrc);
  }
  isChanged() {
    return this.imageBase64Url !== this.originalSrc;
  }
  // Returns true if the current image is large enough to display a "decrease size"
  // option.
  isLarge() {
    const largeImageThreshold = 0.12 * 1024 * 1024;
    return this.getBase64Url().length > largeImageThreshold;
  }
  getBase64Url() {
    return this.imageBase64Url;
  }
  getAltText() {
    return this.altText;
  }
  setAltText(text) {
    this.altText = text;
    this.preview.alt = text;
  }
  static fromSrcAndPreview(initialBase64Src, preview, onUrlUpdate) {
    return new _ImageWrapper(initialBase64Src, preview, onUrlUpdate);
  }
  static fromRenderable(renderable, onUrlUpdate) {
    const preview = new Image();
    preview.src = renderable.base64Url;
    const result = new _ImageWrapper(renderable.base64Url, preview, onUrlUpdate);
    const altText = renderable.label ?? renderable.image.getAttribute("alt");
    if (altText) {
      result.setAltText(altText);
    }
    return { wrapper: result, preview };
  }
};

// node_modules/js-draw/dist/mjs/toolbar/widgets/components/makeSnappedList.mjs
var makeSnappedList = (itemsValue) => {
  const container = document.createElement("div");
  container.classList.add("toolbar-snapped-scroll-list");
  const scroller = document.createElement("div");
  scroller.classList.add("scroller");
  const visibleIndex = MutableReactiveValue.fromInitialValue(0);
  let observer = null;
  const makePageMarkers = () => {
    const markerContainer = document.createElement("div");
    markerContainer.classList.add("page-markers");
    markerContainer.setAttribute("tabindex", "-1");
    const markers = [];
    const pairedItems = ReactiveValue.union([
      visibleIndex,
      itemsValue
    ]);
    pairedItems.onUpdateAndNow(([currentVisibleIndex, items]) => {
      let addedOrRemovedMarkers = false;
      while (items.length < markers.length) {
        markers.pop();
        addedOrRemovedMarkers = true;
      }
      let activeMarker;
      for (let i = 0; i < items.length; i++) {
        let marker;
        if (i >= markers.length) {
          marker = document.createElement("div");
          const content = document.createElement("div");
          content.classList.add("content");
          marker.replaceChildren(content);
          markers.push(marker);
          addedOrRemovedMarkers = true;
        } else {
          marker = markers[i];
        }
        marker.classList.add("marker");
        if (i === currentVisibleIndex) {
          marker.classList.add("-active");
          activeMarker = marker;
        } else {
          marker.classList.remove("-active");
        }
        const markerIndex = i;
        marker.onclick = () => {
          var _a6, _b2;
          (_b2 = (_a6 = wrappedItems.get()[markerIndex]) == null ? void 0 : _a6.element) == null ? void 0 : _b2.scrollIntoView({ block: "nearest", behavior: "smooth" });
        };
      }
      if (addedOrRemovedMarkers) {
        markerContainer.replaceChildren(...markers);
      }
      if (activeMarker && markerContainer.scrollHeight > container.clientHeight) {
        activeMarker.scrollIntoView({ block: "nearest" });
      }
      if (markers.length === 1) {
        markerContainer.classList.add("-one-element");
      } else {
        markerContainer.classList.remove("-one-element");
      }
    });
    return markerContainer;
  };
  const createObserver = () => {
    observer = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting && entry.intersectionRatio > 0.7) {
          const indexString = entry.target.getAttribute("data-item-index");
          if (indexString === null)
            throw new Error("Could not find attribute data-item-index");
          const index = Number(indexString);
          visibleIndex.set(index);
          break;
        }
      }
    }, {
      // Element to use as the boudning box with which to intersect.
      // See https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      root: scroller,
      // Fraction of an element that must be visible to trigger the callback:
      threshold: 0.9
    });
  };
  const destroyObserver = () => {
    if (observer) {
      observer.disconnect();
      visibleIndex.set(0);
      observer = null;
    }
  };
  const wrappedItems = ReactiveValue.map(itemsValue, (items) => {
    return items.map((item, index) => {
      const wrapper = document.createElement("div");
      if (item.element.parentElement)
        item.element.remove();
      wrapper.appendChild(item.element);
      wrapper.classList.add("item");
      wrapper.setAttribute("data-item-index", `${index}`);
      return {
        element: wrapper,
        data: item.data
      };
    });
  });
  const lastItems = [];
  wrappedItems.onUpdateAndNow((items) => {
    visibleIndex.set(-1);
    for (const item of lastItems) {
      observer == null ? void 0 : observer.unobserve(item.element);
    }
    scroller.replaceChildren();
    if (items.length > 1) {
      createObserver();
    } else {
      destroyObserver();
    }
    if (items.length === 0) {
      container.classList.add("-empty");
    } else {
      container.classList.remove("-empty");
    }
    for (const item of items) {
      scroller.appendChild(item.element);
    }
    visibleIndex.set(0);
    if (observer) {
      for (const item of items) {
        observer.observe(item.element);
      }
    }
  });
  const visibleItem = ReactiveValue.map(visibleIndex, (index) => {
    const values = itemsValue.get();
    if (0 <= index && index < values.length) {
      return values[index].data;
    }
    return null;
  });
  stopPropagationOfScrollingWheelEvents_default(scroller);
  container.replaceChildren(makePageMarkers(), scroller);
  return {
    container,
    visibleItem
  };
};
var makeSnappedList_default = makeSnappedList;

// node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/fileToImages.mjs
var fileToImages = async (imageFile) => {
  const result = [];
  const imageElement = new Image();
  const base64Url = await fileToBase64Url_default(imageFile);
  if (base64Url) {
    result.push({
      image: imageElement,
      base64Url,
      transform: Mat33.identity
    });
  }
  return result;
};
var fileToImages_default = fileToImages;

// node_modules/js-draw/dist/mjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.mjs
var InsertImageWidget = class _InsertImageWidget extends BaseWidget_default {
  constructor(editor, localization4) {
    localization4 ?? (localization4 = editor.localization);
    super(editor, "insert-image-widget", localization4);
    this.container.classList.add("dropdownShowable");
    editor.notifier.on(EditorEventType.SelectionUpdated, (event) => {
      if (event.kind === EditorEventType.SelectionUpdated && this.isDropdownVisible()) {
        this.updateInputs();
      }
    });
    this.images = MutableReactiveValue.fromInitialValue([]);
    this.images.onUpdateAndNow(() => {
      this.onImageDataUpdate();
    });
  }
  getTitle() {
    return this.localizationTable.image;
  }
  createIcon() {
    return this.editor.icons.makeInsertImageIcon();
  }
  setDropdownVisible(visible) {
    var _a6;
    super.setDropdownVisible(visible);
    if (this.isDropdownVisible()) {
      this.updateInputs();
    } else {
      (_a6 = this.selectedFiles) == null ? void 0 : _a6.set([]);
    }
  }
  handleClick() {
    this.setDropdownVisible(!this.isDropdownVisible());
  }
  fillDropdown(dropdown) {
    var _a6;
    const container = document.createElement("div");
    container.classList.add("insert-image-widget-dropdown-content", `${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`);
    const { container: chooseImageRow, selectedFiles } = makeFileInput_default(this.localizationTable.chooseFile, this.editor, {
      accepts: "image/*",
      allowMultiSelect: true,
      customPickerAction: (_a6 = this.editor.getCurrentSettings().image) == null ? void 0 : _a6.showImagePicker
    });
    const altTextRow = document.createElement("div");
    this.imagesPreview = makeSnappedList_default(this.images);
    this.statusView = document.createElement("div");
    const actionButtonRow = document.createElement("div");
    actionButtonRow.classList.add("action-button-row");
    this.statusView.classList.add("insert-image-image-status-view");
    this.submitButton = document.createElement("button");
    this.selectedFiles = selectedFiles;
    this.imageAltTextInput = document.createElement("input");
    const imageAltTextLabel = document.createElement("label");
    const altTextInputId = `insert-image-alt-text-input-${_InsertImageWidget.nextInputId++}`;
    this.imageAltTextInput.setAttribute("id", altTextInputId);
    imageAltTextLabel.htmlFor = altTextInputId;
    imageAltTextLabel.innerText = this.localizationTable.inputAltText;
    this.imageAltTextInput.type = "text";
    this.imageAltTextInput.placeholder = this.localizationTable.describeTheImage;
    this.statusView.setAttribute("aria-live", "polite");
    this.submitButton.innerText = this.localizationTable.submit;
    this.imagesPreview.visibleItem.onUpdateAndNow(() => this.onImageDataUpdate());
    this.imageAltTextInput.oninput = () => {
      const currentImage = this.imagesPreview.visibleItem.get();
      if (currentImage) {
        currentImage.setAltText(this.imageAltTextInput.value);
        this.submitButton.style.display = "";
      }
    };
    this.selectedFiles.onUpdateAndNow(async (files) => {
      if (files.length === 0) {
        this.images.set([]);
        return;
      }
      const previews = (await Promise.all(files.map(async (imageFile) => {
        let renderableImages;
        try {
          renderableImages = await fileToImages_default(imageFile);
        } catch (error) {
          console.error("Image load error", error);
          const errorMessage = this.localizationTable.imageLoadError(error);
          this.statusView.innerText = errorMessage;
          return [];
        }
        return renderableImages.map((image) => {
          const { wrapper, preview } = ImageWrapper.fromRenderable(image, () => this.onImageDataUpdate());
          return {
            data: wrapper,
            element: preview
          };
        });
      }))).flat();
      this.images.set(previews);
    });
    altTextRow.replaceChildren(imageAltTextLabel, this.imageAltTextInput);
    actionButtonRow.replaceChildren(this.submitButton);
    container.replaceChildren(chooseImageRow, altTextRow, this.imagesPreview.container, this.statusView, actionButtonRow);
    dropdown.replaceChildren(container);
    return true;
  }
  onImageDataUpdate() {
    if (!this.imagesPreview)
      return;
    const currentImage = this.imagesPreview.visibleItem.get();
    const base64Data = currentImage == null ? void 0 : currentImage.getBase64Url();
    this.imageAltTextInput.value = (currentImage == null ? void 0 : currentImage.getAltText()) ?? "";
    if (base64Data) {
      this.submitButton.disabled = false;
      this.submitButton.style.display = "";
      this.updateImageSizeDisplay();
    } else {
      this.submitButton.disabled = true;
      this.submitButton.style.display = "none";
      this.statusView.innerText = "";
      this.submitButton.disabled = true;
    }
    if (this.images.get().length <= 1) {
      this.submitButton.innerText = this.localizationTable.submit;
    } else {
      this.submitButton.innerText = this.localizationTable.addAll;
    }
  }
  hideDialog() {
    this.setDropdownVisible(false);
  }
  updateImageSizeDisplay() {
    const currentImage = this.imagesPreview.visibleItem.get();
    const imageData = (currentImage == null ? void 0 : currentImage.getBase64Url()) ?? "";
    const { size, units } = bytesToSizeString_default(imageData.length);
    const sizeText = document.createElement("span");
    sizeText.innerText = this.localizationTable.imageSize(Math.round(size), units);
    const decreaseSizeButton = document.createElement("button");
    decreaseSizeButton.innerText = this.localizationTable.decreaseImageSize;
    decreaseSizeButton.onclick = () => {
      currentImage == null ? void 0 : currentImage.decreaseSize();
    };
    const resetSizeButton = document.createElement("button");
    resetSizeButton.innerText = this.localizationTable.resetImage;
    resetSizeButton.onclick = () => {
      currentImage == null ? void 0 : currentImage.reset();
    };
    this.statusView.replaceChildren(sizeText);
    if (currentImage == null ? void 0 : currentImage.isLarge()) {
      this.statusView.appendChild(decreaseSizeButton);
    } else if (currentImage == null ? void 0 : currentImage.isChanged()) {
      this.statusView.appendChild(resetSizeButton);
    } else {
      const hasLargeOrChangedImages = this.images.get().some((image) => {
        var _a6, _b2;
        return ((_a6 = image.data) == null ? void 0 : _a6.isChanged()) || ((_b2 = image.data) == null ? void 0 : _b2.isLarge());
      });
      if (hasLargeOrChangedImages) {
        decreaseSizeButton.disabled = true;
        this.statusView.appendChild(decreaseSizeButton);
      }
    }
  }
  updateInputs() {
    const resetInputs = () => {
      var _a6;
      (_a6 = this.selectedFiles) == null ? void 0 : _a6.set([]);
      this.imageAltTextInput.value = "";
      this.submitButton.disabled = true;
      this.statusView.innerText = "";
      this.submitButton.style.display = "";
    };
    resetInputs();
    const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool);
    const selectedObjects = selectionTools.map((tool) => tool.getSelectedObjects()).flat();
    let editingImage = null;
    if (selectedObjects.length === 1 && selectedObjects[0] instanceof ImageComponent) {
      editingImage = selectedObjects[0];
      const image = new Image();
      const imageWrapper = ImageWrapper.fromSrcAndPreview(editingImage.getURL(), image, () => this.onImageDataUpdate());
      imageWrapper.setAltText(editingImage.getAltText() ?? "");
      this.images.set([{ data: imageWrapper, element: image }]);
    } else if (selectedObjects.length > 0) {
      selectionTools.forEach((tool) => tool.clearSelection());
    }
    this.submitButton.style.display = "none";
    this.submitButton.onclick = async () => {
      var _a6;
      const newComponents = [];
      let transform = Mat33.identity;
      let fullBBox = null;
      for (const { data: imageWrapper } of this.images.get()) {
        if (!imageWrapper) {
          continue;
        }
        const image = new Image();
        image.src = imageWrapper.getBase64Url();
        const altText = imageWrapper.getAltText();
        if (altText) {
          image.setAttribute("alt", altText);
        }
        let component;
        try {
          component = await ImageComponent.fromImage(image, transform);
        } catch (error) {
          console.error("Error loading image", error);
          this.statusView.innerText = this.localizationTable.imageLoadError(error);
          return;
        }
        const componentBBox = component.getBBox();
        if (componentBBox.area === 0) {
          this.statusView.innerText = this.localizationTable.errorImageHasZeroSize;
          return;
        }
        newComponents.push(component);
        fullBBox ?? (fullBBox = componentBBox);
        fullBBox.union(componentBBox);
        const shift = Vec2.of(0, componentBBox.height);
        transform = transform.rightMul(Mat33.translation(shift));
      }
      if (newComponents.length) {
        if (!fullBBox) {
          throw new Error("Logic error: Full bounding box must be calculated when components are to be added.");
        }
        this.hideDialog();
        if (editingImage) {
          const eraseCommand = new Erase_default([editingImage]);
          const originalTransform = editingImage.getTransformation();
          const originalWidth = editingImage.getBBox().width || 1;
          const newWidth = fullBBox.transformedBoundingBox(originalTransform).width || 1;
          const widthAdjustTransform = Mat33.scaling2D(originalWidth / newWidth);
          const commands = [];
          for (const component of newComponents) {
            commands.push(EditorImage_default.addComponent(component), component.transformBy(originalTransform.rightMul(widthAdjustTransform)), component.setZIndex(editingImage.getZIndex()));
          }
          this.editor.dispatch(uniteCommands_default([...commands, eraseCommand]));
          (_a6 = selectionTools[0]) == null ? void 0 : _a6.setSelection(newComponents);
        } else {
          await this.editor.addAndCenterComponents(newComponents);
        }
      }
    };
  }
};
InsertImageWidget.nextInputId = 0;
var InsertImageWidget_default = InsertImageWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/DocumentPropertiesWidget.mjs
var DocumentPropertiesWidget = class _DocumentPropertiesWidget extends BaseWidget_default {
  constructor(editor, localizationTable) {
    super(editor, "document-properties-widget", localizationTable);
    this.updateDropdownContent = () => {
    };
    this.dropdownUpdateQueued = false;
    this.container.classList.add("dropdownShowable");
    this.editor.notifier.on(EditorEventType.UndoRedoStackUpdated, () => {
      this.queueDropdownUpdate();
    });
    this.editor.image.notifier.on(EditorImageEventType.ExportViewportChanged, () => {
      this.queueDropdownUpdate();
    });
  }
  getTitle() {
    return this.localizationTable.documentProperties;
  }
  createIcon() {
    return this.editor.icons.makeConfigureDocumentIcon();
  }
  handleClick() {
    this.setDropdownVisible(!this.isDropdownVisible());
    this.queueDropdownUpdate();
  }
  queueDropdownUpdate() {
    if (!this.dropdownUpdateQueued) {
      requestAnimationFrame(() => this.updateDropdown());
      this.dropdownUpdateQueued = true;
    }
  }
  updateDropdown() {
    this.dropdownUpdateQueued = false;
    if (this.isDropdownVisible()) {
      this.updateDropdownContent();
    }
  }
  setBackgroundColor(color) {
    this.editor.dispatch(this.editor.setBackgroundColor(color));
  }
  getBackgroundColor() {
    return this.editor.estimateBackgroundColor();
  }
  removeBackgroundComponents() {
    const previousBackgrounds = [];
    for (const component of this.editor.image.getBackgroundComponents()) {
      if (component instanceof BackgroundComponent) {
        previousBackgrounds.push(component);
      }
    }
    return new Erase_default(previousBackgrounds);
  }
  /** Replace existing background components with a background of the given type. */
  setBackgroundType(backgroundType) {
    const prevBackgroundColor = this.editor.estimateBackgroundColor();
    const newBackground = new BackgroundComponent(backgroundType, prevBackgroundColor);
    const addBackgroundCommand = this.editor.image.addComponent(newBackground);
    return uniteCommands_default([this.removeBackgroundComponents(), addBackgroundCommand]);
  }
  /** Returns the type of the topmost background component */
  getBackgroundType() {
    const backgroundComponents = this.editor.image.getBackgroundComponents();
    for (let i = backgroundComponents.length - 1; i >= 0; i--) {
      const component = backgroundComponents[i];
      if (component instanceof BackgroundComponent) {
        return component.getBackgroundType();
      }
    }
    return BackgroundType.None;
  }
  updateImportExportRectSize(size) {
    const filterDimension = (dim) => {
      if (dim !== void 0 && (!isFinite(dim) || dim <= 0)) {
        dim = 100;
      }
      return dim;
    };
    const width = filterDimension(size.width);
    const height = filterDimension(size.height);
    const currentRect = this.editor.getImportExportRect();
    const newRect = new Rect2(currentRect.x, currentRect.y, width ?? currentRect.w, height ?? currentRect.h);
    this.editor.dispatch(this.editor.image.setImportExportRect(newRect));
    this.editor.queueRerender();
  }
  getHelpText() {
    return this.localizationTable.pageDropdown__baseHelpText;
  }
  fillDropdown(dropdown, helpDisplay) {
    const container = document.createElement("div");
    container.classList.add(`${toolbarCSSPrefix}spacedList`, `${toolbarCSSPrefix}nonbutton-controls-main-list`, `${toolbarCSSPrefix}document-properties-widget`);
    const makeBackgroundColorInput = () => {
      const backgroundColorRow2 = document.createElement("div");
      const backgroundColorLabel = document.createElement("label");
      backgroundColorLabel.innerText = this.localizationTable.backgroundColor;
      const { input: colorInput, container: backgroundColorInputContainer, setValue: setBgColorInputValue2, registerWithHelpTextDisplay: registerHelpForInputs } = makeColorInput_default(this.editor, (color) => {
        if (!color.eq(this.getBackgroundColor())) {
          this.setBackgroundColor(color);
        }
      });
      colorInput.id = `${toolbarCSSPrefix}docPropertiesColorInput-${_DocumentPropertiesWidget.idCounter++}`;
      backgroundColorLabel.htmlFor = colorInput.id;
      backgroundColorRow2.replaceChildren(backgroundColorLabel, backgroundColorInputContainer);
      const registerWithHelp = (helpDisplay2) => {
        if (!helpDisplay2) {
          return;
        }
        helpDisplay2 == null ? void 0 : helpDisplay2.registerTextHelpForElement(backgroundColorRow2, this.localizationTable.pageDropdown__backgroundColorHelpText);
        registerHelpForInputs(helpDisplay2);
      };
      return { setBgColorInputValue: setBgColorInputValue2, backgroundColorRow: backgroundColorRow2, registerWithHelp };
    };
    const { backgroundColorRow, setBgColorInputValue, registerWithHelp: registerBackgroundRowWithHelp } = makeBackgroundColorInput();
    const makeCheckboxRow = (labelText, onChange) => {
      const rowContainer = document.createElement("div");
      const labelElement = document.createElement("label");
      const checkboxElement = document.createElement("input");
      checkboxElement.id = `${toolbarCSSPrefix}docPropertiesCheckbox-${_DocumentPropertiesWidget.idCounter++}`;
      labelElement.htmlFor = checkboxElement.id;
      checkboxElement.type = "checkbox";
      labelElement.innerText = labelText;
      checkboxElement.oninput = () => {
        onChange(checkboxElement.checked);
      };
      rowContainer.replaceChildren(labelElement, checkboxElement);
      return { container: rowContainer, checkbox: checkboxElement };
    };
    const { container: useGridRow, checkbox: useGridCheckbox } = makeCheckboxRow(this.localizationTable.useGridOption, (checked) => {
      const prevBackgroundType = this.getBackgroundType();
      const wasGrid = prevBackgroundType === BackgroundType.Grid;
      if (wasGrid === checked) {
        return;
      }
      let newBackgroundType = BackgroundType.SolidColor;
      if (checked) {
        newBackgroundType = BackgroundType.Grid;
      }
      this.editor.dispatch(this.setBackgroundType(newBackgroundType));
    });
    const addDimensionRow = (labelContent, onChange) => {
      const row = document.createElement("div");
      const label = document.createElement("label");
      const input = document.createElement("input");
      label.innerText = labelContent;
      input.type = "number";
      input.min = "0";
      input.id = `${toolbarCSSPrefix}docPropertiesDimensionRow-${_DocumentPropertiesWidget.idCounter++}`;
      label.htmlFor = input.id;
      input.style.flexGrow = "2";
      input.style.width = "25px";
      input.oninput = () => {
        onChange(parseFloat(input.value));
      };
      row.classList.add("js-draw-size-input-row");
      row.replaceChildren(label, input);
      return {
        setValue: (value) => {
          if (document.activeElement === input && input.value.match(/^0*$/)) {
            const originalValue = input.value;
            input.type = "text";
            input.value = value.toString();
            const lengthToSelect = Math.max(1, input.value.length - originalValue.length);
            input.setSelectionRange(0, lengthToSelect);
            input.type = "number";
          } else {
            input.value = value.toString();
          }
        },
        setIsAutomaticSize: (automatic) => {
          input.disabled = automatic;
          const automaticSizeClass = "size-input-row--automatic-size";
          if (automatic) {
            row.classList.add(automaticSizeClass);
          } else {
            row.classList.remove(automaticSizeClass);
          }
        },
        element: row
      };
    };
    const imageWidthRow = addDimensionRow(this.localizationTable.imageWidthOption, (value) => {
      this.updateImportExportRectSize({ width: value });
    });
    const imageHeightRow = addDimensionRow(this.localizationTable.imageHeightOption, (value) => {
      this.updateImportExportRectSize({ height: value });
    });
    const { container: auroresizeRow, checkbox: autoresizeCheckbox } = makeCheckboxRow(this.localizationTable.enableAutoresizeOption, (checked) => {
      const image = this.editor.image;
      this.editor.dispatch(image.setAutoresizeEnabled(checked));
    });
    const aboutButton = document.createElement("button");
    aboutButton.classList.add("about-button");
    aboutButton.innerText = this.localizationTable.about;
    aboutButton.onclick = () => {
      this.editor.showAboutDialog();
    };
    registerBackgroundRowWithHelp(helpDisplay);
    helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(useGridRow, this.localizationTable.pageDropdown__gridCheckboxHelpText);
    helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(auroresizeRow, this.localizationTable.pageDropdown__autoresizeCheckboxHelpText);
    helpDisplay == null ? void 0 : helpDisplay.registerTextHelpForElement(aboutButton, this.localizationTable.pageDropdown__aboutButtonHelpText);
    this.updateDropdownContent = () => {
      setBgColorInputValue(this.getBackgroundColor());
      const autoresize = this.editor.image.getAutoresizeEnabled();
      const importExportRect = this.editor.getImportExportRect();
      imageWidthRow.setValue(importExportRect.width);
      imageHeightRow.setValue(importExportRect.height);
      autoresizeCheckbox.checked = autoresize;
      imageWidthRow.setIsAutomaticSize(autoresize);
      imageHeightRow.setIsAutomaticSize(autoresize);
      useGridCheckbox.checked = this.getBackgroundType() === BackgroundType.Grid;
    };
    this.updateDropdownContent();
    container.replaceChildren(backgroundColorRow, useGridRow, imageWidthRow.element, imageHeightRow.element, auroresizeRow, aboutButton);
    dropdown.replaceChildren(container);
    return true;
  }
};
DocumentPropertiesWidget.idCounter = 0;
var DocumentPropertiesWidget_default = DocumentPropertiesWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/SaveActionWidget.mjs
var SaveActionWidget = class extends ActionButtonWidget_default {
  constructor(editor, localization4, saveCallback, labelOverride = {}) {
    super(
      editor,
      "save-button",
      // Creates an icon
      () => {
        return labelOverride.icon ?? editor.icons.makeSaveIcon();
      },
      labelOverride.label ?? localization4.save,
      saveCallback
    );
    this.setTags([ToolbarWidgetTag.Save]);
  }
  shouldAutoDisableInReadOnlyEditor() {
    return false;
  }
  onKeyPress(event) {
    if (this.editor.shortcuts.matchesShortcut(saveKeyboardShortcut, event)) {
      this.clickAction();
      return true;
    }
    return super.onKeyPress(event);
  }
  mustBeInToplevelMenu() {
    return true;
  }
};
var SaveActionWidget_default = SaveActionWidget;

// node_modules/js-draw/dist/mjs/toolbar/widgets/ExitActionWidget.mjs
var ExitActionWidget = class extends ActionButtonWidget_default {
  constructor(editor, localization4, saveCallback, labelOverride = {}) {
    super(
      editor,
      "exit-button",
      // Creates an icon
      () => {
        return labelOverride.icon ?? editor.icons.makeCloseIcon();
      },
      labelOverride.label ?? localization4.exit,
      saveCallback
    );
    this.setTags([ToolbarWidgetTag.Exit]);
  }
  shouldAutoDisableInReadOnlyEditor() {
    return false;
  }
  onKeyPress(event) {
    if (this.editor.shortcuts.matchesShortcut(exitKeyboardShortcut, event)) {
      this.clickAction();
      return true;
    }
    return super.onKeyPress(event);
  }
  mustBeInToplevelMenu() {
    return true;
  }
};
var ExitActionWidget_default = ExitActionWidget;

// node_modules/js-draw/dist/mjs/toolbar/AbstractToolbar.mjs
var __classPrivateFieldGet14 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet12 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AbstractToolbar_listeners;
var _AbstractToolbar_widgetsById;
var _AbstractToolbar_widgetList;
var _AbstractToolbar_updateColoris;
var AbstractToolbar = class _AbstractToolbar {
  /** @internal */
  constructor(editor, localizationTable) {
    this.editor = editor;
    _AbstractToolbar_listeners.set(this, []);
    _AbstractToolbar_widgetsById.set(this, {});
    _AbstractToolbar_widgetList.set(this, []);
    _AbstractToolbar_updateColoris.set(this, null);
    this.closeColorPickerOverlay = null;
    this.localizationTable = localizationTable ?? editor.localization;
    if (!_AbstractToolbar.colorisStarted) {
      _init();
      _AbstractToolbar.colorisStarted = true;
    }
    this.setupColorPickers();
  }
  setupCloseColorPickerOverlay() {
    if (this.closeColorPickerOverlay)
      return;
    this.closeColorPickerOverlay = document.createElement("div");
    this.closeColorPickerOverlay.className = `${toolbarCSSPrefix}closeColorPickerOverlay`;
    this.editor.createHTMLOverlay(this.closeColorPickerOverlay);
    __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(this.editor.handlePointerEventsExceptClicksFrom(this.closeColorPickerOverlay, (eventName) => {
      if (eventName === "pointerdown") {
        _close();
      }
      if (eventName === "pointerup") {
        this.editor.focus();
      }
      return true;
    }));
  }
  // @internal
  setupColorPickers() {
    if (__classPrivateFieldGet14(this, _AbstractToolbar_updateColoris, "f")) {
      __classPrivateFieldGet14(this, _AbstractToolbar_updateColoris, "f").call(this);
      return;
    }
    this.setupCloseColorPickerOverlay();
    const maxSwatchLen = 12;
    const swatches = [
      Color4.red.toHexString(),
      Color4.purple.toHexString(),
      Color4.blue.toHexString(),
      Color4.clay.toHexString(),
      Color4.black.toHexString(),
      Color4.white.toHexString()
    ];
    const presetColorEnd = swatches.length;
    let colorisInitScheduled = false;
    const initColoris = () => {
      try {
        _coloris({
          el: ".coloris_input",
          format: "hex",
          selectInput: false,
          focusInput: false,
          themeMode: "auto",
          swatches
        });
      } catch (err) {
        console.warn("Failed to initialize Coloris. Error: ", err);
        if (!colorisInitScheduled) {
          colorisInitScheduled = true;
          document.addEventListener("load", () => {
            initColoris();
          }, { once: true });
        }
      }
    };
    initColoris();
    __classPrivateFieldSet12(this, _AbstractToolbar_updateColoris, initColoris, "f");
    const addColorToSwatch = (newColor) => {
      let alreadyPresent = false;
      for (const color of swatches) {
        if (color === newColor) {
          alreadyPresent = true;
        }
      }
      if (!alreadyPresent) {
        swatches.push(newColor);
        if (swatches.length > maxSwatchLen) {
          swatches.splice(presetColorEnd, 1);
        }
        initColoris();
      }
    };
    __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(this.editor.notifier.on(EditorEventType.ColorPickerToggled, (event) => {
      if (event.kind !== EditorEventType.ColorPickerToggled) {
        return;
      }
      if (this.closeColorPickerOverlay) {
        this.closeColorPickerOverlay.style.display = event.open ? "block" : "none";
      }
    }));
    __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(this.editor.notifier.on(EditorEventType.ColorPickerColorSelected, (event) => {
      if (event.kind === EditorEventType.ColorPickerColorSelected) {
        addColorToSwatch(event.color.toHexString());
      }
    }));
  }
  closeColorPickers() {
    var _a6;
    (_a6 = _close) == null ? void 0 : _a6();
  }
  getWidgetUniqueId(widget) {
    return widget.getUniqueIdIn(__classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"));
  }
  getWidgetFromId(id) {
    return __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[id];
  }
  /** Do **not** modify the return value. */
  getAllWidgets() {
    return __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f");
  }
  /**
   * Adds an `ActionButtonWidget` or `BaseToolWidget`. The widget should not have already have a parent
   * (i.e. its `addTo` method should not have been called).
   *
   * @example
   * ```ts
   * const toolbar = editor.addToolbar();
   * const insertImageWidget = new InsertImageWidget(editor);
   * toolbar.addWidget(insertImageWidget);
   * ```
   */
  addWidget(widget) {
    const id = widget.getUniqueIdIn(__classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"));
    __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[id] = widget;
    __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f").push(widget);
    this.addWidgetInternal(widget);
    this.setupColorPickers();
  }
  /** Removes the given `widget` from this toolbar. */
  removeWidget(widget) {
    const id = widget.getUniqueIdIn(__classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"));
    this.removeWidgetInternal(widget);
    delete __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[id];
    __classPrivateFieldSet12(this, _AbstractToolbar_widgetList, __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f").filter((otherWidget) => otherWidget !== widget), "f");
  }
  /** Returns a snapshot of the state of widgets in the toolbar. */
  serializeState() {
    const result = {};
    for (const widgetId in __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")) {
      result[widgetId] = __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[widgetId].serializeState();
    }
    result[_AbstractToolbar.rootToolbarId] = this.serializeInternal();
    return JSON.stringify(result);
  }
  /**
   * Deserialize toolbar widgets from the given state.
   * Assumes that toolbar widgets are in the same order as when state was serialized.
   */
  deserializeState(state) {
    const data = JSON.parse(state);
    assertIsObject(data);
    assertTruthy(data);
    const rootId = _AbstractToolbar.rootToolbarId;
    if (rootId in data && typeof data[rootId] !== "undefined") {
      this.deserializeInternal(data[rootId]);
    }
    for (const widgetId in data) {
      if (widgetId === rootId) {
        continue;
      }
      if (!(widgetId in __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f"))) {
        console.warn(`Unable to deserialize widget ${widgetId} ­— no such widget.`);
        continue;
      }
      if (typeof data[widgetId] === "object" && data[widgetId]) {
        __classPrivateFieldGet14(this, _AbstractToolbar_widgetsById, "f")[widgetId].deserializeFrom(data[widgetId]);
      }
    }
  }
  /**
   * Called by `serializeState` to attach any additional JSONifyable data
   * to the serialized result.
   *
   * @returns an object that can be converted to JSON with `JSON.stringify`.
   */
  serializeInternal() {
  }
  /**
   * Called by `deserializeState` with a version of the JSON outputted
   * previously by `serializeInternal`.
   */
  deserializeInternal(_json) {
  }
  /**
   * Creates, but does not add, an action button to this container.
   *
   * @see
   * {@link addActionButton}
   */
  makeActionButton(title, command, options = true) {
    if (typeof options === "boolean") {
      options = {
        mustBeToplevel: options
      };
    }
    const mustBeToplevel = options.mustBeToplevel ?? true;
    const autoDisableInReadOnlyEditors = options.autoDisableInReadOnlyEditors ?? true;
    const titleString = typeof title === "string" ? title : title.label;
    const widgetId = "action-button";
    const makeIcon = () => {
      if (typeof title === "string") {
        return null;
      }
      return title.icon;
    };
    const widget = new ActionButtonWidget_default(this.editor, widgetId, makeIcon, titleString, command, this.editor.localization, mustBeToplevel, autoDisableInReadOnlyEditors);
    return widget;
  }
  /**
   * Adds an action button with `title` to this toolbar (or to the given `parent` element).
   *
   * `options` can either be an object with properties `mustBeToplevel` and/or
   * `autoDisableInReadOnlyEditors` or a boolean value. If a boolean, it is interpreted
   * as being the value of `mustBeToplevel`.
   *
   * @return The added button.
   *
   * **Example**:
   * ```ts,runnable
   * import { Editor } from 'js-draw';
   * const editor = new Editor(document.body);
   * const toolbar = editor.addToolbar();
   *
   * function makeTrashIcon() {
   *   const container = document.createElement('div');
   *   container.textContent = '🗑️';
   *   return container;
   * }
   *
   * toolbar.addActionButton({
   *   icon: makeTrashIcon(), // can be any Element not in the DOM
   *   label: 'Delete all',
   * }, () => {
   *   alert('to-do!');
   * });
   */
  addActionButton(title, command, options = true) {
    const widget = this.makeActionButton(title, command, options);
    this.addWidget(widget);
    return widget;
  }
  /**
   * Like {@link addActionButton}, except associates `tags` with the button that allow
   * different toolbar styles to give the button tag-dependent styles.
   */
  addTaggedActionButton(tags, title, command, options = true) {
    const widget = this.makeActionButton(title, command, options);
    widget.setTags(tags);
    this.addWidget(widget);
    return widget;
  }
  /**
   * Adds a save button that, when clicked, calls `saveCallback`.
   *
   * @example
   * ```ts,runnable
   * import { Editor, makeDropdownToolbar } from 'js-draw';
   *
   * const editor = new Editor(document.body);
   * const toolbar = makeDropdownToolbar(editor);
   *
   * toolbar.addDefaults();
   * toolbar.addSaveButton(() => alert('save clicked!'));
   * ```
   *
   * `labelOverride` can optionally be used to change the `label` or `icon` of the button.
   */
  addSaveButton(saveCallback, labelOverride = {}) {
    const widget = new SaveActionWidget_default(this.editor, this.localizationTable, saveCallback, labelOverride);
    this.addWidget(widget);
    return widget;
  }
  /**
   * Adds an "Exit" button that, when clicked, calls `exitCallback`.
   *
   * **Note**: This is *roughly* equivalent to
   * ```ts
   * toolbar.addTaggedActionButton([ ToolbarWidgetTag.Exit ], {
   *   label: this.editor.localization.exit,
   *   icon: this.editor.icons.makeCloseIcon(),
   *
   *   // labelOverride can be used to override label or icon.
   *   ...labelOverride,
   * }, () => {
   *   exitCallback();
   * });
   * ```
   * with some additional configuration.
   *
   * @final
   */
  addExitButton(exitCallback, labelOverride = {}) {
    const widget = new ExitActionWidget_default(this.editor, this.localizationTable, exitCallback, labelOverride);
    this.addWidget(widget);
    return widget;
  }
  /**
   * Adds undo and redo buttons that trigger the editor's built-in undo and redo
   * functionality.
   */
  addUndoRedoButtons(undoFirst = true) {
    const makeUndo = () => {
      return this.addTaggedActionButton([ToolbarWidgetTag.Undo], {
        label: this.localizationTable.undo,
        icon: this.editor.icons.makeUndoIcon()
      }, () => {
        this.editor.history.undo();
      });
    };
    const makeRedo = () => {
      return this.addTaggedActionButton([ToolbarWidgetTag.Redo], {
        label: this.localizationTable.redo,
        icon: this.editor.icons.makeRedoIcon()
      }, () => {
        this.editor.history.redo();
      });
    };
    let undoButton;
    let redoButton;
    if (undoFirst) {
      undoButton = makeUndo();
      redoButton = makeRedo();
    } else {
      redoButton = makeRedo();
      undoButton = makeUndo();
    }
    undoButton.setDisabled(true);
    redoButton.setDisabled(true);
    this.editor.notifier.on(EditorEventType.UndoRedoStackUpdated, (event) => {
      if (event.kind !== EditorEventType.UndoRedoStackUpdated) {
        throw new Error("Wrong event type!");
      }
      undoButton.setDisabled(event.undoStackSize === 0);
      redoButton.setDisabled(event.redoStackSize === 0);
    });
  }
  /**
   * Adds widgets for pen/eraser/selection/text/pan-zoom primary tools.
   *
   * If `filter` returns `false` for a tool, no widget is added for that tool.
   * See {@link addDefaultToolWidgets}
   */
  addWidgetsForPrimaryTools(filter) {
    for (const tool of this.editor.toolController.getPrimaryTools()) {
      if (filter && !(filter == null ? void 0 : filter(tool))) {
        continue;
      }
      if (tool instanceof Pen) {
        const widget = new PenToolWidget_default(this.editor, tool, this.localizationTable);
        this.addWidget(widget);
      } else if (tool instanceof Eraser) {
        this.addWidget(new EraserToolWidget_default(this.editor, tool, this.localizationTable));
      } else if (tool instanceof SelectionTool) {
        this.addWidget(new SelectionToolWidget(this.editor, tool, this.localizationTable));
      } else if (tool instanceof TextTool) {
        this.addWidget(new TextToolWidget_default(this.editor, tool, this.localizationTable));
      } else if (tool instanceof PanZoom) {
        this.addWidget(new HandToolWidget(this.editor, tool, this.localizationTable));
      }
    }
  }
  /**
   * Adds toolbar widgets based on the enabled tools, and additional tool-like
   * buttons (e.g. {@link DocumentPropertiesWidget} and {@link InsertImageWidget}).
   */
  addDefaultToolWidgets() {
    this.addWidgetsForPrimaryTools();
    this.addDefaultEditorControlWidgets();
  }
  /**
   * Adds widgets that don't correspond to tools, but do allow the user to control
   * the editor in some way.
   *
   * By default, this includes {@link DocumentPropertiesWidget} and {@link InsertImageWidget}.
   */
  addDefaultEditorControlWidgets() {
    this.addWidget(new DocumentPropertiesWidget_default(this.editor, this.localizationTable));
    this.addWidget(new InsertImageWidget_default(this.editor, this.localizationTable));
  }
  addDefaultActionButtons() {
    this.addUndoRedoButtons();
  }
  /**
   * Remove this toolbar from its container and clean up listeners.
   * This should only be called **once** for a given toolbar.
   */
  remove() {
    var _a6;
    (_a6 = this.closeColorPickerOverlay) == null ? void 0 : _a6.remove();
    for (const listener of __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f")) {
      listener.remove();
    }
    __classPrivateFieldSet12(this, _AbstractToolbar_listeners, [], "f");
    this.onRemove();
    for (const widget of __classPrivateFieldGet14(this, _AbstractToolbar_widgetList, "f")) {
      widget.remove();
    }
  }
  /**
   * Removes `listener` when {@link remove} is called.
   */
  manageListener(listener) {
    __classPrivateFieldGet14(this, _AbstractToolbar_listeners, "f").push(listener);
  }
};
_AbstractToolbar_listeners = /* @__PURE__ */ new WeakMap(), _AbstractToolbar_widgetsById = /* @__PURE__ */ new WeakMap(), _AbstractToolbar_widgetList = /* @__PURE__ */ new WeakMap(), _AbstractToolbar_updateColoris = /* @__PURE__ */ new WeakMap();
AbstractToolbar.colorisStarted = false;
AbstractToolbar.rootToolbarId = "root-toolbar--";
var AbstractToolbar_default = AbstractToolbar;

// node_modules/js-draw/dist/mjs/toolbar/EdgeToolbar.mjs
var makeEdgeToolbar = (editor) => {
  return new EdgeToolbar(editor, editor.getRootElement(), editor.localization);
};
var EdgeToolbar = class extends AbstractToolbar_default {
  /** @internal */
  constructor(editor, parent, localizationTable) {
    super(editor, localizationTable);
    this.clearDragListeners = null;
    this.toolbarContainer = document.createElement("div");
    this.toolbarContainer.classList.add(`${toolbarCSSPrefix}root`);
    this.toolbarContainer.classList.add(`${toolbarCSSPrefix}element`);
    this.toolbarContainer.classList.add(`${toolbarCSSPrefix}edge-toolbar`);
    this.toolbarContainer.setAttribute("role", "toolbar");
    this.toolbarActionRow = document.createElement("div");
    this.toolbarActionRow.classList.add("toolbar-element", "toolbar-action-row");
    this.toolbarToolRow = document.createElement("div");
    this.toolbarToolRow.classList.add("toolbar-element", "toolbar-tool-row");
    stopPropagationOfScrollingWheelEvents_default(this.toolbarToolRow);
    if ("ResizeObserver" in window) {
      this.toolRowResizeObserver = new ResizeObserver((_entries) => {
        this.onToolbarRowResize();
      });
      this.toolRowResizeObserver.observe(this.toolbarToolRow);
    } else {
      console.warn("ResizeObserver not supported. Toolbar will not resize.");
    }
    this.toolbarContainer.replaceChildren(this.toolbarActionRow, this.toolbarToolRow);
    parent.appendChild(this.toolbarContainer);
    this.sidebarVisible = ReactiveValue.fromInitialValue(false);
    this.sidebarY = ReactiveValue.fromInitialValue(0);
    this.menuContainer = document.createElement("div");
    this.menuContainer.classList.add(`${toolbarCSSPrefix}edgemenu-container`);
    this.sidebarContainer = document.createElement("div");
    this.sidebarContainer.classList.add(`${toolbarCSSPrefix}edgemenu`, `${toolbarCSSPrefix}element`);
    this.sidebarContainer.classList.add(`${toolbarCSSPrefix}tool-properties`);
    this.sidebarContent = document.createElement("div");
    this.sidebarY.onUpdateAndNow((y) => {
      const belowEdgeClassName = "dropdown-below-edge";
      if (y > 0) {
        this.sidebarContainer.style.transform = `translate(0, ${y}px)`;
        this.sidebarContainer.style.paddingBottom = "";
        this.menuContainer.classList.add(belowEdgeClassName);
      } else {
        this.sidebarContainer.style.transform = "";
        this.sidebarContainer.style.paddingBottom = `${-y}px`;
        this.menuContainer.classList.remove(belowEdgeClassName);
      }
    });
    this.closeButton = document.createElement("button");
    this.closeButton.classList.add("drag-elem");
    this.editor.handleKeyEventsFrom(this.closeButton, (event) => {
      return event.code !== "Space" && event.code !== "Enter" && event.code !== "Tab";
    });
    this.sidebarContainer.addEventListener("keyup", (event) => {
      if (!event.defaultPrevented && event.code === "Escape") {
        this.sidebarVisible.set(false);
        event.preventDefault();
      }
    });
    this.initDragListeners();
    const setSidebarContent = (...content) => {
      this.sidebarContent.replaceChildren(...content);
      this.setupColorPickers();
    };
    this.sidebarTitle = MutableReactiveValue.fromInitialValue("");
    this.layoutManager = new EdgeToolbarLayoutManager(setSidebarContent, this.sidebarTitle, this.sidebarVisible, editor.announceForAccessibility.bind(editor), localizationTable);
    this.sidebarTitle.onUpdateAndNow((title) => {
      this.closeButton.setAttribute("aria-label", localizationTable.closeSidebar(title));
    });
    this.listenForVisibilityChanges();
    this.sidebarContainer.replaceChildren(this.closeButton, this.sidebarContent);
    this.menuContainer.replaceChildren(this.sidebarContainer);
    parent.appendChild(this.menuContainer);
  }
  listenForVisibilityChanges() {
    var _a6;
    let animationTimeout = null;
    const animationDuration = 170;
    if (!this.sidebarVisible.get()) {
      this.menuContainer.style.display = "none";
      this.menuContainer.style.opacity = "0";
    }
    const prefersReduceMotion = ((_a6 = window.matchMedia) == null ? void 0 : _a6.call(window, "(prefers-reduced-motion: reduce)")) ?? "";
    this.sidebarVisible.onUpdate((visible) => {
      const animationProperties = `${animationDuration}ms ease`;
      const reduceMotion = prefersReduceMotion.matches ? "-reduce-motion" : "";
      if (visible) {
        this.sidebarY.set(this.snappedSidebarY());
        if (animationTimeout) {
          clearTimeout(animationTimeout);
          animationTimeout = null;
        }
        this.menuContainer.style.display = "";
        this.sidebarContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-transition-in${reduceMotion}`;
        this.menuContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-container-transition-in${reduceMotion}`;
        this.menuContainer.style.opacity = "1";
        this.closeButton.focus({ preventScroll: true });
      } else {
        this.closeColorPickers();
        if (animationTimeout === null) {
          this.sidebarContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-transition-out${reduceMotion}`;
          this.menuContainer.style.animation = `${animationProperties} ${toolbarCSSPrefix}-edgemenu-container-transition-out${reduceMotion}`;
          this.menuContainer.style.opacity = "0";
          this.editor.announceForAccessibility(this.localizationTable.dropdownHidden(this.sidebarTitle.get()));
          animationTimeout = setTimeout(() => {
            this.menuContainer.style.display = "none";
            this.menuContainer.style.overflowY = "";
            animationTimeout = null;
          }, animationDuration);
        }
      }
    });
  }
  onToolbarRowResize() {
    const setExtraPadding = () => {
      const visibleWidth = this.toolbarToolRow.clientWidth;
      let currentWidth = 0;
      let extraPadding = 0;
      let numVisibleButtons = 0;
      for (const child of this.toolbarToolRow.children) {
        const buttonBaseSize = child.clientHeight;
        currentWidth += buttonBaseSize;
        numVisibleButtons++;
        if (currentWidth > visibleWidth) {
          extraPadding = visibleWidth - currentWidth + buttonBaseSize / 2;
          if (extraPadding < 0) {
            extraPadding += buttonBaseSize;
          }
          break;
        }
      }
      const perButtonPadding = Math.round(extraPadding / numVisibleButtons * 10) / 10;
      this.toolbarToolRow.style.setProperty("--extra-left-right-padding", `${perButtonPadding}px`);
    };
    const actionRowBBox = this.toolbarActionRow.getBoundingClientRect();
    const toolbarRowBBox = this.toolbarToolRow.getBoundingClientRect();
    const onDifferentRows = actionRowBBox.y + actionRowBBox.height <= toolbarRowBBox.y;
    if (onDifferentRows) {
      this.toolbarContainer.classList.remove("one-row");
    } else {
      this.toolbarContainer.classList.add("one-row");
    }
    if (this.toolbarToolRow.clientWidth < this.toolbarToolRow.scrollWidth) {
      this.toolbarToolRow.classList.add("has-scroll");
      setExtraPadding();
    } else {
      this.toolbarToolRow.classList.remove("has-scroll", "extra-padding");
    }
  }
  addSpacer(_options) {
  }
  addUndoRedoButtons() {
    super.addUndoRedoButtons(false);
  }
  addDefaults() {
    this.addDefaultActionButtons();
    this.addDefaultToolWidgets();
  }
  updateWidgetCSSClasses(widget) {
    const tags = widget.getTags();
    widget.removeCSSClassFromContainer("label-inline");
    widget.removeCSSClassFromContainer("label-left");
    widget.removeCSSClassFromContainer("label-right");
    if (tags.includes(ToolbarWidgetTag.Save)) {
      widget.addCSSClassToContainer("label-inline");
      widget.addCSSClassToContainer("label-left");
    }
    if (tags.includes(ToolbarWidgetTag.Exit)) {
      widget.addCSSClassToContainer("label-inline");
      widget.addCSSClassToContainer("label-right");
    }
  }
  addWidgetInternal(widget) {
    this.updateWidgetCSSClasses(widget);
    widget.setLayoutManager(this.layoutManager);
    if (widget.mustBeInToplevelMenu()) {
      widget.addTo(this.toolbarActionRow);
    } else {
      widget.addTo(this.toolbarToolRow);
    }
  }
  removeWidgetInternal(widget) {
    widget.remove();
  }
  onRemove() {
    var _a6;
    this.toolbarContainer.remove();
    this.menuContainer.remove();
    this.toolRowResizeObserver.disconnect();
    (_a6 = this.clearDragListeners) == null ? void 0 : _a6.call(this);
  }
  initDragListeners() {
    const dragElements = [this.closeButton, this.sidebarContainer, this.sidebarContent];
    this.manageListener(this.editor.handlePointerEventsExceptClicksFrom(this.menuContainer, (eventName, event) => {
      if (event.target === this.menuContainer) {
        if (eventName === "pointerdown") {
          this.sidebarVisible.set(false);
          setTimeout(() => this.editor.focus(), 0);
        }
        return true;
      }
      if (!this.sidebarVisible.get()) {
        return true;
      }
      return false;
    }, (_eventName, event) => {
      return event.target === this.menuContainer;
    }));
    let lastGestureWasRoughlyClick = true;
    let gestureEndTimestamp = 0;
    const dragController = makeDraggable_default(this.sidebarContainer, {
      draggableChildElements: dragElements,
      onDrag: (deltaX, deltaY) => this.handleDrag(deltaX, deltaY),
      onDragEnd: (dragStatistics) => {
        gestureEndTimestamp = dragStatistics.endTimestamp;
        lastGestureWasRoughlyClick = dragStatistics.roughlyClick;
        this.finalizeDrag();
      }
    });
    this.clearDragListeners = () => dragController.removeListeners();
    this.closeButton.onclick = () => {
      const wasJustDragging = performance.now() - gestureEndTimestamp < 100;
      if (wasJustDragging && lastGestureWasRoughlyClick || !wasJustDragging) {
        this.sidebarVisible.set(false);
      }
    };
  }
  /**
   * Updates the position of this menu **during** a drag. After a drag ends,
   * {@link finalizeDrag} should be called.
   */
  handleDrag(_deltaX, deltaY) {
    this.sidebarContainer.style.transition = "none";
    this.sidebarY.set(this.sidebarY.get() + deltaY);
  }
  /** Returns `this.sidebarY` rounded to a valid value. */
  snappedSidebarY(sidebarY) {
    const y = sidebarY ?? this.sidebarY.get();
    const snapYs = [-100, 0];
    if (this.sidebarContainer.clientHeight > window.innerHeight) {
      snapYs.push(100);
    }
    let closestSnap = snapYs[0];
    for (const snapY of snapYs) {
      if (Math.abs(snapY - y) < Math.abs(closestSnap - y)) {
        closestSnap = snapY;
      }
    }
    return closestSnap;
  }
  /**
   * Moves the menu to a valid location or closes it, depending on
   * the position set by the drag.
   */
  finalizeDrag() {
    this.sidebarContainer.style.transition = "";
    if (this.sidebarY.get() > this.sidebarContainer.clientHeight / 2) {
      this.sidebarVisible.set(false);
    } else {
      this.sidebarY.set(this.snappedSidebarY());
    }
  }
  serializeInternal() {
    return {
      menuSizeY: this.snappedSidebarY()
    };
  }
  deserializeInternal(json) {
    if (typeof json === "object" && typeof json["menuSizeY"] === "number") {
      this.sidebarY.set(this.snappedSidebarY(json["menuSizeY"]));
    }
  }
};

// node_modules/js-draw/dist/mjs/tools/InputFilter/StrokeKeyboardControl.mjs
var StrokeKeyboardControl = class _StrokeKeyboardControl extends InputMapper_default {
  constructor(shortcuts, viewport) {
    super();
    this.shortcuts = shortcuts;
    this.viewport = viewport;
    this.snapToGridEnabled = false;
    this.angleLockEnabled = false;
    this.startPointCanvas = null;
  }
  // Snap the given pointer to the nearer of the x/y axes.
  xyAxesSnap(pointer) {
    if (!this.startPointCanvas) {
      return pointer;
    }
    const screenPos = this.viewport.canvasToScreen(this.startPointCanvas);
    return pointer.lockedToXYAxesScreen(screenPos, this.viewport);
  }
  mapPointerEvent(event) {
    const mapPointer = (pointer) => {
      if (event.allPointers.length > 1) {
        return pointer;
      }
      if (this.snapToGridEnabled) {
        return pointer.snappedToGrid(this.viewport);
      }
      if (this.angleLockEnabled && this.startPointCanvas) {
        return this.xyAxesSnap(pointer);
      }
      return pointer;
    };
    return {
      kind: event.kind,
      current: mapPointer(event.current),
      allPointers: event.allPointers.map(mapPointer)
    };
  }
  onEvent(event) {
    const shortcuts = this.shortcuts;
    if (event.kind === InputEvtType.PointerDownEvt || event.kind === InputEvtType.PointerMoveEvt || event.kind === InputEvtType.PointerUpEvt) {
      if (event.kind === InputEvtType.PointerDownEvt) {
        this.startPointCanvas = event.current.canvasPos;
      }
      event = this.mapPointerEvent(event);
    }
    let handled = this.emit(event);
    if (
      // Always check keyUpEvents (in case we handled the corresponding keyDown event)
      event.kind === InputEvtType.KeyUpEvent || // Only handle key press events if another tool isn't handling it. We don't want
      // snap to grid/angle lock to conflict with selection/another tool's shortcuts.
      !handled && event.kind === InputEvtType.KeyPressEvent
    ) {
      const isKeyPress = event.kind === InputEvtType.KeyPressEvent;
      if (shortcuts.matchesShortcut(snapToGridKeyboardShortcutId, event)) {
        this.snapToGridEnabled = isKeyPress;
        handled = true;
      }
      if (shortcuts.matchesShortcut(lineLockKeyboardShortcutId, event)) {
        this.angleLockEnabled = isKeyPress;
        handled = true;
      }
    }
    return handled;
  }
  static fromEditor(editor) {
    return new _StrokeKeyboardControl(editor.shortcuts, editor.viewport);
  }
};

// node_modules/js-draw/dist/mjs/util/guessKeyCodeFromKey.mjs
var keyToKeyCode = {
  Control: "ControlLeft",
  "=": "Equal",
  "-": "Minus",
  ";": "Semicolon",
  " ": "Space"
};
var guessKeyCodeFromKey = (key) => {
  const upperKey = key.toUpperCase();
  if ("A" <= upperKey && upperKey <= "Z") {
    return `Key${upperKey}`;
  }
  if ("0" <= key && key <= "9") {
    return `Digit${key}`;
  }
  if (key in keyToKeyCode) {
    return keyToKeyCode[key];
  }
  return key;
};
var guessKeyCodeFromKey_default = guessKeyCodeFromKey;

// node_modules/js-draw/dist/mjs/dialogs/makeAboutDialog.mjs
var makeAboutDialog2 = (editor, entries) => {
  const dialog = makeMessageDialog_default(editor, {
    title: editor.localization.about,
    contentClassNames: ["about-dialog-content"]
  });
  for (const entry of entries) {
    const container = document.createElement(entry.minimized ? "details" : "div");
    container.classList.add("about-entry");
    const header = document.createElement(entry.minimized ? "summary" : "h2");
    if (typeof entry.heading === "string") {
      header.innerText = entry.heading;
    } else {
      const link = document.createElement("a");
      link.href = entry.heading.href.replace(/^javascript:/i, "");
      link.text = entry.heading.text;
      header.appendChild(link);
    }
    container.appendChild(header);
    if (entry.text) {
      const bodyText = document.createElement("div");
      bodyText.innerText = entry.text;
      container.appendChild(bodyText);
    }
    dialog.appendChild(container);
  }
  return {
    close: () => {
      return dialog.close();
    }
  };
};
var makeAboutDialog_default = makeAboutDialog2;

// node_modules/js-draw/dist/mjs/version.mjs
var version_default = {
  // Note: Auto-updated by prebuild.js:
  number: "1.29.0"
};

// node_modules/js-draw/dist/mjs/image/export/adjustExportedSVGSize.mjs
var adjustExportedSVGSize = (svg, exportRect, options) => {
  let width = exportRect.w;
  let height = exportRect.h;
  if ((options == null ? void 0 : options.minDimension) && width < options.minDimension) {
    const newWidth = options.minDimension;
    height *= newWidth / (width || 1);
    width = newWidth;
  }
  if ((options == null ? void 0 : options.minDimension) && height < options.minDimension) {
    const newHeight = options.minDimension;
    width *= newHeight / (height || 1);
    height = newHeight;
  }
  svg.setAttribute("width", toRoundedString(width));
  svg.setAttribute("height", toRoundedString(height));
};
var adjustExportedSVGSize_default = adjustExportedSVGSize;

// node_modules/js-draw/dist/mjs/image/export/editorImageToSVG.mjs
var toSVGInternal = (image, renderFunction, options) => {
  const importExportViewport = image.getImportExportViewport().getTemporaryClone();
  if (options == null ? void 0 : options.minDimension) {
    const originalRect = importExportViewport.visibleRect;
    let rect = originalRect;
    if (rect.w <= 0) {
      rect = new Rect2(rect.x, rect.y, options.minDimension, rect.h);
    }
    if (rect.h <= 0) {
      rect = new Rect2(rect.x, rect.y, rect.w, options.minDimension);
    }
    if (!rect.eq(originalRect)) {
      importExportViewport.updateScreenSize(rect.size);
    }
  }
  const { element: result, renderer } = SVGRenderer.fromViewport(importExportViewport, {
    sanitize: options.sanitize ?? false,
    useViewBoxForPositioning: true
  });
  renderFunction(renderer, () => {
    if (image.getAutoresizeEnabled()) {
      result.classList.add(svgLoaderAutoresizeClassName);
    } else {
      result.classList.remove(svgLoaderAutoresizeClassName);
    }
    const exportRect = importExportViewport.visibleRect;
    adjustExportedSVGSize_default(result, exportRect, options);
    return result;
  });
  return result;
};
var editorImageToSVGSync = (image, options) => {
  return toSVGInternal(image, (renderer, onComplete) => {
    image.renderAll(renderer);
    onComplete();
  }, options);
};
var editorImageToSVGAsync = (image, preRenderComponent, options) => {
  return new Promise((resolve) => {
    toSVGInternal(image, async (renderer, onComplete) => {
      await image.renderAllAsync(renderer, preRenderComponent);
      const result = onComplete();
      resolve(result);
    }, options);
  });
};

// node_modules/js-draw/dist/mjs/util/listenForKeyboardEventsFrom.mjs
var listenForKeyboardEventsFrom = (elem, callbacks) => {
  let keysDown = [];
  const keyEventsMatch = (a, b) => {
    return a.key === b.key && a.code === b.code;
  };
  const isKeyDown = (keyEvent) => {
    return keysDown.some((other) => keyEventsMatch(other, keyEvent));
  };
  const keyEventToRecord = (event) => {
    return {
      code: event.code,
      key: event.key,
      ctrlKey: event.ctrlKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey,
      metaKey: event.metaKey
    };
  };
  const handleKeyEvent = (htmlEvent) => {
    if (htmlEvent.type === "keydown") {
      if (!isKeyDown(htmlEvent)) {
        keysDown.push(keyEventToRecord(htmlEvent));
      }
      if (!callbacks.filter(htmlEvent)) {
        return;
      }
      callbacks.handleKeyDown(htmlEvent);
    } else {
      console.assert(htmlEvent.type === "keyup");
      keysDown = keysDown.filter((event) => {
        const matches = keyEventsMatch(event, htmlEvent);
        return !matches;
      });
      if (!callbacks.filter(htmlEvent)) {
        return;
      }
      callbacks.handleKeyUp(htmlEvent);
    }
  };
  elem.addEventListener("keydown", (htmlEvent) => {
    handleKeyEvent(htmlEvent);
  });
  elem.addEventListener("keyup", (htmlEvent) => {
    handleKeyEvent(htmlEvent);
  });
  elem.addEventListener("focusout", (focusEvent) => {
    let stillHasFocus = false;
    if (focusEvent.relatedTarget) {
      const relatedTarget = focusEvent.relatedTarget;
      stillHasFocus = elem.contains(relatedTarget) || callbacks.getHandlesKeyEventsFrom(relatedTarget);
    }
    if (!stillHasFocus) {
      for (const event of keysDown) {
        callbacks.handleKeyUp(new KeyboardEvent("keyup", {
          ...event
        }));
      }
      keysDown = [];
    }
  });
  const fireArtificalEventsBasedOn = (htmlEvent) => {
    let wasShiftDown = false;
    let wasCtrlDown = false;
    let wasAltDown = false;
    let wasMetaDown = false;
    for (const otherEvent of keysDown) {
      const code = otherEvent.code;
      wasShiftDown || (wasShiftDown = !!code.match(/^Shift(Left|Right)$/));
      wasCtrlDown || (wasCtrlDown = !!code.match(/^Control(Left|Right)$/));
      wasAltDown || (wasAltDown = !!code.match(/^Alt(Left|Right)$/));
      wasMetaDown || (wasMetaDown = !!code.match(/^Meta(Left|Right)$/));
    }
    const eventName = (isDown) => {
      if (isDown) {
        return "keydown";
      } else {
        return "keyup";
      }
    };
    const eventInitDefaults = {
      shiftKey: htmlEvent.shiftKey,
      altKey: htmlEvent.altKey,
      metaKey: htmlEvent.metaKey,
      ctrlKey: htmlEvent.ctrlKey
    };
    if (htmlEvent.shiftKey !== wasShiftDown) {
      handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.shiftKey), {
        ...eventInitDefaults,
        key: "Shift",
        code: "ShiftLeft"
      }));
    }
    if (htmlEvent.altKey !== wasAltDown) {
      handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.altKey), {
        ...eventInitDefaults,
        key: "Alt",
        code: "AltLeft"
      }));
    }
    if (htmlEvent.ctrlKey !== wasCtrlDown) {
      handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.ctrlKey), {
        ...eventInitDefaults,
        key: "Control",
        code: "ControlLeft"
      }));
    }
    if (htmlEvent.metaKey !== wasMetaDown) {
      handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.metaKey), {
        ...eventInitDefaults,
        key: "Meta",
        code: "MetaLeft"
      }));
    }
  };
  elem.addEventListener("mousedown", (htmlEvent) => {
    fireArtificalEventsBasedOn(htmlEvent);
  });
  elem.addEventListener("mousemove", (htmlEvent) => {
    fireArtificalEventsBasedOn(htmlEvent);
  });
};
var listenForKeyboardEventsFrom_default = listenForKeyboardEventsFrom;

// node_modules/js-draw/dist/mjs/util/mitLicenseAttribution.mjs
var mitLicenseAttribution = (copyright) => {
  const removeSingleLineBreaks = (text) => text.replace(/([^\n])[\n]([^\n])/g, "$1 $2");
  return removeSingleLineBreaks(`
MIT License

Copyright (c) ${copyright}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.`);
};
var mitLicenseAttribution_default = mitLicenseAttribution;

// node_modules/js-draw/dist/mjs/tools/InputFilter/ContextMenuRecognizer.mjs
var ContextMenuRecognizer = class extends InputMapper_default {
  constructor() {
    super();
    this.canShowContextMenu = false;
    this.stationaryDetector = null;
    this.clickTolerance = 12;
  }
  /**
   * In general, only certain events (i.e. touchscreens) are expected to be able to
   * create long-press menus. This method checks whether `event` was generated by
   * one such device.
   */
  canMakeLongPressMenuEvent(event) {
    const allowedDevices = [PointerDevice.Touch];
    return event.allPointers.length === 1 && allowedDevices.includes(event.current.device);
  }
  onEvent(event) {
    var _a6, _b2, _c2;
    const sendContextMenuEvent = () => {
      if (!isPointerEvt(event))
        return false;
      if (this.canShowContextMenu) {
        const eventHandled = this.emit({
          kind: InputEvtType.ContextMenu,
          screenPos: event.current.screenPos,
          canvasPos: event.current.canvasPos
        });
        if (eventHandled) {
          this.emit({
            kind: InputEvtType.GestureCancelEvt
          });
          return true;
        }
      }
      return false;
    };
    if (event.kind === InputEvtType.PointerDownEvt) {
      if (event.allPointers.length === 1) {
        this.canShowContextMenu = true;
        this.contextMenuTriggerPointer = event.current;
        this.contextMenuStartPoint = event.current.screenPos;
        if (this.canMakeLongPressMenuEvent(event)) {
          this.stationaryDetector = new StationaryPenDetector(event.current, defaultStationaryDetectionConfig, sendContextMenuEvent);
        }
      } else {
        this.canShowContextMenu = false;
      }
    } else if (event.kind === InputEvtType.PointerMoveEvt) {
      if (this.canShowContextMenu) {
        (_a6 = this.stationaryDetector) == null ? void 0 : _a6.onPointerMove(event.current);
        const deltaPosition = event.current.screenPos.minus(this.contextMenuStartPoint);
        const threshold = this.clickTolerance;
        if (deltaPosition.length() > threshold) {
          this.canShowContextMenu = false;
        }
      }
    } else if (event.kind === InputEvtType.PointerUpEvt) {
      (_b2 = this.stationaryDetector) == null ? void 0 : _b2.destroy();
      if (((_c2 = this.contextMenuTriggerPointer) == null ? void 0 : _c2.id) === event.current.id && this.contextMenuTriggerPointer.device === PointerDevice.RightButtonMouse && sendContextMenuEvent()) {
        return true;
      }
    }
    return this.emit(event);
  }
};

// node_modules/js-draw/dist/mjs/Editor.mjs
var Editor = class {
  /**
   * @example
   * ```ts,runnable
   * import { Editor } from 'js-draw';
   *
   * const container = document.body;
   *
   * // Create an editor
   * const editor = new Editor(container, {
   *   // 2e-10 and 1e12 are the default values for minimum/maximum zoom.
   *   minZoom: 2e-10,
   *   maxZoom: 1e12,
   * });
   *
   * // Add the default toolbar
   * const toolbar = editor.addToolbar();
   *
   * const createCustomIcon = () => {
   *   // Create/return an icon here.
   * };
   *
   * // Add a custom button
   * toolbar.addActionButton({
   *   label: 'Custom Button'
   *   icon: createCustomIcon(),
   * }, () => {
   *   // Do something here
   * });
   * ```
   */
  constructor(parent, settings = {}) {
    var _a6, _b2, _c2, _d, _e;
    this.eventListenerTargets = [];
    this.previousAccessibilityAnnouncement = "";
    this.pointers = {};
    this.announceUndoCallback = (command) => {
      this.announceForAccessibility(this.localization.undoAnnouncement(command.description(this, this.localization)));
    };
    this.announceRedoCallback = (command) => {
      this.announceForAccessibility(this.localization.redoAnnouncement(command.description(this, this.localization)));
    };
    this.nextRerenderListeners = [];
    this.rerenderQueued = false;
    this.closeAboutDialog = null;
    this.localization = {
      ...getLocalizationTable_default(),
      ...settings.localization
    };
    this.settings = {
      wheelEventsEnabled: settings.wheelEventsEnabled ?? true,
      renderingMode: settings.renderingMode ?? RenderingMode.CanvasRenderer,
      localization: this.localization,
      minZoom: settings.minZoom ?? 2e-10,
      maxZoom: settings.maxZoom ?? 1e12,
      keyboardShortcutOverrides: settings.keyboardShortcutOverrides ?? {},
      iconProvider: settings.iconProvider ?? new IconProvider_default(),
      notices: settings.notices ?? [],
      appInfo: settings.appInfo ? { ...settings.appInfo } : null,
      pens: {
        additionalPenTypes: ((_a6 = settings.pens) == null ? void 0 : _a6.additionalPenTypes) ?? [],
        filterPenTypes: ((_b2 = settings.pens) == null ? void 0 : _b2.filterPenTypes) ?? (() => true)
      },
      text: {
        fonts: ((_c2 = settings.text) == null ? void 0 : _c2.fonts) ?? ["sans-serif", "serif", "monospace"]
      },
      image: {
        showImagePicker: ((_d = settings.image) == null ? void 0 : _d.showImagePicker) ?? void 0
      },
      svg: {
        loaderPlugins: ((_e = settings.svg) == null ? void 0 : _e.loaderPlugins) ?? []
      },
      clipboardApi: settings.clipboardApi ?? null
    };
    if (this.settings.minZoom > this.settings.maxZoom) {
      throw new Error("Minimum zoom must be lesser than maximum zoom!");
    }
    this.readOnly = MutableReactiveValue.fromInitialValue(false);
    this.icons = this.settings.iconProvider;
    this.shortcuts = new KeyboardShortcutManager_default(this.settings.keyboardShortcutOverrides);
    this.container = document.createElement("div");
    this.renderingRegion = document.createElement("div");
    this.container.appendChild(this.renderingRegion);
    this.container.classList.add("imageEditorContainer", "js-draw");
    this.loadingWarning = document.createElement("div");
    this.loadingWarning.classList.add("loadingMessage");
    this.loadingWarning.ariaLive = "polite";
    this.container.appendChild(this.loadingWarning);
    this.accessibilityControlArea = document.createElement("textarea");
    this.accessibilityControlArea.setAttribute("placeholder", this.localization.accessibilityInputInstructions);
    this.accessibilityControlArea.style.opacity = "0";
    this.accessibilityControlArea.style.width = "0";
    this.accessibilityControlArea.style.height = "0";
    this.accessibilityControlArea.style.position = "absolute";
    this.accessibilityAnnounceArea = document.createElement("div");
    this.accessibilityAnnounceArea.setAttribute("aria-live", "assertive");
    this.accessibilityAnnounceArea.className = "accessibilityAnnouncement";
    this.container.appendChild(this.accessibilityAnnounceArea);
    this.renderingRegion.style.touchAction = "none";
    this.renderingRegion.className = "imageEditorRenderArea";
    this.renderingRegion.appendChild(this.accessibilityControlArea);
    this.renderingRegion.setAttribute("tabIndex", "0");
    this.renderingRegion.setAttribute("alt", "");
    this.notifier = new EventDispatcher();
    this.viewport = new Viewport_default((oldTransform, newTransform) => {
      this.notifier.dispatch(EditorEventType.ViewportChanged, {
        kind: EditorEventType.ViewportChanged,
        newTransform,
        oldTransform
      });
    });
    this.display = new Display(this, this.settings.renderingMode, this.renderingRegion);
    this.image = new EditorImage_default();
    this.history = new UndoRedoHistory_default(this, this.announceRedoCallback, this.announceUndoCallback);
    this.toolController = new ToolController(this, this.localization);
    this.toolController.addInputMapper(StrokeKeyboardControl.fromEditor(this));
    this.toolController.addInputMapper(new ContextMenuRecognizer());
    parent.appendChild(this.container);
    this.viewport.updateScreenSize(Vec2.of(this.display.width, this.display.height));
    this.registerListeners();
    this.queueRerender();
    this.hideLoadingWarning();
    this.notifier.on(EditorEventType.ViewportChanged, (evt) => {
      if (evt.kind !== EditorEventType.ViewportChanged)
        return;
      const getZoom = (mat) => mat.transformVec3(Vec2.unitX).length();
      const zoom = getZoom(evt.newTransform);
      if (zoom > this.settings.maxZoom || zoom < this.settings.minZoom) {
        const oldZoom = getZoom(evt.oldTransform);
        let resetTransform = Mat33.identity;
        if (oldZoom <= this.settings.maxZoom && oldZoom >= this.settings.minZoom) {
          resetTransform = evt.oldTransform;
        } else {
          resetTransform = Mat33.scaling2D((this.settings.minZoom + this.settings.maxZoom) / 2);
        }
        this.viewport.resetTransform(resetTransform);
      } else if (!isFinite(zoom)) {
        console.warn(`Non-finite zoom (${zoom}) detected. Resetting the viewport. This was likely caused by division by zero.`);
        if (isFinite(getZoom(evt.oldTransform))) {
          this.viewport.resetTransform(evt.oldTransform);
        } else {
          this.viewport.resetTransform();
        }
      }
    });
  }
  /**
   * @returns a shallow copy of the current settings of the editor.
   *
   * Do not modify.
   */
  getCurrentSettings() {
    return {
      ...this.settings
    };
  }
  /**
   * @returns a reference to the editor's container.
   *
   * @example
   * ```
   *   // Set the editor's height to 500px
   *   editor.getRootElement().style.height = '500px';
   * ```
   */
  getRootElement() {
    return this.container;
  }
  /**
   * @returns the bounding box of the main rendering region of the editor in the HTML viewport.
   *
   * @internal
   */
  getOutputBBoxInDOM() {
    return Rect2.of(this.renderingRegion.getBoundingClientRect());
  }
  /**
   * Shows a "Loading..." message.
   * @param fractionLoaded - should be a number from 0 to 1, where 1 represents completely loaded.
   */
  showLoadingWarning(fractionLoaded) {
    const loadingPercent = Math.round(fractionLoaded * 100);
    this.loadingWarning.innerText = this.localization.loading(loadingPercent);
    this.loadingWarning.style.display = "block";
  }
  /** @see {@link showLoadingWarning} */
  hideLoadingWarning() {
    this.loadingWarning.style.display = "none";
    this.announceForAccessibility(this.localization.doneLoading);
  }
  /**
   * Announce `message` for screen readers. If `message` is the same as the previous
   * message, it is re-announced.
   */
  announceForAccessibility(message) {
    if (message === this.previousAccessibilityAnnouncement) {
      message = message + ". ";
    }
    this.accessibilityAnnounceArea.innerText = message;
    this.previousAccessibilityAnnouncement = message;
  }
  /**
   * Creates a toolbar. If `defaultLayout` is true, default buttons are used.
   * @returns a reference to the toolbar.
   */
  addToolbar(defaultLayout = true) {
    const toolbar = new EdgeToolbar(this, this.container, this.localization);
    if (defaultLayout) {
      toolbar.addDefaults();
    }
    return toolbar;
  }
  registerListeners() {
    this.handlePointerEventsFrom(this.renderingRegion);
    this.handleKeyEventsFrom(this.renderingRegion);
    this.handlePointerEventsFrom(this.accessibilityAnnounceArea);
    const preventSelectionOf = [
      this.renderingRegion,
      this.accessibilityAnnounceArea,
      this.accessibilityControlArea,
      this.loadingWarning
    ];
    for (const element of preventSelectionOf) {
      element.addEventListener("drag", (event) => {
        event.preventDefault();
        return false;
      });
      element.addEventListener("dragstart", (event) => {
        event.preventDefault();
        return false;
      });
    }
    this.container.addEventListener("wheel", (evt) => {
      this.handleHTMLWheelEvent(evt);
    });
    const handleResize = () => {
      this.viewport.updateScreenSize(Vec2.of(this.display.width, this.display.height));
      this.rerender();
      this.updateEditorSizeVariables();
    };
    if ("ResizeObserver" in window) {
      const resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(this.renderingRegion);
      resizeObserver.observe(this.container);
    } else {
      addEventListener("resize", handleResize);
    }
    this.accessibilityControlArea.addEventListener("input", () => {
      this.accessibilityControlArea.value = "";
    });
    const copyHandler = new ClipboardHandler_default(this);
    document.addEventListener("copy", async (evt) => {
      if (!this.isEventSink(document.querySelector(":focus"))) {
        return;
      }
      copyHandler.copy(evt);
    });
    document.addEventListener("paste", (evt) => {
      this.handlePaste(evt);
    });
  }
  updateEditorSizeVariables() {
    this.container.style.setProperty("--editor-current-width-px", `${this.container.clientWidth}px`);
    this.container.style.setProperty("--editor-current-height-px", `${this.container.clientHeight}px`);
    this.container.style.setProperty("--editor-current-display-width-px", `${this.renderingRegion.clientWidth}px`);
    this.container.style.setProperty("--editor-current-display-height-px", `${this.renderingRegion.clientHeight}px`);
  }
  /** @internal */
  handleHTMLWheelEvent(event) {
    let delta = Vec3.of(event.deltaX, event.deltaY, event.deltaZ);
    if (!event.ctrlKey && !event.metaKey) {
      if (!this.settings.wheelEventsEnabled) {
        return;
      } else if (this.settings.wheelEventsEnabled === "only-if-focused") {
        const focusedChild = this.container.querySelector(":focus");
        if (!focusedChild) {
          return;
        }
      }
    }
    if (event.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      delta = delta.times(15);
    } else if (event.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
      delta = delta.times(100);
    }
    if (event.ctrlKey || event.metaKey) {
      delta = Vec3.of(0, 0, event.deltaY);
    }
    const bbox = this.getOutputBBoxInDOM();
    const pos = Vec2.of(event.clientX, event.clientY).minus(bbox.topLeft);
    if (this.toolController.dispatchInputEvent({
      kind: InputEvtType.WheelEvt,
      delta,
      screenPos: pos
    })) {
      event.preventDefault();
      return true;
    }
    return false;
  }
  getPointerList() {
    const nowTime = performance.now();
    const res = [];
    for (const id in this.pointers) {
      const maxUnupdatedTime = 2e3;
      if (this.pointers[id] && nowTime - this.pointers[id].timeStamp < maxUnupdatedTime) {
        res.push(this.pointers[id]);
      }
    }
    return res;
  }
  /**
   * A protected method that can override setPointerCapture in environments where it may fail
   * (e.g. with synthetic events). @internal
   */
  setPointerCapture(target, pointerId) {
    try {
      target.setPointerCapture(pointerId);
    } catch (error) {
      console.warn("Failed to setPointerCapture", error);
    }
  }
  /** Can be overridden in a testing environment to handle synthetic events. @internal */
  releasePointerCapture(target, pointerId) {
    try {
      target.releasePointerCapture(pointerId);
    } catch (error) {
      console.warn("Failed to releasePointerCapture", error);
    }
  }
  /**
   * Dispatches a `PointerEvent` to the editor. The target element for `evt` must have the same top left
   * as the content of the editor.
   */
  handleHTMLPointerEvent(eventType, evt) {
    var _a6;
    const eventsRelativeTo = this.renderingRegion;
    const eventTarget = evt.target ?? this.renderingRegion;
    if (eventType === "pointerdown") {
      const pointer = Pointer.ofEvent(evt, true, this.viewport, eventsRelativeTo);
      this.pointers[pointer.id] = pointer;
      this.setPointerCapture(eventTarget, pointer.id);
      const event = {
        kind: InputEvtType.PointerDownEvt,
        current: pointer,
        allPointers: this.getPointerList()
      };
      this.toolController.dispatchInputEvent(event);
      return true;
    } else if (eventType === "pointermove") {
      const pointer = Pointer.ofEvent(evt, ((_a6 = this.pointers[evt.pointerId]) == null ? void 0 : _a6.down) ?? false, this.viewport, eventsRelativeTo);
      if (pointer.down) {
        const prevData = this.pointers[pointer.id];
        if (prevData) {
          const distanceMoved = pointer.screenPos.distanceTo(prevData.screenPos);
          if (distanceMoved < 2) {
            return false;
          }
        }
        this.pointers[pointer.id] = pointer;
        if (this.toolController.dispatchInputEvent({
          kind: InputEvtType.PointerMoveEvt,
          current: pointer,
          allPointers: this.getPointerList()
        })) {
          evt.preventDefault();
        }
      }
      return true;
    } else if (eventType === "pointercancel" || eventType === "pointerup") {
      const pointer = Pointer.ofEvent(evt, false, this.viewport, eventsRelativeTo);
      if (!this.pointers[pointer.id]) {
        return false;
      }
      this.pointers[pointer.id] = pointer;
      this.releasePointerCapture(eventTarget, pointer.id);
      if (this.toolController.dispatchInputEvent({
        kind: InputEvtType.PointerUpEvt,
        current: pointer,
        allPointers: this.getPointerList()
      })) {
        evt.preventDefault();
      }
      delete this.pointers[pointer.id];
      return true;
    }
    return eventType;
  }
  isEventSink(evtTarget) {
    let currentElem = evtTarget;
    while (currentElem !== null) {
      for (const elem of this.eventListenerTargets) {
        if (elem === currentElem) {
          return true;
        }
      }
      currentElem = currentElem.parentElement;
    }
    return false;
  }
  /** @internal */
  async handleDrop(evt) {
    evt.preventDefault();
    await this.handlePaste(evt);
  }
  /** @internal */
  async handlePaste(evt) {
    const target = document.querySelector(":focus") ?? evt.target;
    if (!this.isEventSink(target)) {
      return;
    }
    return await new ClipboardHandler_default(this).paste(evt);
  }
  /**
   * Forward pointer events from `elem` to this editor. Such that right-click/right-click drag
   * events are also forwarded, `elem`'s contextmenu is disabled.
   *
   * `filter` is called once per pointer event, before doing any other processing. If `filter` returns `true` the event is
   * forwarded to the editor.
   *
   * **Note**: `otherEventsFilter` is like `filter`, but is called for other pointer-related
   * events that could also be forwarded to the editor. To forward just pointer events,
   * for example, `otherEventsFilter` could be given as `()=>false`.
   *
   * @example
   * ```ts
   * const overlay = document.createElement('div');
   * editor.createHTMLOverlay(overlay);
   *
   * // Send all pointer events that don't have the control key pressed
   * // to the editor.
   * editor.handlePointerEventsFrom(overlay, (event) => {
   *   if (event.ctrlKey) {
   *     return false;
   *   }
   *   return true;
   * });
   * ```
   */
  handlePointerEventsFrom(elem, filter, otherEventsFilter) {
    const touchstartListener = (evt) => {
      if (otherEventsFilter && !otherEventsFilter("touchstart", evt)) {
        return;
      }
      evt.preventDefault();
    };
    const contextmenuListener = (evt) => {
      if (otherEventsFilter && !otherEventsFilter("contextmenu", evt)) {
        return;
      }
      evt.preventDefault();
    };
    const listeners = {
      touchstart: touchstartListener,
      contextmenu: contextmenuListener
    };
    const eventNames = [
      "pointerdown",
      "pointermove",
      "pointerup",
      "pointercancel"
    ];
    for (const eventName of eventNames) {
      listeners[eventName] = (evt) => {
        const event = evt;
        if (filter && !filter(eventName, event)) {
          return void 0;
        }
        return this.handleHTMLPointerEvent(eventName, event);
      };
    }
    for (const eventName in listeners) {
      elem.addEventListener(eventName, listeners[eventName]);
    }
    return {
      /** Remove all event listeners registered by this function. */
      remove: () => {
        for (const eventName in listeners) {
          elem.removeEventListener(eventName, listeners[eventName]);
        }
      }
    };
  }
  /**
   * Like {@link handlePointerEventsFrom} except ignores short input gestures like clicks.
   *
   * `filter` is called once per event, before doing any other processing. If `filter` returns `true` the event is
   * forwarded to the editor.
   *
   * `otherEventsFilter` is passed unmodified to `handlePointerEventsFrom`.
   */
  handlePointerEventsExceptClicksFrom(elem, filter, otherEventsFilter) {
    const gestureData = /* @__PURE__ */ Object.create(null);
    return this.handlePointerEventsFrom(elem, (eventName, event) => {
      if (filter && !filter(eventName, event)) {
        return false;
      }
      const currentPos = Vec2.of(event.pageX ?? event.clientX, event.pageY ?? event.clientY);
      const pointerId = event.pointerId ?? 0;
      let sendToEditor = true;
      if (eventName === "pointerdown") {
        gestureData[pointerId] = {
          eventBuffer: [[eventName, event]],
          startPoint: currentPos,
          hasMovedSignificantly: false
        };
        this.setPointerCapture(elem, event.pointerId);
        sendToEditor = false;
      } else if (eventName === "pointermove" && gestureData[pointerId]) {
        const gestureStartPos = gestureData[pointerId].startPoint;
        const eventBuffer = gestureData[pointerId].eventBuffer;
        const strokeStartThreshold = 10;
        const isWithinClickThreshold = gestureStartPos && currentPos.distanceTo(gestureStartPos) < strokeStartThreshold;
        if (isWithinClickThreshold && !gestureData[pointerId].hasMovedSignificantly) {
          eventBuffer.push([eventName, event]);
          sendToEditor = false;
        } else {
          for (const [eventName2, event2] of eventBuffer) {
            this.handleHTMLPointerEvent(eventName2, event2);
          }
          gestureData[pointerId].eventBuffer = [];
          gestureData[pointerId].hasMovedSignificantly = true;
          sendToEditor = true;
        }
      } else if (eventName === "pointermove") {
        sendToEditor = true;
      } else if ((eventName === "pointerup" || eventName === "pointercancel") && gestureData[pointerId] && gestureData[pointerId].eventBuffer.length > 0) {
        this.releasePointerCapture(elem, event.pointerId);
        sendToEditor = false;
        delete gestureData[pointerId];
      }
      return sendToEditor;
    }, otherEventsFilter);
  }
  /** @internal */
  handleHTMLKeyDownEvent(htmlEvent) {
    console.assert(htmlEvent.type === "keydown", `handling a keydown event with type ${htmlEvent.type}`);
    const event = keyPressEventFromHTMLEvent(htmlEvent);
    if (this.toolController.dispatchInputEvent(event)) {
      htmlEvent.preventDefault();
      return true;
    } else if (event.key === "t" || event.key === "T") {
      htmlEvent.preventDefault();
      this.display.rerenderAsText();
      return true;
    } else if (event.key === "Escape") {
      this.renderingRegion.blur();
      return true;
    }
    return false;
  }
  /** @internal */
  handleHTMLKeyUpEvent(htmlEvent) {
    console.assert(htmlEvent.type === "keyup", `Handling a keyup event with type ${htmlEvent.type}`);
    const event = keyUpEventFromHTMLEvent(htmlEvent);
    if (this.toolController.dispatchInputEvent(event)) {
      htmlEvent.preventDefault();
      return true;
    }
    return false;
  }
  /**
   * Adds event listners for keypresses (and drop events) on `elem` and forwards those
   * events to the editor.
   *
   * If the given `filter` returns `false` for an event, the event is ignored and not
   * passed to the editor.
   */
  handleKeyEventsFrom(elem, filter = () => true) {
    listenForKeyboardEventsFrom_default(elem, {
      filter,
      handleKeyDown: (htmlEvent) => {
        this.handleHTMLKeyDownEvent(htmlEvent);
      },
      handleKeyUp: (htmlEvent) => {
        this.handleHTMLKeyUpEvent(htmlEvent);
      },
      getHandlesKeyEventsFrom: (element) => {
        return this.eventListenerTargets.includes(element);
      }
    });
    elem.ondragover = (evt) => {
      evt.preventDefault();
    };
    elem.ondrop = (evt) => {
      this.handleDrop(evt);
    };
    this.eventListenerTargets.push(elem);
  }
  /**
   * Attempts to prevent **user-triggered** events from modifying
   * the content of the image.
   */
  setReadOnly(readOnly) {
    if (readOnly !== this.readOnly.get()) {
      this.readOnly.set(readOnly);
      this.notifier.dispatch(EditorEventType.ReadOnlyModeToggled, {
        kind: EditorEventType.ReadOnlyModeToggled,
        editorIsReadOnly: readOnly
      });
    }
  }
  // @internal
  isReadOnlyReactiveValue() {
    return this.readOnly;
  }
  isReadOnly() {
    return this.readOnly;
  }
  /**
   * `apply` a command. `command` will be announced for accessibility.
   *
   * **Example**:
   * [[include:doc-pages/inline-examples/adding-a-stroke.md]]
   */
  dispatch(command, addToHistory = true) {
    const dispatchResult = this.dispatchNoAnnounce(command, addToHistory);
    const commandDescription = command.description(this, this.localization);
    this.announceForAccessibility(commandDescription);
    return dispatchResult;
  }
  /**
   * Dispatches a command without announcing it. By default, does not add to history.
   * Use this to show finalized commands that don't need to have `announceForAccessibility`
   * called.
   *
   * If `addToHistory` is `false`, this is equivalent to `command.apply(editor)`.
   *
   * @example
   * ```
   * const addToHistory = false;
   * editor.dispatchNoAnnounce(editor.viewport.zoomTo(someRectangle), addToHistory);
   * ```
   */
  dispatchNoAnnounce(command, addToHistory = false) {
    const result = command.apply(this);
    if (addToHistory) {
      const apply = false;
      this.history.push(command, apply);
    }
    return result;
  }
  /**
   * Apply a large transformation in chunks.
   * If `apply` is `false`, the commands are unapplied.
   * Triggers a re-render after each `updateChunkSize`-sized group of commands
   * has been applied.
   */
  async asyncApplyOrUnapplyCommands(commands, apply, updateChunkSize2) {
    console.assert(updateChunkSize2 > 0);
    this.display.setDraftMode(true);
    for (let i = 0; i < commands.length; i += updateChunkSize2) {
      this.showLoadingWarning(i / commands.length);
      for (let j = i; j < commands.length && j < i + updateChunkSize2; j++) {
        const cmd = commands[j];
        if (apply) {
          cmd.apply(this);
        } else {
          cmd.unapply(this);
        }
      }
      if (i + updateChunkSize2 < commands.length) {
        await new Promise((resolve) => {
          this.rerender();
          requestAnimationFrame(resolve);
        });
      }
    }
    this.display.setDraftMode(false);
    this.hideLoadingWarning();
  }
  /** @see {@link asyncApplyOrUnapplyCommands } */
  asyncApplyCommands(commands, chunkSize) {
    return this.asyncApplyOrUnapplyCommands(commands, true, chunkSize);
  }
  /**
   * @see {@link asyncApplyOrUnapplyCommands}
   *
   * If `unapplyInReverseOrder`, commands are reversed before unapplying.
   */
  asyncUnapplyCommands(commands, chunkSize, unapplyInReverseOrder = false) {
    if (unapplyInReverseOrder) {
      commands = [...commands];
      commands.reverse();
    }
    return this.asyncApplyOrUnapplyCommands(commands, false, chunkSize);
  }
  /**
   * Schedule a re-render for some time in the near future. Does not schedule an additional
   * re-render if a re-render is already queued.
   *
   * @returns a promise that resolves when re-rendering has completed.
   */
  queueRerender() {
    if (!this.rerenderQueued) {
      this.rerenderQueued = true;
      requestAnimationFrame(() => {
        if (this.rerenderQueued) {
          this.rerender();
          this.rerenderQueued = false;
        }
      });
    }
    return new Promise((resolve) => {
      this.nextRerenderListeners.push(() => resolve());
    });
  }
  // @internal
  isRerenderQueued() {
    return this.rerenderQueued;
  }
  /**
   * Re-renders the entire image.
   *
   * @see {@link Editor.queueRerender}
   */
  rerender(showImageBounds = true) {
    this.display.startRerender();
    if (this.display.width === 0 || this.display.height === 0) {
      return;
    }
    const renderer = this.display.getDryInkRenderer();
    this.image.renderWithCache(renderer, this.display.getCache(), this.viewport);
    if (showImageBounds && !this.image.getAutoresizeEnabled()) {
      const exportRectFill = { fill: Color4.fromHex("#44444455") };
      const exportRectStrokeWidth = 5 * this.viewport.getSizeOfPixelOnCanvas();
      renderer.drawRect(this.getImportExportRect(), exportRectStrokeWidth, exportRectFill);
    }
    this.rerenderQueued = false;
    this.nextRerenderListeners.forEach((listener) => listener());
    this.nextRerenderListeners = [];
  }
  /**
   * Draws the given path onto the wet ink renderer. The given path will
   * be displayed on top of the main image.
   *
   * @see {@link Display.getWetInkRenderer} {@link Display.flatten}
   */
  drawWetInk(...path) {
    for (const part of path) {
      this.display.getWetInkRenderer().drawPath(part);
    }
  }
  /**
   * Clears the wet ink display.
   *
   * The wet ink display can be used by the currently active tool to display a preview
   * of an in-progress action.
   *
   * @see {@link Display.getWetInkRenderer}
   */
  clearWetInk() {
    this.display.getWetInkRenderer().clear();
  }
  /**
   * Focuses the region used for text input/key commands.
   */
  focus() {
    this.renderingRegion.focus();
  }
  /**
   * Creates an element that will be positioned on top of the dry/wet ink
   * renderers.
   *
   * So as not to change the position of other overlays, `overlay` should either
   * be styled to have 0 height or have `position: absolute`.
   *
   * This is useful for displaying content on top of the rendered content
   * (e.g. a selection box).
   */
  createHTMLOverlay(overlay) {
    overlay.classList.add("overlay", "js-draw-editor-overlay");
    this.container.appendChild(overlay);
    return {
      remove: () => overlay.remove()
    };
  }
  /**
   * Anchors the given `element` to the canvas with a given position/transformation in canvas space.
   */
  anchorElementToCanvas(element, canvasTransform) {
    if (canvasTransform instanceof Mat33) {
      canvasTransform = ReactiveValue_default.fromImmutable(canvasTransform);
    }
    const overlay = document.createElement("div");
    overlay.classList.add("anchored-element-overlay");
    const contentWrapper = document.createElement("div");
    contentWrapper.classList.add("content-wrapper");
    element.classList.add("content");
    const updateElementPositioning = () => {
      const transform = canvasTransform.get();
      const canvasRotation = transform.transformVec3(Vec2.unitX).angle();
      const screenRotation = canvasRotation + this.viewport.getRotationAngle();
      const screenTransform = this.viewport.canvasToScreenTransform.rightMul(canvasTransform.get());
      overlay.style.setProperty("--full-transform", screenTransform.toCSSMatrix());
      const translation = screenTransform.transformVec2(Vec2.zero);
      overlay.style.setProperty("--position-x", `${translation.x}px`);
      overlay.style.setProperty("--position-y", `${translation.y}px`);
      overlay.style.setProperty("--rotation", `${screenRotation * 180 / Math.PI}deg`);
      overlay.style.setProperty("--scale", `${screenTransform.getScaleFactor()}`);
    };
    updateElementPositioning();
    const updateListener = canvasTransform.onUpdate(updateElementPositioning);
    const viewportListener = this.notifier.on(EditorEventType.ViewportChanged, updateElementPositioning);
    contentWrapper.appendChild(element);
    overlay.appendChild(contentWrapper);
    overlay.classList.add("overlay", "js-draw-editor-overlay");
    this.renderingRegion.insertAdjacentElement("afterend", overlay);
    return {
      remove: () => {
        overlay.remove();
        updateListener.remove();
        viewportListener.remove();
      }
    };
  }
  /**
   * Creates a CSS stylesheet with `content` and applies it to the document
   * (and thus, to this editor).
   */
  addStyleSheet(content) {
    const styleSheet = document.createElement("style");
    styleSheet.innerText = content;
    this.container.appendChild(styleSheet);
    return styleSheet;
  }
  /**
   * Dispatch a keyboard event to the currently selected tool.
   * Intended for unit testing.
   *
   * If `shiftKey` is undefined, it is guessed from `key`.
   *
   * At present, the **key code** dispatched is guessed from the given key and,
   * while this works for ASCII alphanumeric characters, this does not work for
   * most non-alphanumeric keys.
   *
   * Because guessing the key code from `key` is problematic, **only use this for testing**.
   */
  sendKeyboardEvent(eventType, key, ctrlKey = false, altKey = false, shiftKey = void 0) {
    shiftKey ?? (shiftKey = key.toUpperCase() === key && key.toLowerCase() !== key);
    this.toolController.dispatchInputEvent({
      kind: eventType,
      key,
      code: guessKeyCodeFromKey_default(key),
      ctrlKey,
      altKey,
      shiftKey
    });
  }
  /**
   * Dispatch a pen event to the currently selected tool.
   * Intended primarially for unit tests.
   *
   * @deprecated
   * @see {@link sendPenEvent} {@link sendTouchEvent}
   */
  sendPenEvent(eventType, point, allPointers) {
    sendPenEvent_default(this, eventType, point, allPointers);
  }
  /**
   * Adds all components in `components` such that they are in the center of the screen.
   * This is a convenience method that creates **and applies** a single command.
   *
   * If `selectComponents` is true (the default), the components are selected.
   *
   * `actionDescription`, if given, should be a screenreader-friendly description of the
   * reason components were added (e.g. "pasted").
   */
  async addAndCenterComponents(components, selectComponents = true, actionDescription) {
    let bbox = null;
    for (const component of components) {
      if (bbox) {
        bbox = bbox.union(component.getBBox());
      } else {
        bbox = component.getBBox();
      }
    }
    if (!bbox) {
      return;
    }
    const visibleRect = this.viewport.visibleRect;
    const scaleRatioX = visibleRect.width / bbox.width;
    const scaleRatioY = visibleRect.height / bbox.height;
    let scaleRatio = scaleRatioX;
    if (bbox.width * scaleRatio > visibleRect.width || bbox.height * scaleRatio > visibleRect.height) {
      scaleRatio = scaleRatioY;
    }
    scaleRatio *= 2 / 3;
    scaleRatio = Viewport_default.roundScaleRatio(scaleRatio);
    const transfm = Mat33.translation(visibleRect.center.minus(bbox.center)).rightMul(Mat33.scaling2D(scaleRatio, bbox.center));
    const commands = [];
    for (const component of components) {
      commands.push(EditorImage_default.addComponent(component));
      commands.push(component.transformBy(transfm));
    }
    const applyChunkSize = 100;
    await this.dispatch(uniteCommands_default(commands, { applyChunkSize, description: actionDescription }), true);
    if (selectComponents) {
      for (const selectionTool of this.toolController.getMatchingTools(SelectionTool)) {
        selectionTool.setEnabled(true);
        selectionTool.setSelection(components);
      }
    }
  }
  /**
   * Get a data URL (e.g. as produced by `HTMLCanvasElement::toDataURL`).
   * If `format` is not `image/png`, a PNG image URL may still be returned (as in the
   * case of `HTMLCanvasElement::toDataURL`).
   *
   * The export resolution is the same as the size of the drawing canvas, unless `outputSize`
   * is given.
   *
   * **Example**:
   * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]
   */
  toDataURL(format = "image/png", outputSize) {
    const { element: canvas, renderer } = CanvasRenderer.fromViewport(this.image.getImportExportViewport(), { canvasSize: outputSize });
    this.image.renderAll(renderer);
    const dataURL = canvas.toDataURL(format);
    return dataURL;
  }
  /**
   * Converts the editor's content into an SVG image.
   *
   * If the output SVG has width or height less than `options.minDimension`, its size
   * will be increased.
   *
   * @see
   * {@link SVGRenderer}
   */
  toSVG(options) {
    return editorImageToSVGSync(this.image, options ?? {});
  }
  /**
   * Converts the editor's content into an SVG image in an asynchronous,
   * but **potentially lossy** way.
   *
   * **Warning**: If the image is being edited during an async rendering, edited components
   * may not be rendered.
   *
   * Like {@link toSVG}, but can be configured to briefly pause after processing every
   * `pauseAfterCount` items. This can prevent the editor from becoming unresponsive
   * when saving very large images.
   */
  async toSVGAsync(options = {}) {
    const pauseAfterCount = options.pauseAfterCount ?? 100;
    return await editorImageToSVGAsync(this.image, async (_component, processedCount, totalComponents) => {
      if (options.onProgress) {
        const shouldContinue = await options.onProgress(processedCount, totalComponents);
        if (shouldContinue === false) {
          return false;
        }
      }
      if (processedCount % pauseAfterCount === 0) {
        await untilNextAnimationFrame_default();
      }
      return true;
    }, {
      minDimension: options.minDimension
    });
  }
  /**
   * Load editor data from an `ImageLoader` (e.g. an {@link SVGLoader}).
   *
   * @see loadFromSVG
   */
  async loadFrom(loader) {
    this.showLoadingWarning(0);
    this.display.setDraftMode(true);
    const originalBackgrounds = this.image.getBackgroundComponents();
    const eraseBackgroundCommand = new Erase_default(originalBackgrounds);
    await loader.start(async (component) => {
      await this.dispatchNoAnnounce(EditorImage_default.addComponent(component));
    }, (countProcessed, totalToProcess) => {
      if (countProcessed % 500 === 0) {
        this.showLoadingWarning(countProcessed / totalToProcess);
        this.rerender();
        return untilNextAnimationFrame_default();
      }
      return null;
    }, (importExportRect, options) => {
      this.dispatchNoAnnounce(this.setImportExportRect(importExportRect), false);
      this.dispatchNoAnnounce(this.viewport.zoomTo(importExportRect), false);
      if (options) {
        this.dispatchNoAnnounce(this.image.setAutoresizeEnabled(options.autoresize), false);
      }
    });
    if (this.image.getBackgroundComponents().length !== originalBackgrounds.length) {
      await this.dispatchNoAnnounce(eraseBackgroundCommand);
    }
    this.hideLoadingWarning();
    this.display.setDraftMode(false);
    this.queueRerender();
  }
  getTopmostBackgroundComponent() {
    let background = null;
    for (const component of this.image.getBackgroundComponents()) {
      if (component instanceof BackgroundComponent) {
        background = component;
      }
    }
    return background;
  }
  /**
   * This is a convenience method for adding or updating the {@link BackgroundComponent}
   * and {@link EditorImage.setAutoresizeEnabled} for the current image.
   *
   * If there are multiple {@link BackgroundComponent}s in the image, this only modifies
   * the topmost such element.
   *
   * **Example**:
   * ```ts,runnable
   * import { Editor, Color4, BackgroundComponentBackgroundType } from 'js-draw';
   * const editor = new Editor(document.body);
   * editor.dispatch(editor.setBackgroundStyle({
   *     color: Color4.orange,
   *     type: BackgroundComponentBackgroundType.Grid,
   *     autoresize: true,
   * }));
   * ```
   *
   * To change the background size, see {@link EditorImage.setImportExportRect}.
   */
  setBackgroundStyle(style) {
    var _a6, _b2;
    const originalBackground = this.getTopmostBackgroundComponent();
    const commands = [];
    if (originalBackground) {
      commands.push(new Erase_default([originalBackground]));
    }
    const originalType = ((_a6 = originalBackground == null ? void 0 : originalBackground.getBackgroundType) == null ? void 0 : _a6.call(originalBackground)) ?? BackgroundType.None;
    const originalColor = ((_b2 = originalBackground == null ? void 0 : originalBackground.getStyle) == null ? void 0 : _b2.call(originalBackground).color) ?? Color4.transparent;
    const originalFillsScreen = this.image.getAutoresizeEnabled();
    const defaultType = style.color && originalType === BackgroundType.None ? BackgroundType.SolidColor : originalType;
    const backgroundType = style.type ?? defaultType;
    const backgroundColor = style.color ?? originalColor;
    const fillsScreen = style.autoresize ?? originalFillsScreen;
    if (backgroundType !== BackgroundType.None) {
      const newBackground = new BackgroundComponent(backgroundType, backgroundColor);
      commands.push(EditorImage_default.addComponent(newBackground));
    }
    if (fillsScreen !== originalFillsScreen) {
      commands.push(this.image.setAutoresizeEnabled(fillsScreen));
      if (!fillsScreen && this.image.getImportExportRect().maxDimension === 0) {
        commands.push(this.image.setImportExportRect(this.image.getImportExportRect().resizedTo(Vec2.of(500, 500))));
      }
    }
    return uniteCommands_default(commands);
  }
  /**
   * Set the background color of the image.
   *
   * This is a convenience method for adding or updating the {@link BackgroundComponent}
   * for the current image.
   *
   * @see {@link setBackgroundStyle}
   */
  setBackgroundColor(color) {
    let background = this.getTopmostBackgroundComponent();
    if (!background) {
      const backgroundType = color.eq(Color4.transparent) ? BackgroundType.None : BackgroundType.SolidColor;
      background = new BackgroundComponent(backgroundType, color);
      return this.image.addComponent(background);
    } else {
      return background.updateStyle({ color });
    }
  }
  /**
   * @returns the average of the colors of all background components. Use this to get the current background
   * color.
   */
  estimateBackgroundColor() {
    const backgroundColors = [];
    for (const component of this.image.getBackgroundComponents()) {
      if (component instanceof BackgroundComponent) {
        backgroundColors.push(component.getStyle().color ?? Color4.transparent);
      }
    }
    return Color4.average(backgroundColors);
  }
  // Returns the size of the visible region of the output SVG
  getImportExportRect() {
    return this.image.getImportExportViewport().visibleRect;
  }
  // Resize the output SVG to match `imageRect`.
  setImportExportRect(imageRect) {
    return this.image.setImportExportRect(imageRect);
  }
  /**
   * Alias for `loadFrom(SVGLoader.fromString)`.
   *
   * @example
   * ```ts,runnable
   * import {Editor} from 'js-draw';
   * const editor = new Editor(document.body);
   *
   * ---visible---
   * await editor.loadFromSVG(`
   *   <svg viewBox="5 23 52 30" width="52" height="16" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
   *     <text style="
   *       transform: matrix(0.181846, 0.1, 0, 0.181846, 11.4, 33.2);
   *       font-family: serif;
   *       font-size: 32px;
   *       fill: rgb(100, 140, 61);
   *     ">An SVG image!</text>
   *   </svg>
   * `);
   * ```
   */
  async loadFromSVG(svgData, sanitize = false) {
    var _a6;
    const loader = SVGLoader.fromString(svgData, {
      sanitize,
      plugins: (_a6 = this.getCurrentSettings().svg) == null ? void 0 : _a6.loaderPlugins
    });
    await this.loadFrom(loader);
  }
  /**
   * Shows an information dialog with legal notices.
   */
  showAboutDialog() {
    var _a6;
    const iconLicenseText = this.icons.licenseInfo();
    const notices = [];
    if (this.settings.appInfo) {
      const descriptionLines = [];
      if (this.settings.appInfo.version) {
        descriptionLines.push(`v${this.settings.appInfo.version}`, "");
      }
      if (this.settings.appInfo.description) {
        descriptionLines.push(this.settings.appInfo.description + "\n");
      } else {
        descriptionLines.push(`js-draw v${version_default.number}`);
      }
      notices.push({
        heading: `${this.settings.appInfo.name}`,
        text: descriptionLines.join("\n")
      });
    } else {
      notices.push({
        heading: "js-draw",
        text: `v${version_default.number}`
      });
    }
    const screenSize = this.viewport.getScreenRectSize();
    notices.push({
      heading: this.localization.developerInformation,
      text: [
        "Image debug information (from when this dialog was opened):",
        `    ${this.viewport.getScaleFactor()}x zoom, ${180 / Math.PI * this.viewport.getRotationAngle()}° rotation`,
        `    ${this.image.estimateNumElements()} components`,
        `    auto-resize: ${this.image.getAutoresizeEnabled() ? "enabled" : "disabled"}`,
        `    image size: ${this.getImportExportRect().w}x${this.getImportExportRect().h}`,
        `    screen size: ${screenSize.x}x${screenSize.y}`,
        `    device pixel ratio: ${this.display.getDevicePixelRatio()}`,
        "    cache:",
        `        ${this.display.getCache().getDebugInfo().replace(/([\n])/g, "\n        ")}`
      ].join("\n"),
      minimized: true
    });
    notices.push({
      heading: this.localization.softwareLibraries,
      text: [
        `This image editor is powered by js-draw v${version_default.number}.`,
        "",
        "At runtime, js-draw uses",
        " - The Coloris color picker: https://github.com/mdbassit/Coloris",
        " - The bezier.js Bézier curve library: https://github.com/Pomax/bezierjs",
        "",
        "Both are licensed under the MIT license:",
        "",
        "",
        "== Coloris ==",
        mitLicenseAttribution_default("2021 Mohammed Bassit"),
        "",
        "",
        "== Bezier.js ==",
        mitLicenseAttribution_default('2023 Mike "Pomax" Kamermans'),
        "",
        "",
        "== js-draw ==",
        mitLicenseAttribution_default("2023-2025 Henry Heino"),
        ""
      ].join("\n"),
      minimized: true
    });
    if (iconLicenseText) {
      notices.push({
        heading: "Icon Pack",
        text: iconLicenseText,
        minimized: true
      });
    }
    notices.push(...this.settings.notices);
    (_a6 = this.closeAboutDialog) == null ? void 0 : _a6.call(this);
    this.closeAboutDialog = makeAboutDialog_default(this, notices).close;
  }
  /**
   * Removes and **destroys** the editor. The editor cannot be added to a parent
   * again after calling this method.
   */
  remove() {
    this.container.remove();
    this.toolController.onEditorDestroyed();
  }
};
var Editor_default = Editor;

// node_modules/js-draw/dist/mjs/commands/invertCommand.mjs
var invertCommand = (command) => {
  if (command instanceof SerializableCommand_default) {
    return new class extends SerializableCommand_default {
      constructor() {
        super(...arguments);
        this._command = command;
      }
      serializeToJSON() {
        return command.serialize();
      }
      apply(editor) {
        command.unapply(editor);
      }
      unapply(editor) {
        command.apply(editor);
      }
      onDrop(editor) {
        command.onDrop(editor);
      }
      description(editor, localizationTable) {
        return localizationTable.inverseOf(command.description(editor, localizationTable));
      }
    }("inverse");
  } else {
    const result = new class extends Command_default {
      apply(editor) {
        command.unapply(editor);
      }
      unapply(editor) {
        command.apply(editor);
      }
      onDrop(editor) {
        command.onDrop(editor);
      }
      description(editor, localizationTable) {
        return localizationTable.inverseOf(command.description(editor, localizationTable));
      }
    }();
    return result;
  }
};
SerializableCommand_default.register("inverse", (data, editor) => {
  return invertCommand(SerializableCommand_default.deserialize(data, editor));
});
var invertCommand_default = invertCommand;

// node_modules/js-draw/dist/mjs/toolbar/widgets/OverflowWidget.mjs
var OverflowWidget = class extends BaseWidget_default {
  constructor(editor, localizationTable) {
    super(editor, "overflow-widget", localizationTable);
    this.overflowChildren = [];
    this.container.classList.add("toolbar-overflow-widget");
    this.container.classList.add("dropdownShowable");
    this.overflowContainer ?? (this.overflowContainer = document.createElement("div"));
  }
  shouldAutoDisableInReadOnlyEditor() {
    return false;
  }
  getTitle() {
    return this.localizationTable.toggleOverflow;
  }
  createIcon() {
    return this.editor.icons.makeOverflowIcon();
  }
  handleClick() {
    this.setDropdownVisible(!this.isDropdownVisible());
  }
  fillDropdown(dropdown) {
    this.overflowContainer ?? (this.overflowContainer = document.createElement("div"));
    if (this.overflowContainer.parentElement) {
      this.overflowContainer.remove();
    }
    this.overflowContainer.classList.add("toolbar-overflow-widget-overflow-list");
    dropdown.appendChild(this.overflowContainer);
    return true;
  }
  /**
   * Removes all `BaseWidget`s from this and returns them.
   */
  clearChildren() {
    this.overflowContainer.replaceChildren();
    this.container.classList.remove("horizontal");
    const overflowChildren = this.overflowChildren;
    this.overflowChildren = [];
    return overflowChildren;
  }
  getChildWidgets() {
    return [...this.overflowChildren];
  }
  hasAsChild(widget) {
    for (const otherWidget of this.overflowChildren) {
      if (widget === otherWidget) {
        return true;
      }
    }
    return false;
  }
  /**
   * Adds `widget` to this.
   * `widget`'s previous parent is still responsible
   * for serializing/deserializing its state.
   */
  addToOverflow(widget) {
    this.overflowChildren.push(widget);
    widget.addTo(this.overflowContainer);
    widget.setIsToplevel(false);
    if (this.overflowChildren.length > 2) {
      this.container.classList.add("horizontal");
    }
  }
  // This always returns false.
  // Don't try to move the overflow menu to itself.
  canBeInOverflowMenu() {
    return false;
  }
};

// node_modules/js-draw/dist/mjs/toolbar/DropdownToolbar.mjs
var makeDropdownToolbar = (editor) => {
  return new DropdownToolbar(editor, editor.getRootElement(), editor.localization);
};
var DropdownToolbar = class extends AbstractToolbar_default {
  /** @internal */
  constructor(editor, parent, localizationTable) {
    super(editor, localizationTable);
    this.widgetOrderCounter = 0;
    this.overflowWidget = null;
    this.reLayoutQueued = false;
    this.container = document.createElement("div");
    this.container.classList.add(`${toolbarCSSPrefix}root`);
    this.container.classList.add(`${toolbarCSSPrefix}element`);
    this.container.classList.add(`${toolbarCSSPrefix}dropdown-toolbar`);
    this.container.setAttribute("role", "toolbar");
    parent.appendChild(this.container);
    if ("ResizeObserver" in window) {
      this.resizeObserver = new ResizeObserver((_entries) => {
        this.reLayout();
      });
      this.resizeObserver.observe(this.container);
    } else {
      console.warn("ResizeObserver not supported. Toolbar will not resize.");
    }
  }
  queueReLayout() {
    if (!this.reLayoutQueued) {
      this.reLayoutQueued = true;
      requestAnimationFrame(() => this.reLayout());
    }
  }
  reLayout() {
    this.reLayoutQueued = false;
    if (!this.overflowWidget) {
      return;
    }
    const getTotalWidth = (widgetList) => {
      let totalWidth = 0;
      for (const widget of widgetList) {
        if (!widget.isHidden()) {
          totalWidth += widget.getButtonWidth();
        }
      }
      return totalWidth;
    };
    const canRemoveFirstChildFromOverflow = (freeSpaceInMainMenu) => {
      var _a6;
      const overflowChildren = ((_a6 = this.overflowWidget) == null ? void 0 : _a6.getChildWidgets()) ?? [];
      if (overflowChildren.length === 0) {
        return false;
      }
      return overflowChildren[0].getButtonWidth() <= freeSpaceInMainMenu;
    };
    const allWidgets = this.getAllWidgets();
    let overflowWidgetsWidth = getTotalWidth(this.overflowWidget.getChildWidgets());
    let shownWidgetWidth = getTotalWidth(allWidgets) - overflowWidgetsWidth;
    let availableWidth = this.container.clientWidth * 0.87;
    if (window.innerHeight > availableWidth * 1.75) {
      availableWidth *= 1.75;
    }
    let updatedChildren = false;
    if (canRemoveFirstChildFromOverflow(availableWidth - shownWidgetWidth)) {
      const overflowChildren = this.overflowWidget.clearChildren();
      for (const child of overflowChildren) {
        child.addTo(this.container);
        child.setIsToplevel(true);
        if (!child.isHidden()) {
          shownWidgetWidth += child.getButtonWidth();
        }
      }
      overflowWidgetsWidth = 0;
      updatedChildren = true;
    }
    if (shownWidgetWidth >= availableWidth) {
      for (let i = allWidgets.length - 1; i >= 0 && shownWidgetWidth >= availableWidth; i--) {
        const child = allWidgets[i];
        if (this.overflowWidget.hasAsChild(child)) {
          continue;
        }
        if (child.canBeInOverflowMenu()) {
          shownWidgetWidth -= child.getButtonWidth();
          this.overflowWidget.addToOverflow(child);
        }
      }
      updatedChildren = true;
    }
    this.overflowWidget.setHidden(this.overflowWidget.getChildWidgets().length === 0);
    if (updatedChildren) {
      this.setupColorPickers();
    }
  }
  addWidgetInternal(widget) {
    const container = widget.addTo(this.container);
    container.style.order = `${this.widgetOrderCounter++}`;
    this.queueReLayout();
  }
  removeWidgetInternal(widget) {
    widget.remove();
    this.queueReLayout();
  }
  addSpacer(options = {}) {
    const spacer = document.createElement("div");
    spacer.classList.add(`${toolbarCSSPrefix}spacer`);
    if (options.grow) {
      spacer.style.flexGrow = `${options.grow}`;
    }
    if (options.minSize) {
      spacer.style.minWidth = options.minSize;
    }
    if (options.maxSize) {
      spacer.style.maxWidth = options.maxSize;
    }
    spacer.style.order = `${this.widgetOrderCounter++}`;
    this.container.appendChild(spacer);
  }
  /**
   * Adds a widget that toggles the overflow menu. Call `addOverflowWidget` to ensure
   * that this widget is in the correct space (if shown).
   *
   * @example
   * ```ts
   * toolbar.addDefaultToolWidgets();
   * toolbar.addOverflowWidget();
   * toolbar.addDefaultActionButtons();
   * ```
   * shows the overflow widget between the default tool widgets and the default action buttons,
   * if shown.
   */
  addOverflowWidget() {
    this.overflowWidget = new OverflowWidget(this.editor, this.localizationTable);
    this.addWidget(this.overflowWidget);
  }
  /**
   * Adds both the default tool widgets and action buttons. Equivalent to
   * ```ts
   * toolbar.addDefaultToolWidgets();
   * toolbar.addOverflowWidget();
   * toolbar.addDefaultActionButtons();
   * ```
   */
  addDefaults() {
    this.addDefaultToolWidgets();
    this.addOverflowWidget();
    this.addDefaultActionButtons();
  }
  onRemove() {
    this.container.remove();
    this.resizeObserver.disconnect();
  }
};

// node_modules/js-draw/dist/mjs/testing/sendTouchEvent.mjs
var sendTouchEvent = (editor, eventType, screenPos, allOtherPointers) => {
  const canvasPos = editor.viewport.screenToCanvas(screenPos);
  const ptrId = getUniquePointerId_default(allOtherPointers ?? []);
  const mainPointer = Pointer.ofCanvasPoint(canvasPos, eventType !== InputEvtType.PointerUpEvt, editor.viewport, ptrId, PointerDevice.Touch);
  editor.toolController.dispatchInputEvent({
    kind: eventType,
    allPointers: [...allOtherPointers ?? [], mainPointer],
    current: mainPointer
  });
  return mainPointer;
};
var sendTouchEvent_default = sendTouchEvent;

// node_modules/js-draw/dist/mjs/util/adjustEditorThemeForContrast.mjs
var adjustEditorThemeForContrast = (editor, options) => {
  const editorElem = editor.getRootElement();
  const colorPairs = [
    ["--background-color-1", "--foreground-color-1", true, true],
    ["--background-color-2", "--foreground-color-2", true, true],
    ["--background-color-3", "--foreground-color-3", true, true],
    ["--background-color-2", "--primary-action-foreground-color", false, true],
    ["--selection-background-color", "--selection-foreground-color", false, true]
  ];
  if (!(options == null ? void 0 : options.dontClearOverrides)) {
    for (const [backgroundVar, foregroundVar] of colorPairs) {
      editorElem.style.setProperty(backgroundVar, null);
      editorElem.style.setProperty(foregroundVar, null);
    }
  }
  const styles = getComputedStyle(editorElem);
  const updatedColors = /* @__PURE__ */ Object.create(null);
  const adjustVariablesForContrast = (var1, var2, minContrast, updateVar1, updateVar2) => {
    let color1 = updatedColors[var1] ? updatedColors[var1] : Color4.fromString(styles.getPropertyValue(var1));
    let color2 = updatedColors[var2] ? updatedColors[var2] : Color4.fromString(styles.getPropertyValue(var2));
    if (color1.relativeLuminance() < color2.relativeLuminance()) {
      const tmp = color1;
      color1 = color2;
      color2 = tmp;
      const oldVar2 = var2;
      var2 = var1;
      var1 = oldVar2;
      const oldUpdateVar1 = updateVar1;
      updateVar1 = updateVar2;
      updateVar2 = oldUpdateVar1;
    }
    let colorsUpdated = false;
    let currentContrast = Color4.contrastRatio(color1, color2);
    let iterations = 0;
    while (currentContrast < minContrast && iterations < 8) {
      const step = Vec3.of(0.1, 0.1, 0.1);
      if (updateVar1) {
        if (color2.eq(Color4.white) && !updateVar2) {
          color2 = Color4.black;
        }
        color1 = Color4.fromRGBVector(color1.rgb.plus(step));
      }
      if (updateVar2) {
        if (color2.eq(Color4.black) && !updateVar1) {
          color2 = Color4.white;
        }
        color2 = Color4.fromRGBVector(color2.rgb.minus(step));
      }
      currentContrast = Color4.contrastRatio(color1, color2);
      colorsUpdated = true;
      iterations++;
    }
    if (colorsUpdated) {
      editorElem.style.setProperty(var1, color1.toHexString());
      editorElem.style.setProperty(var2, color2.toHexString());
      updatedColors[var1] = color1;
      updatedColors[var2] = color2;
    }
  };
  adjustVariablesForContrast("--selection-background-color", "--background-color-2", 1.29, true, false);
  for (const [backgroundVar, foregroundVar, updateBackground, updateForeground] of colorPairs) {
    const minContrast = 4.5;
    adjustVariablesForContrast(backgroundVar, foregroundVar, minContrast, updateBackground, updateForeground);
  }
};
var adjustEditorThemeForContrast_default = adjustEditorThemeForContrast;

// node_modules/js-draw/dist/mjs/lib.mjs
var lib_default = Editor_default;
export {
  Abstract2DShape,
  AbstractComponent_default as AbstractComponent,
  AbstractRenderer,
  AbstractToolbar_default as AbstractToolbar,
  ActionButtonWidget_default as ActionButtonWidget,
  BackgroundComponent,
  BackgroundType as BackgroundComponentBackgroundType,
  BaseTool_default as BaseTool,
  BaseToolWidget,
  BaseWidget_default as BaseWidget,
  CanvasRenderer,
  Color4,
  Command_default as Command,
  ComponentSizingMode,
  Display,
  DocumentPropertiesWidget_default as DocumentPropertiesWidget,
  DummyRenderer,
  Duplicate_default as Duplicate,
  Editor_default as Editor,
  EditorEventType,
  EditorImage_default as EditorImage,
  Erase_default as Erase,
  EraserMode,
  Eraser as EraserTool,
  EraserToolWidget_default as EraserToolWidget,
  EventDispatcher,
  AbstractToolbar_default as HTMLToolbar,
  HandToolWidget,
  IconProvider_default as IconProvider,
  ImageComponent,
  InputEvtType,
  InputMapper_default as InputMapper,
  InsertImageWidget_default as InsertImageWidget,
  KeyBinding,
  KeyboardShortcutManager_default as KeyboardShortcutManager,
  LineSegment2,
  Mat33,
  MutableReactiveValue,
  PanZoomMode,
  PanZoom as PanZoomTool,
  Parameterized2DShape,
  PasteHandler,
  Path,
  PathCommandType,
  Pen as PenTool,
  PenToolWidget_default as PenToolWidget,
  Pointer,
  PointerDevice,
  QuadraticBezier,
  ReactiveValue,
  Rect2,
  RenderingMode,
  SVGLoader,
  SVGRenderer,
  SelectAllShortcutHandler,
  SelectionMode,
  SelectionTool,
  SelectionToolWidget,
  SerializableCommand_default as SerializableCommand,
  SoundUITool,
  Stroke,
  Stroke as StrokeComponent,
  StrokeSmoother_default as StrokeSmoother,
  TextComponent_default as Text,
  TextComponent_default as TextComponent,
  TextTool,
  TextToolWidget_default as TextToolWidget,
  ToolController,
  ToolEnabledGroup,
  ToolSwitcherShortcut,
  ToolbarShortcutHandler,
  ToolbarWidgetTag,
  UndoEventType,
  UndoRedoHistory_default as UndoRedoHistory,
  UndoRedoShortcut,
  Vec2,
  Vec3,
  Viewport_default as Viewport,
  version_default as __js_draw__version,
  adjustEditorThemeForContrast_default as adjustEditorThemeForContrast,
  compareCurveIndices as comparePathIndices,
  createRestyleComponentCommand,
  lib_default as default,
  defaultEditorLocalization,
  getLocalizationTable_default as getLocalizationTable,
  invertCommand_default as invertCommand,
  isPointerEvt,
  isRestylableComponent,
  keyPressEventFromHTMLEvent,
  keyUpEventFromHTMLEvent,
  makeArrowBuilder,
  makeColorInput,
  makeDropdownToolbar,
  makeEdgeToolbar,
  makeFilledRectangleBuilder,
  makeFreehandLineBuilder,
  makeLineBuilder,
  makeOutlinedCircleBuilder,
  makeOutlinedRectangleBuilder,
  makePolylineBuilder,
  makePressureSensitiveFreehandLineBuilder,
  matchingLocalizationTable,
  pathFromRenderable,
  pathToRenderable,
  visualEquivalent as pathVisualEquivalent,
  sendPenEvent_default as sendPenEvent,
  sendTouchEvent_default as sendTouchEvent,
  stepCurveIndexBy as stepPathIndexBy,
  toRoundedString,
  uniteCommands_default as uniteCommands
};
/*! Bundled license information:

@melloware/coloris/dist/esm/coloris.js:
  (*!
  * Copyright (c) 2021-2023 Momo Bassit.
  * Licensed under the MIT License (MIT)
  * https://github.com/mdbassit/Coloris
  * Version: 0.21.1
  * NPM: https://github.com/melloware/coloris-npm
  *)
*/
//# sourceMappingURL=js-draw.js.map
